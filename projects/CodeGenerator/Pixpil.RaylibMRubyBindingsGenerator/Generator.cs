// #define LOG_TODO
#define WRITE_ENUM
#define WRITE_CLASS
#define WRITE_FUNCTION
using System.Text;
using System.Text.RegularExpressions;
using CppAst;


namespace Pixpil.RaylibMRubyBindingsGenerator;

public static class Generator {
	
	public const int TargetRaylibVersionNum = 500;
	
	public readonly static string[] KSupportedTypedefCallbacks = [
		"TraceLogCallback",
		"LoadFileDataCallback",
		"SaveFileDataCallback",
		"LoadFileTextCallback",
		"SaveFileTextCallback"
	];

	public readonly static string[] KSupportedEnums = [
		"ConfigFlags",
		"TraceLogLevel",
		"KeyboardKey",
		"MouseButton",
		"MouseCursor",
		"GamepadButton",
		"GamepadAxis",
		"MaterialMapIndex",
		"ShaderLocationIndex",
		"ShaderUniformDataType",
		"ShaderAttributeDataType",
		"PixelFormat",
		"TextureFilter",
		"TextureWrap",
		"CubemapLayout",
		"FontType",
		"BlendMode",
		"Gesture",
		"CameraMode",
		"CameraProjection",
		"NPatchLayout"
	];
	
	public readonly static string[] KSupportedStructs = [
		"Vector2",
		"Vector3",
		"Vector4",
		"Quaternion",
		"Matrix",
		"Color",
		"Rectangle",
		"Image",
		"Texture",
		"Texture2D",
		"TextureCubemap",
		"RenderTexture",
		"RenderTexture2D",
		"NPatchInfo",
		"GlyphInfo",
		"Font",
		"Camera3D",
		"Camera",
		"Camera2D",
		"Mesh",
		"Shader",
		"MaterialMap",
		"Material",
		"Transform",
		"BoneInfo",
		"Model",
		"ModelAnimation",
		"Ray",
		"RayCollision",
		"BoundingBox",
		"Wave",
		"rAudioBuffer",
		"rAudioProcessor",
		"AudioStream",
		"Sound",
		"Music",
		"VrDeviceInfo",
		"VrStereoConfig",
		"FilePathList",
		"AutomationEvent",
		"AutomationEventList"
	];

	public readonly static string[] KSkippedMacros = [
		"__GCC_HAVE_DWARF2_CFI_ASM",
		"RAYLIB_H",
		"__STDARG_H",
		"_VA_LIST",
		"va_start",
		"va_end",
		"va_arg",
		"__va_copy",
		"va_copy",
		"__GNUC_VA_LIST",
		"RAYLIB_VERSION_MAJOR",
		"RAYLIB_VERSION_MINOR",
		"RAYLIB_VERSION_PATCH",
		"RAYLIB_VERSION",
		"RLAPI",
		"PI",
		"DEG2RAD",
		"RAD2DEG",
		"RL_MALLOC",
		"RL_CALLOC",
		"RL_REALLOC",
		"RL_FREE",
		"CLITERAL",
		"RL_COLOR_TYPE",
		"RL_RECTANGLE_TYPE",
		"RL_VECTOR2_TYPE",
		"RL_VECTOR3_TYPE",
		"RL_VECTOR4_TYPE",
		"RL_QUATERNION_TYPE",
		"RL_MATRIX_TYPE"
	];
	
	
	public static string Parse( string raylibPath ) {
		
		// Console.WriteLine( $"Environment.OSVersion.Platform: {Environment.OSVersion.Platform}" );
		CppParserOptions options = new CppParserOptions();
		if ( Environment.OSVersion.Platform == PlatformID.Unix ) {
			options.TargetSystem = "darwin";
			options.TargetCpu = CppTargetCpu.X86_64;
			options.IncludeFolders.Add( @"/opt/homebrew/Cellar/llvm/17.0.6/include" );
			options.IncludeFolders.Add( @"/opt/homebrew/Cellar/llvm/17.0.6/include/c++/v1" );
			options.IncludeFolders.Add( @"/opt/homebrew/Cellar/llvm/17.0.6/lib/clang/17/include" );
			options.IncludeFolders.Add( @"/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include" );
			options.IncludeFolders.Add( @"/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/System/Library/Frameworks/Kernel.framework/Headers" );
			// options.Defines.Add( "__cplusplus" );
		}
		options.IncludeFolders.Add( raylibPath );
		CppCompilation compilation = CppParser.ParseFiles(
			[
				// Path.Combine( raylibPath, "raudio.c" ),
				Path.Combine( raylibPath, "raylib.h" )
			],
			options
		);

		if ( compilation.HasErrors ) {
			foreach ( var msg in compilation.Diagnostics.Messages ) {
				Console.WriteLine( $"{msg.Text}" );
			}
			return string.Empty;
		}

		var parsedFunctionNames = new List< string >();
		StringBuilder output = new StringBuilder();
		output.AppendLine( "// this file generated by RaylibMRubyBindingsGenerator, DO NOT EDIT\n" );

		var functionCount = 0;
		
		CppMacro versionMacroDefine = compilation.Macros.FirstOrDefault( ma => ma.Name == "RAYLIB_VERSION" );
		if ( versionMacroDefine != null ) {
			output.AppendLine( $"// RAYLIB_VERSION: {versionMacroDefine.Value}" );
		}

		int majorNum, minorNum, patchNum;
		versionMacroDefine = compilation.Macros.FirstOrDefault( ma => ma.Name == "RAYLIB_VERSION_MAJOR" );
		majorNum = Convert.ToInt32( versionMacroDefine.Value ) * 100;
		versionMacroDefine = compilation.Macros.FirstOrDefault( ma => ma.Name == "RAYLIB_VERSION_MINOR" );
		minorNum = Convert.ToInt32( versionMacroDefine.Value ) * 10;
		versionMacroDefine = compilation.Macros.FirstOrDefault( ma => ma.Name == "RAYLIB_VERSION_PATCH" );
		patchNum = Convert.ToInt32( versionMacroDefine.Value );

		versionMacroDefine = compilation.Macros.FirstOrDefault( ma => ma.Name == "RAYLIB_VERSION" );
		if ( versionMacroDefine != null ) {
			if ( majorNum + minorNum + patchNum > TargetRaylibVersionNum ) {
				Console.WriteLine( $"[Warning] Raylib Version maybe not support: {versionMacroDefine.Value}" );
			}
		}
		
		// mod header
		output.AppendLine( @"#include ""rMRuby.h""
#include ""raudio.c""
#include <mruby/class.h>
#include <mruby/data.h>
#include <mruby/array.h>
#include <mruby/string.h>

RMRUBY_API struct RClass *mod_RayLib;
RMRUBY_API struct RClass *class_RayLibError;
		" );
		
		// forward class define
		foreach ( var klass in compilation.Classes ) {

			if ( !KSupportedStructs.Contains( klass.Name ) ) {
				continue;
			}

			var klassName = klass.Name;
			var lowerKlassName = klass.Name.ToLower();
			
			output.Append( "//----------------------------------------------------------------//\n" );
			output.Append( $"// Raylib::{klassName}\n" );
			
			// RClass var
			output.AppendLine( $"static struct RClass *class_{klassName};\n" );
			
			// RClass data_t
			output.AppendLine( @$"typedef struct class_raylib_{lowerKlassName}_data_t {{
	bool is_associated;
	{klassName} {lowerKlassName};
}} class_raylib_{lowerKlassName}_data_t;
		" );
			
			// RClass dfree
			output.AppendLine( @$"static void
class_raylib_{lowerKlassName}_data_free( mrb_state *mrb, void *p ) {{
	class_raylib_{lowerKlassName}_data_t *data = ( class_raylib_{lowerKlassName}_data_t* )p;
	if ( NULL != data ) {{
		mrb_free( mrb, data );
	}}
}}
" );
			
			// data type define
			output.AppendLine( @$"static struct mrb_data_type const class_raylib_{lowerKlassName}_data_type = {{
	""{klassName}"", class_raylib_{lowerKlassName}_data_free
}};
" );
			
			// 
			output.AppendLine( $@"mrb_value
class_raylib_{lowerKlassName}_2_mrbvalue( mrb_state *mrb, {klassName} *{lowerKlassName}, bool is_associated ) {{
	class_raylib_{lowerKlassName}_data_t *data = ( class_raylib_{lowerKlassName}_data_t* )mrb_malloc( mrb, sizeof( class_raylib_{lowerKlassName}_data_t ) );
	if ( NULL == data ) {{
		mrb_raise( mrb, E_RUNTIME_ERROR, ""insufficient memory."" );
	}}
	data->is_associated = is_associated;
	data->{lowerKlassName} = *{lowerKlassName};
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_{klassName}, &class_raylib_{lowerKlassName}_data_type, data ) );
}}
" );
			
// 			output.AppendLine( $@"mrb_value
// class_raylib_{lowerKlassName}_ref_2_mrbvalue( mrb_state *mrb, {klassName}& {lowerKlassName}, bool is_associated ) {{
// 	class_raylib_{lowerKlassName}_data_t *data = ( class_raylib_{lowerKlassName}_data_t* )mrb_malloc( mrb, sizeof( class_raylib_{lowerKlassName}_data_t ) );
// 	if ( NULL == data ) {{
// 		mrb_raise( mrb, E_RUNTIME_ERROR, ""insufficient memory."" );
// 	}}
// 	data->is_associated = is_associated;
// 	data->{lowerKlassName} = {lowerKlassName};
// 	return mrb_obj_value( Data_Wrap_Struct( mrb, class_{klassName}, &class_raylib_{lowerKlassName}_data_type, data ) );
// }}
// " );
			
			// copy
			output.AppendLine( $@"mrb_value
class_raylib_{lowerKlassName}_2_mrbvalue_direct( mrb_state *mrb, {klassName} const *{lowerKlassName} ) {{
	class_raylib_{lowerKlassName}_data_t *data = ( class_raylib_{lowerKlassName}_data_t* )mrb_malloc( mrb, sizeof( class_raylib_{lowerKlassName}_data_t ) );
	if ( NULL == data ) {{
		mrb_raise( mrb, E_RUNTIME_ERROR, ""insufficient memory."" );
	}}
	if ( NULL == {lowerKlassName} ) {{
		// Do init
	}} else {{
		// Do Copy
		data->{lowerKlassName} = *{lowerKlassName};
	}}
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_{klassName}, &class_raylib_{lowerKlassName}_data_type, data ) );
}}
" );

			output.AppendLine( $@"{klassName}*
class_raylib_{lowerKlassName}_get_ptr( mrb_state *mrb, mrb_value {lowerKlassName} ) {{
	class_raylib_{lowerKlassName}_data_t *data;
	if ( mrb_nil_p( {lowerKlassName} ) ) {{
		return NULL;
	}}
	data = ( class_raylib_{lowerKlassName}_data_t* )mrb_data_get_ptr( mrb, {lowerKlassName}, &class_raylib_{lowerKlassName}_data_type );
	return &data->{lowerKlassName};
}}
" );

			output.AppendLine( $@"static mrb_value
class_raylib_{lowerKlassName}_initialize( mrb_state *mrb, mrb_value self ) {{
	class_raylib_{lowerKlassName}_data_t *data = DATA_PTR( self );

	if ( NULL == data ) {{
		data = mrb_malloc( mrb, sizeof( class_raylib_{lowerKlassName}_data_t ) );
		if ( NULL == data ) {{
			mrb_raise( mrb, E_RUNTIME_ERROR, ""insufficient memory."" );
		}}
		//data->{lowerKlassName} = {{ 0 }};
	}} else {{
		// if ( NULL != &( data->{lowerKlassName} ) ) {{
		// 
		// }}
	}}
	{klassName} {lowerKlassName} = {{ 0 }};
	data->{lowerKlassName} = {lowerKlassName};
	// if ( NULL == &( data->{lowerKlassName} ) ) {{
	//	mrb_free( mrb, data );
	// }}
	DATA_PTR( self ) = data;
	DATA_TYPE( self ) = &class_raylib_{lowerKlassName}_data_type;
	return self;
}}
" );
			
			// TODO: field get/set
			foreach ( var field in klass.Fields ) {
				var isPointerField = field.Type.TypeKind == CppTypeKind.Pointer;
				// var derefPointerPlaceholder = isPointerField ? "&" : string.Empty;

				if ( field.Type is not CppArrayType ) {
					
					output.AppendLine( $@"static mrb_value
{GetClassFieldGetterFunctionName( klass, field )}( mrb_state *mrb, mrb_value self ) {{
	return {GetNativeType2MRubyExpr( field, $"class_raylib_{lowerKlassName}_get_ptr( mrb, self )->{field.Name}", isPointerField )};
}}
	" );
					var ( expr, exprReturnPointer ) = GetMRubyValue2NativeValue( field.Type, "param0" );
					var exprNeedTypeCast = field.Type.TypeKind == CppTypeKind.Primitive;
					if ( expr != "NULL" ) {
						if ( field.Type.TypeKind is CppTypeKind.Pointer && !exprReturnPointer ) {
							expr = $"&{expr}";
						}
						if ( field.Type.TypeKind is not CppTypeKind.Pointer && exprReturnPointer ) {
							expr = $"*{expr}";
						}
					}
					if ( exprNeedTypeCast ) {
						// expr = $"( {GetNativeType2MRubyValueType( field.Type )} ){expr}";
						expr = "param0";
					}
					output.AppendLine( $@"static mrb_value
{GetClassFieldSetterFunctionName( klass, field )}( mrb_state *mrb, mrb_value self ) {{
	{GetNativeType2MRubyValueType( field.Type )} param0;
	mrb_get_args( mrb, ""{GetMRBGetArgTypeHint( field.Type )}"", &param0 );
	class_raylib_{lowerKlassName}_get_ptr( mrb, self )->{field.Name} = {expr};
	return self;
}}
	" );
				}
				else {
					output.AppendLine( $@"static mrb_value
{GetClassFieldGetterFunctionName( klass, field )}( mrb_state *mrb, mrb_value self ) {{
	{GetNativeArrayType2MRubyExpr( field, $"class_raylib_{lowerKlassName}_get_ptr( mrb, self )->{field.Name}", isPointerField )};
}}
	" );

					output.AppendLine( $@"static mrb_value
{GetClassFieldSetterFunctionName( klass, field )}( mrb_state *mrb, mrb_value self ) {{
	// TODO: set {field.Name}
	return self;
}}
	" );
				}
				
			}
			
			// module init
			output.AppendLine( $@"void
{GetInitClassBindingFunctionName( klass )}( mrb_state *mrb, struct RClass *mod_RayLib ) {{
	class_{klassName} = mrb_define_class_under( mrb, mod_RayLib, ""{klassName}"", mrb->object_class );

	MRB_SET_INSTANCE_TT( class_{klassName}, MRB_TT_DATA );

	mrb_define_method( mrb, class_{klassName}, ""initialize"", class_raylib_{lowerKlassName}_initialize, MRB_ARGS_NONE() );
" );
			
			// class field getter/setter
			foreach ( var field in klass.Fields ) {
				output.AppendLine( $"\tmrb_define_method( mrb, class_{klassName}, \"{CamelCase2SnakeCase( field.Name )}\", {GetClassFieldGetterFunctionName(klass, field)}, MRB_ARGS_NONE() );" );
				output.AppendLine( $"\tmrb_define_method( mrb, class_{klassName}, \"{CamelCase2SnakeCase( field.Name )}=\", {GetClassFieldSetterFunctionName(klass, field)}, MRB_ARGS_REQ( 1 ) );" );
			}

			output.AppendLine( "}" );

			output.AppendLine( "//----------------------------------------------------------------//\n\n" );

		}
		
		
		// raylib function define
		foreach ( var function in compilation.Functions ) {
			WriteRaylibFunction( compilation, function, output );
			output.AppendLine();
		}
		
		output.AppendLine( "void\nmrb_raylib_module_init( mrb_state *mrb ) {\n" );

		output.AppendLine( @"	mod_RayLib = mrb_define_module( mrb, ""Raylib"" );
	class_RayLibError = mrb_define_class_under( mrb, mod_RayLib, ""RaylibError"", mrb->eStandardError_class );
" );
		
		output.AppendLine( $"\tmrb_define_const( mrb, mod_RayLib, \"VERSION\", mrb_fixnum_value( {majorNum + minorNum + patchNum} ) );" );
		output.AppendLine( $"\tmrb_define_const( mrb, mod_RayLib, \"VERSION_MAJOR\", mrb_fixnum_value( {(int)(majorNum/100)} ) );" );
		output.AppendLine( $"\tmrb_define_const( mrb, mod_RayLib, \"VERSION_MINOR\", mrb_fixnum_value( {(int)(minorNum/10)} ) );" );
		output.AppendLine( $"\tmrb_define_const( mrb, mod_RayLib, \"VERSION_PATCH\", mrb_fixnum_value( {patchNum} ) );\n" );

		// TODO: predefine macro process
		// foreach ( var macro in compilation.Macros ) {
		// 	output.AppendLine( $"{macro.Name} = {macro.Value}" );
		// }
		
#if WRITE_ENUM
		output.AppendLine( "\tint arena_size = mrb_gc_arena_save(mrb);\n" );
		foreach ( CppEnum @enum in compilation.Enums ) {
			
			output.Append( "\t//----------------------------------------------------------------//\n" );
			output.Append( $"\t// Raylib::{@enum.Name}\n" );
			output.Append( "\t//----------------------------------------------------------------//\n" );
			
			// define under Raylib::
			foreach ( var enumItem in @enum.Items ) {
				output.AppendLine( $"\tmrb_define_const(mrb, mod_RayLib, \"{enumItem.Name}\", mrb_fixnum_value({enumItem.Value}));" );
			}

			output.AppendLine();
			
			// define under Raylib::{enumName}::
			output.AppendLine( $"\tstruct RClass *mod_RayLib_{@enum.Name};" );
			output.AppendLine( $"\tmod_RayLib_{@enum.Name} = mrb_define_module_under(mrb, mod_RayLib, \"{@enum.Name}\" );" );
			foreach ( var enumItem in @enum.Items ) {
				output.AppendLine( $"\tmrb_define_const(mrb, mod_RayLib_{@enum.Name}, \"{enumItem.Name}\", mrb_fixnum_value({enumItem.Value}));" );
			}
			
			output.AppendLine();
		}
		output.AppendLine( "\tmrb_gc_arena_restore(mrb, arena_size);\n" );
#endif
		
#if WRITE_CLASS
		
		foreach ( var klass in compilation.Classes ) {
			
			if ( !KSupportedStructs.Contains( klass.Name ) ) {
				continue;
			}
			
			output.Append( "\t//----------------------------------------------------------------//\n" );
			output.Append( $"\t// module: {klass.Name}\n" );
			output.Append( "\t//----------------------------------------------------------------//\n" );
			output.AppendLine( $"\t{GetInitClassBindingFunctionName( klass )}( mrb, mod_RayLib );" );
			output.AppendLine();
		}
		
#endif
		
		output.AppendLine();
		foreach ( var function in compilation.Functions ) {
			string mrbArgsStr;
			if ( function.Parameters.Count > 0 ) {
				mrbArgsStr = $"MRB_ARGS_REQ( {function.Parameters.Count} )";
			}
			else {
				mrbArgsStr = "MRB_ARGS_NONE()";
			}
			output.AppendLine( $"\tmrb_define_module_function( mrb, mod_RayLib, \"{CamelCase2SnakeCase( function.Name )}\", {GetRaylibModuleFunctionName( function )}, {mrbArgsStr} );" );
		}
		output.AppendLine();
		
		output.AppendLine( "}\n" );

		output.Append( @"void
mrb_raylib_gem_init( mrb_state *mrb ) {

}

void
mrb_raylib_struct_init( mrb_state *mrb ) {

}

void
mrb_raylib_module_final( mrb_state *mrb ) {

}
" );
		
		// Console.WriteLine( $"Supported: {parsedFunctionNames.Count}/{functionCount}" );

		return output.ToString();
	}


	public static void TestCamelCase2SnakeCase() {
		Console.WriteLine( $"func1: {CamelCase2SnakeCase( "DrawLine3D" )}" );
		Console.WriteLine( $"func2: {CamelCase2SnakeCase2( "DrawLine3D" )}" );
	}

	private static void WriteRaylibFunction( CppCompilation compilation, CppFunction function, StringBuilder builder ) {
		builder.AppendLine( @$"static mrb_value
{GetRaylibModuleFunctionName( function )}( mrb_state *mrb, mrb_value self ) {{" );

		bool hasParameters = function.Parameters.Count > 0;
		if ( hasParameters ) {
			string mrbGetArgsHints = string.Empty;
			for ( var i = 0; i < function.Parameters.Count; i++ ) {
				mrbGetArgsHints += GetMRBGetArgTypeHint( function.Parameters[ i ].Type );
				builder.AppendLine( $"\t{GetNativeType2MRubyValueType( function.Parameters[ i ].Type )} param{i}; // {function.Parameters[ i ].Type.FullName}" );
			}
			builder.AppendLine();
			builder.Append( $"\tmrb_get_args( mrb, \"{mrbGetArgsHints}\"" );
			for ( var i = 0; i < function.Parameters.Count; i++ ) {
				builder.Append( $", &param{i}" );
			}
			builder.Append( " );\n" );
			builder.AppendLine();
		}

		string paramterSpace = hasParameters ? " " : string.Empty;
		bool hasReturnValue = !function.ReturnType.Equals( CppPrimitiveType.Void );
		if ( hasReturnValue ) {
			builder.Append( $"\t{function.ReturnType.FullName} ret = {function.Name}({paramterSpace}" );
		}
		else {
			builder.Append( $"\t{function.Name}({paramterSpace}" );
		}
		for ( var i = 0; i < function.Parameters.Count; i++ ) {
			var parameter = function.Parameters[ i ];
			var ( expr, exprReturnPointer ) = GetMRubyValue2NativeValueDuringGetArgs( parameter.Type, $"param{i}" );
			if ( expr != "NULL" ) {
				if ( parameter.Type.TypeKind is CppTypeKind.Pointer && !exprReturnPointer ) {
					builder.Append( "&" );
				}
				if ( parameter.Type.TypeKind is not CppTypeKind.Pointer && exprReturnPointer ) {
					builder.Append( "*" );
				}
			}
			builder.Append( $"{expr}" );
			if ( i != function.Parameters.Count - 1 ) {
				builder.Append( ", " );
			}
		}
		// builder.Append( hasReturnValue ? $"{paramterSpace});\n" : $"{paramterSpace});\n" );
		builder.Append( $"{paramterSpace});\n" );
		builder.AppendLine();

		if ( !hasReturnValue ) {
			builder.AppendLine( "\treturn self;" );
		}
		else {
			if ( function.ReturnType is not CppArrayType ) {
				builder.AppendLine( $"\treturn {GetNativeType2MRubyExpr( function.ReturnType, "ret", false )};" );
			}
			else {
				builder.AppendLine( $"{GetNativeType2MRubyExpr( function.ReturnType, "ret", false )}return arr;" );
			}
		}
		builder.AppendLine( "}" );
	}

	
	private static string CamelCase2SnakeCase( string str ) {
		var builder = new StringBuilder();
		var name = str;
		var previousUpper = false;
		for ( var i = 0; i < name.Length; i++ ) {
			var c = name[ i ];
			if ( char.IsUpper( c ) ) {

				// ignore 2D/3D like
				var isSpecialCaseNeedIgnore = false;
				if ( c == 'D' && i - 1 >= 0 ) {
					if ( char.IsNumber( name[ i - 1 ] ) ) {
						isSpecialCaseNeedIgnore = true;
					}
				}

				if ( isSpecialCaseNeedIgnore ) {
					builder.Append( char.ToLowerInvariant( c ) );
					previousUpper = false;
					continue;
				}
				
				if ( i > 0 && !previousUpper ) {
					builder.Append( "_" );
				}

				builder.Append( char.ToLowerInvariant( c ) );
				previousUpper = true;
			}
			else {
				builder.Append( c );
				previousUpper = false;
			}
		}

		return builder.ToString();
	}


	private static string CamelCase2SnakeCase2( string str ) {
		var matchFirstCap = new Regex( "(.)([A-Z][a-z]+)" );
		var matchAllCap = new Regex( "([a-z0-9])([A-Z])" );
		var snake = matchFirstCap.Replace( str, "${1}_${2}" );
		snake = matchAllCap.Replace( snake, "${1}_${2}" );
		return snake.ToLower();
	}


	private static string GetMRBGetArgTypeHint( CppType cppType ) {
		switch ( cppType.TypeKind ) {
			case CppTypeKind.Primitive:
				if ( cppType.Equals( CppPrimitiveType.Void ) ) {
					return string.Empty;
				}
				if ( cppType.Equals( CppPrimitiveType.Bool ) ) {
					return "b";
				}
				if ( cppType.Equals( CppPrimitiveType.Int ) ||
					 cppType.Equals( CppPrimitiveType.UnsignedInt ) ||
					 cppType.Equals( CppPrimitiveType.Short ) ||
					 cppType.Equals( CppPrimitiveType.UnsignedShort ) ||
					 cppType.Equals( CppPrimitiveType.Char ) ||
					 cppType.Equals( CppPrimitiveType.UnsignedChar ) ||
					 cppType.Equals( CppPrimitiveType.WChar ) ||
					 cppType.Equals( CppPrimitiveType.LongLong ) ||
					 cppType.Equals( CppPrimitiveType.UnsignedLongLong ) ) {
					return "i";
				}
				if ( cppType.Equals( CppPrimitiveType.Float ) ||
					 cppType.Equals( CppPrimitiveType.Double ) ||
					 cppType.Equals( CppPrimitiveType.LongDouble ) ) {
					return "f";
				}
				goto Unsupported;
			case CppTypeKind.StructOrClass:
				if ( cppType is CppClass ) {
					// return "d";
					return "o";
				}
				goto Unsupported;
			case CppTypeKind.Array:
				if ( cppType is CppArrayType ) {
					return "A";
				}
				goto Unsupported;
			case CppTypeKind.Pointer:
				if ( cppType is CppPointerType pointerType ) {
					if ( pointerType.ElementType.Equals( CppPrimitiveType.Void ) ) {
						return "d";
					}
					// TODO: primitive pointer type be regarded as cptr, because we dont known length of it.
					if ( pointerType.ElementType.TypeKind is CppTypeKind.Primitive ) {
						return "*";
					}
					// Multi-level pointers are treated as cptr
					if ( pointerType.ElementType.TypeKind is CppTypeKind.Pointer ) {
						return "!d";
					}
					if ( pointerType.FullName.Equals( "const char*" ) ) {
						return "S";
					}
					if ( pointerType.ElementType is CppClass pointerCppClass ) {
						if ( pointerCppClass.Parent is CppCompilation ) { // check is Root, if is root, that must be defined under raylib
							return "!d";
						}
					}
					if ( pointerType.ElementType is CppTypedef pointerTypeDef ) {
						if ( pointerTypeDef.ElementType is CppClass ) {
							return "!d";
						}
					}
					if ( pointerType.ElementType is CppQualifiedType pointerQualifiedType ) {
						var pointerQualifiedElementType = pointerQualifiedType.ElementType;
						if ( pointerQualifiedElementType.Equals( CppPrimitiveType.Void ) ) {
							return "!d";
						}
						if ( pointerQualifiedElementType.TypeKind is CppTypeKind.Primitive ) {
							return "!d";
						}
						if ( pointerType.FullName.Equals( "const char*" ) ) {
							return "S";
						}
						if ( pointerQualifiedElementType is CppClass ) {
							return "!d";
						}
					}
				}
				goto Unsupported;
			case CppTypeKind.Typedef:
				if ( cppType is CppTypedef cppTypedef ) {
					if ( cppTypedef.ElementType is CppClass ) {
						return "d";
					}
				}
				goto Unsupported;
		}
		
	Unsupported:
// #if LOG_TODO
		Console.WriteLine( $"TODO: unsupported cppType: {cppType} {cppType.TypeKind}" );
// #endif	
		
		return "*";
	}


	private static string GetClassFieldGetterFunctionName( CppClass cppClass, CppField field ) {
		return $"class_raylib_{cppClass.Name.ToLower()}_get_{field.Name}";
	}
	
	
	private static string GetClassFieldSetterFunctionName( CppClass cppClass, CppField field ) {
		return $"class_raylib_{cppClass.Name.ToLower()}_set_{field.Name}";
	}


	private static string GetInitClassBindingFunctionName( CppClass cppClass ) {
		return $"class_raylib_{cppClass.Name.ToLower()}_init";
	}


	private static string GetRaylibModuleFunctionName( CppFunction cppFunction ) {
		return $"mod_raylib_{CamelCase2SnakeCase( cppFunction.Name )}";
	}


	private static string GetNativeValueNewToMrubyValue( CppClass cppClass ) {
		return $"class_raylib_{cppClass.Name.ToLower()}_2_mrbvalue_direct( mrb )";
	}
	
	
	private static string GetNativeValueNewToMrubyValue( CppType cppType, string nativeValueExpr ) {
		return $"class_raylib_{cppType.FullName.ToLower()}_2_mrbvalue_direct( mrb, {nativeValueExpr} )";
	}


	private static string GetNativeType2MRubyExpr( CppField cppField, string nativeValueExpr, bool nativeValueExprReturnAPointer = false ) {
		return GetNativeType2MRubyExpr( cppField.Type, nativeValueExpr, nativeValueExprReturnAPointer );
	}
	
	
	private static string GetNativeArrayType2MRubyExpr( CppField cppField, string nativeValueExpr, bool nativeValueExprReturnAPointer = false ) {
		return $"{GetNativeType2MRubyExpr( cppField.Type, nativeValueExpr, nativeValueExprReturnAPointer )}return arr";
	}
	
	
	private static string GetNativeType2MRubyExpr( CppClass cppClass, string nativeValueExpr, bool nativeValueExprReturnAPointer = false ) {
		return GetNativeType2MRubyExpr( cppClass.GetCanonicalType(), nativeValueExpr, nativeValueExprReturnAPointer );
	}
	
	
	private static string GetNativeType2MRubyValueType( CppType cppType ) {
		switch ( cppType.TypeKind ) {
			case CppTypeKind.Primitive:
				if ( cppType.Equals( CppPrimitiveType.Void ) ) {
					return "void";
				}
				if ( cppType.Equals( CppPrimitiveType.Bool ) ) {
					return "mrb_bool";
				}
				if ( cppType.Equals( CppPrimitiveType.Int ) ||
					 cppType.Equals( CppPrimitiveType.UnsignedInt ) ||
					 cppType.Equals( CppPrimitiveType.Short ) ||
					 cppType.Equals( CppPrimitiveType.UnsignedShort ) ||
					 cppType.Equals( CppPrimitiveType.Char ) || // TODO: convert char correctly
					 cppType.Equals( CppPrimitiveType.UnsignedChar ) ||
					 cppType.Equals( CppPrimitiveType.WChar ) ||
					 cppType.Equals( CppPrimitiveType.LongLong ) ||
					 cppType.Equals( CppPrimitiveType.UnsignedLongLong ) ) {
					return "mrb_int";
					// return $"mrb_fixnum_value( mrb, {nativeValueExpr} )"; // TODO: should we using mrb_fixnum_value?
				}
				if ( cppType.Equals( CppPrimitiveType.Float ) ||
					 cppType.Equals( CppPrimitiveType.Double ) ||
					 cppType.Equals( CppPrimitiveType.LongDouble ) ) {
					return "mrb_float";
				}
				goto Unsupported;
			case CppTypeKind.StructOrClass:
				if ( cppType is CppClass ) {
					return "mrb_value";
				}
				goto Unsupported;
			case CppTypeKind.Array:
				if ( cppType is CppArrayType ) {
					return "mrb_value";
				}
				goto Unsupported;
			case CppTypeKind.Pointer:
				if ( cppType is CppPointerType ) {
					return "mrb_value";
				}
				goto Unsupported;
			case CppTypeKind.Typedef:
				if ( cppType is CppTypedef cppTypedef ) {
					if ( cppTypedef.ElementType is CppClass ) {
						return "mrb_value";
					}
				}
				goto Unsupported;
		}
		
	Unsupported:
// #if LOG_TODO
		Console.WriteLine( $"TODO: GetNativeType2MRubyValueType() unsupported cppType: {cppType} {cppType.TypeKind}" );
// #endif	
		
		return "mrb_value";
	}

	
	/// <summary>
	/// cpptype -> mrb_value
	/// </summary>
	private static string GetNativeType2MRubyExpr( CppType cppType, string nativeValueExpr, bool nativeValueExprReturnAPointer ) {
		
		switch ( cppType.TypeKind ) {
			case CppTypeKind.Primitive:
				if ( cppType.Equals( CppPrimitiveType.Void ) ) {
					return "mrb_nil_value()";
				}
				if ( cppType.Equals( CppPrimitiveType.Bool ) ) {
					return $"mrb_bool_value( {nativeValueExpr} )";
				}
				if ( cppType.Equals( CppPrimitiveType.Int ) ||
					 cppType.Equals( CppPrimitiveType.UnsignedInt ) ||
					 cppType.Equals( CppPrimitiveType.Short ) ||
					 cppType.Equals( CppPrimitiveType.UnsignedShort ) ||
					 cppType.Equals( CppPrimitiveType.Char ) || // TODO: convert char correctly
					 cppType.Equals( CppPrimitiveType.UnsignedChar ) ||
					 cppType.Equals( CppPrimitiveType.WChar ) ||
					 cppType.Equals( CppPrimitiveType.LongLong ) ||
					 cppType.Equals( CppPrimitiveType.UnsignedLongLong ) ) {
					// return $"mrb_int_value( mrb, {nativeValueExpr} )";
					return $"mrb_fixnum_value( {nativeValueExpr} )"; // TODO: should we using mrb_fixnum_value?
				}
				if ( cppType.Equals( CppPrimitiveType.Float ) ||
					 cppType.Equals( CppPrimitiveType.Double ) ||
					 cppType.Equals( CppPrimitiveType.LongDouble ) ) {
					return $"mrb_float_value( mrb, {nativeValueExpr} )";
				}
				goto Unsupported;
			case CppTypeKind.StructOrClass:
				if ( cppType is CppClass cppClass ) {
					if ( nativeValueExprReturnAPointer ) {
						return $"class_raylib_{cppClass.Name.ToLower()}_2_mrbvalue( mrb, {nativeValueExpr}, 0 )";
					}
					else {
						return $"class_raylib_{cppClass.Name.ToLower()}_2_mrbvalue( mrb, &{nativeValueExpr}, 0 )";
					}
				}
				goto Unsupported;
			case CppTypeKind.Array:
				if ( cppType is CppArrayType cppArrayType ) {
					var arrayExpr = string.Empty;
					arrayExpr += "mrb_value arr = mrb_ary_new( mrb );\n";
					for ( var i = 0; i < cppArrayType.Size; i++ ) {
						arrayExpr += $"mrb_ary_push( mrb, arr, {GetNativeType2MRubyExpr( cppArrayType.ElementType, $"{nativeValueExpr}[ {i} ]", false )} );\n";
					}
					return arrayExpr;
				}
				goto Unsupported;
			case CppTypeKind.Pointer:
				if ( cppType is CppPointerType pointerType ) {
					if ( pointerType.ElementType.Equals( CppPrimitiveType.Void ) ) {
						return $"mrb_cptr_value( mrb, {nativeValueExpr} )";
					}
					// TODO: primitive pointer type be regarded as cptr, because we dont known length of it.
					if ( pointerType.ElementType.TypeKind is CppTypeKind.Primitive ) {
						return $"mrb_cptr_value( mrb, ( void* )( {nativeValueExpr} ) )";
					}
					// Multi-level pointers are treated as cptr
					if ( pointerType.ElementType.TypeKind is CppTypeKind.Pointer ) {
						return $"mrb_cptr_value( mrb, ( void* )( {nativeValueExpr} ) )";
					}
					if ( pointerType.FullName.Equals( "const char*" ) ) {
						return $"mrb_str_new_cstr( mrb, {nativeValueExpr} )";
					}
					if ( pointerType.ElementType is CppClass pointerCppClass ) {
						if ( pointerCppClass.Parent is CppCompilation ) { // check is Root, if is root, that must be defined under raylib
							return $"class_raylib_{pointerCppClass.Name.ToLower()}_2_mrbvalue( mrb, {nativeValueExpr}, 0 )";
						}
					}
				}
				goto Unsupported;
			case CppTypeKind.Typedef:
				if ( cppType is CppTypedef cppTypedef ) {
					if ( cppTypedef.ElementType is CppClass cppTypeDefClass ) {
						if ( nativeValueExprReturnAPointer ) {
							return $"class_raylib_{cppTypeDefClass.Name.ToLower()}_2_mrbvalue( mrb, {nativeValueExpr}, 0 )";
						}
						else {
							return $"class_raylib_{cppTypeDefClass.Name.ToLower()}_2_mrbvalue( mrb, &{nativeValueExpr}, 0 )";
						}
					}
				}
				goto Unsupported;
		}
		
	Unsupported:
// #if LOG_TODO
		Console.WriteLine( $"TODO: GetNativeType2MRubyExpr() unsupported cppType: {cppType} {cppType.TypeKind}" );
// #endif	
		
		return "mrb_nil_value()";
	}


	private static ( string, bool ) GetMRubyValue2NativeValueDuringGetArgs( CppType cppType, string mrbValueExpr ) {
		switch ( cppType.TypeKind ) {
			case CppTypeKind.Primitive:
				if ( cppType.Equals( CppPrimitiveType.Void ) ) {
					return ( "NULL", false );
				}
				if ( cppType.Equals( CppPrimitiveType.Bool ) ) {
					return ( $"{mrbValueExpr}", false );
				}
				if ( cppType.Equals( CppPrimitiveType.Int ) ||
					 cppType.Equals( CppPrimitiveType.UnsignedInt ) ||
					 cppType.Equals( CppPrimitiveType.Short ) ||
					 cppType.Equals( CppPrimitiveType.UnsignedShort ) ||
					 cppType.Equals( CppPrimitiveType.Char ) || // TODO: convert char correctly
					 cppType.Equals( CppPrimitiveType.UnsignedChar ) ||
					 cppType.Equals( CppPrimitiveType.WChar ) ||
					 cppType.Equals( CppPrimitiveType.LongLong ) ||
					 cppType.Equals( CppPrimitiveType.UnsignedLongLong ) ) {
					return ( $"{mrbValueExpr}", false );
				}
				if ( cppType.Equals( CppPrimitiveType.Float ) ||
					 cppType.Equals( CppPrimitiveType.Double ) ||
					 cppType.Equals( CppPrimitiveType.LongDouble ) ) {
					return ( $"{mrbValueExpr}", false );
				}
				goto Unsupported;
			case CppTypeKind.StructOrClass:
				if ( cppType is CppClass cppClass ) {
					return ( $"class_raylib_{cppClass.Name.ToLower()}_get_ptr( mrb, {mrbValueExpr} )", true );
				}
				goto Unsupported;
			case CppTypeKind.Array:
				// if ( cppType is CppArrayType cppArrayType ) {
				// 	var arrayExpr = string.Empty;
				// 	arrayExpr += "mrb_value arr = mrb_ary_new( mrb );\n";
				// 	for ( var i = 0; i < cppArrayType.Size; i++ ) {
				// 		arrayExpr += $"mrb_ary_push( mrb, arr, {GetNativeType2MRubyExpr( cppArrayType.ElementType, $"{nativeValueExpr}[ {i} ]" )} );\n";
				// 	}
				// 	return arrayExpr;
				// }
				goto Unsupported;
			case CppTypeKind.Pointer:
				if ( cppType is CppPointerType pointerType ) {
					if ( pointerType.ElementType.Equals( CppPrimitiveType.Void ) ) {
						return ( $"mrb_cptr( {mrbValueExpr} )", true );
					}
					// TODO: primitive pointer type be regarded as cptr, because we dont known length of it.
					if ( pointerType.ElementType.TypeKind is CppTypeKind.Primitive ) {
						// return ( $"mrb_cptr_value( mrb, ( void* )( {mrbValueExpr} ) )", true );
						return ( $"mrb_cptr( {mrbValueExpr} )", true );
					}
					// Multi-level pointers are treated as cptr
					if ( pointerType.ElementType.TypeKind is CppTypeKind.Pointer ) {
						return ( $"mrb_cptr( {mrbValueExpr} )", true );
					}
					if ( pointerType.FullName.Equals( "const void*" ) ) {
						return ( $"mrb_cptr( {mrbValueExpr} )", true );
					}
					if ( pointerType.FullName.Equals( "const char*" ) ) {
						return ( $"RSTRING_PTR( {mrbValueExpr} )", true );
					}
					if ( pointerType.ElementType is CppClass pointerCppClass ) {
						if ( pointerCppClass.Parent is CppCompilation ) { // check is Root, if is root, that must be defined under raylib
							return ( $"class_raylib_{pointerCppClass.Name.ToLower()}_get_ptr( mrb, {mrbValueExpr} )", true );
						}
					}
					else if ( pointerType.ElementType is CppTypedef pointerTypeDef ) {
						if ( pointerTypeDef.ElementType.Parent is CppCompilation ) { // check is Root, if is root, that must be defined under raylib
							return ( $"class_raylib_{pointerTypeDef.ElementType.FullName.ToLower()}_get_ptr( mrb, {mrbValueExpr} )", true );
						}
					}
				}
				goto Unsupported;
			case CppTypeKind.Typedef:
				if ( cppType is CppTypedef cppTypedef ) {
					if ( cppTypedef.ElementType is CppClass cppTypeDefClass ) {
						return ( $"class_raylib_{cppTypeDefClass.Name.ToLower()}_get_ptr( mrb, {mrbValueExpr} )", true );
					}
				}
				goto Unsupported;
		}
		
	Unsupported:
// #if LOG_TODO
		Console.WriteLine( $"TODO: GetMRubyValue2NativeValueDuringGetArgs() unsupported cppType: {cppType} {cppType.TypeKind}" );
// #endif
		
		return ( "NULL", false );
	}


	/// <summary>
	/// mrb_value -> cpptype
	/// </summary>
	private static ( string, bool ) GetMRubyValue2NativeValue( CppType cppType, string mrbValueExpr ) {
		
		switch ( cppType.TypeKind ) {
			case CppTypeKind.Primitive:
				if ( cppType.Equals( CppPrimitiveType.Void ) ) {
					return ( "NULL", false );
				}
				if ( cppType.Equals( CppPrimitiveType.Bool ) ) {
					return ( $"mrb_bool( {mrbValueExpr} )", false );
				}
				if ( cppType.Equals( CppPrimitiveType.Int ) ||
					 cppType.Equals( CppPrimitiveType.UnsignedInt ) ||
					 cppType.Equals( CppPrimitiveType.Short ) ||
					 cppType.Equals( CppPrimitiveType.UnsignedShort ) ||
					 cppType.Equals( CppPrimitiveType.Char ) || // TODO: convert char correctly
					 cppType.Equals( CppPrimitiveType.UnsignedChar ) ||
					 cppType.Equals( CppPrimitiveType.WChar ) ||
					 cppType.Equals( CppPrimitiveType.LongLong ) ||
					 cppType.Equals( CppPrimitiveType.UnsignedLongLong ) ) {
					return ( $"mrb_int( mrb, {mrbValueExpr} )", false );
				}
				if ( cppType.Equals( CppPrimitiveType.Float ) ||
					 cppType.Equals( CppPrimitiveType.Double ) ||
					 cppType.Equals( CppPrimitiveType.LongDouble ) ) {
					return ( $"mrb_float( {mrbValueExpr} )", false );
				}
				goto Unsupported;
			case CppTypeKind.StructOrClass:
				if ( cppType is CppClass cppClass ) {
					// return ( $"*class_raylib_{cppClass.Name.ToLower()}_get_ptr( mrb, {mrbValueExpr} )", true );
					return ( $"class_raylib_{cppClass.Name.ToLower()}_get_ptr( mrb, {mrbValueExpr} )", true );
				}
				goto Unsupported;
			case CppTypeKind.Array:
				// if ( cppType is CppArrayType cppArrayType ) {
				// 	var arrayExpr = string.Empty;
				// 	arrayExpr += "mrb_value arr = mrb_ary_new( mrb );\n";
				// 	for ( var i = 0; i < cppArrayType.Size; i++ ) {
				// 		arrayExpr += $"mrb_ary_push( mrb, arr, {GetNativeType2MRubyExpr( cppArrayType.ElementType, $"{nativeValueExpr}[ {i} ]" )} );\n";
				// 	}
				// 	return arrayExpr;
				// }
				goto Unsupported;
			case CppTypeKind.Pointer:
				if ( cppType is CppPointerType pointerType ) {
					if ( pointerType.ElementType.Equals( CppPrimitiveType.Void ) ) {
						return ( $"mrb_cptr( {mrbValueExpr} )", true );
					}
					// TODO: primitive pointer type be regarded as cptr, because we dont known length of it.
					if ( pointerType.ElementType.TypeKind is CppTypeKind.Primitive ) {
						// return ( $"mrb_cptr_value( mrb, ( void* )( {mrbValueExpr} ) )", true );
						return ( $"mrb_cptr( {mrbValueExpr} )", true );
					}
					// Multi-level pointers are treated as cptr
					if ( pointerType.ElementType.TypeKind is CppTypeKind.Pointer ) {
						return ( $"mrb_cptr( {mrbValueExpr} )", true );
					}
					if ( pointerType.FullName.Equals( "const void*" ) ) {
						return ( $"mrb_cptr( {mrbValueExpr} )", true );
					}
					if ( pointerType.FullName.Equals( "const char*" ) ) {
						return ( $"RSTRING_PTR( {mrbValueExpr} )", true );
					}
					if ( pointerType.ElementType is CppClass pointerCppClass ) {
						if ( pointerCppClass.Parent is CppCompilation ) { // check is Root, if is root, that must be defined under raylib
							return ( $"class_raylib_{pointerCppClass.Name.ToLower()}_get_ptr( mrb, {mrbValueExpr} )", true );
						}
					}
					else if ( pointerType.ElementType is CppTypedef pointerTypeDef ) {
						if ( pointerTypeDef.ElementType.Parent is CppCompilation ) { // check is Root, if is root, that must be defined under raylib
							return ( $"class_raylib_{(pointerTypeDef.ElementType as CppClass).Name.ToLower()}_get_ptr( mrb, {mrbValueExpr} )", true );
						}
					}
				}
				goto Unsupported;
			case CppTypeKind.Typedef:
				if ( cppType is CppTypedef cppTypedef ) {
					if ( cppTypedef.ElementType is CppClass cppTypeDefClass ) {
						return ( $"class_raylib_{cppTypeDefClass.Name.ToLower()}_get_ptr( mrb, {mrbValueExpr} )", true );
					}
				}
				goto Unsupported;
		}
		
	Unsupported:
// #if LOG_TODO
		Console.WriteLine( $"TODO: GetMRubyValue2NativeValue() unsupported cppType: {cppType} {cppType.TypeKind}" );
// #endif
		
		return ( "NULL", false );
	}
	
}
