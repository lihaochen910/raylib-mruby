// this file generated by RaylibMRubyBindingsGenerator, DO NOT EDIT

// RAYLIB_VERSION: "5.0"
#include "rMRuby.h"
#include "raudio.c"
#include <mruby/class.h>
#include <mruby/data.h>
#include <mruby/array.h>
#include <mruby/string.h>

RMRUBY_API struct RClass *mod_RayLib;
RMRUBY_API struct RClass *class_RayLibError;
		
//----------------------------------------------------------------//
// Raylib::Vector2
static struct RClass *class_Vector2;

typedef struct class_raylib_vector2_data_t {
	bool is_associated;
	Vector2 vector2;
} class_raylib_vector2_data_t;
		
static void
class_raylib_vector2_data_free( mrb_state *mrb, void *p ) {
	class_raylib_vector2_data_t *data = ( class_raylib_vector2_data_t* )p;
	if ( NULL != data ) {
		mrb_free( mrb, data );
	}
}

static struct mrb_data_type const class_raylib_vector2_data_type = {
	"Vector2", class_raylib_vector2_data_free
};

mrb_value
class_raylib_vector2_2_mrbvalue( mrb_state *mrb, Vector2 *vector2, bool is_associated ) {
	class_raylib_vector2_data_t *data = ( class_raylib_vector2_data_t* )mrb_malloc( mrb, sizeof( class_raylib_vector2_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	data->is_associated = is_associated;
	data->vector2 = *vector2;
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_Vector2, &class_raylib_vector2_data_type, data ) );
}

mrb_value
class_raylib_vector2_2_mrbvalue_direct( mrb_state *mrb, Vector2 const *vector2 ) {
	class_raylib_vector2_data_t *data = ( class_raylib_vector2_data_t* )mrb_malloc( mrb, sizeof( class_raylib_vector2_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	if ( NULL == vector2 ) {
		// Do init
	} else {
		// Do Copy
		data->vector2 = *vector2;
	}
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_Vector2, &class_raylib_vector2_data_type, data ) );
}

Vector2*
class_raylib_vector2_get_ptr( mrb_state *mrb, mrb_value vector2 ) {
	class_raylib_vector2_data_t *data;
	if ( mrb_nil_p( vector2 ) ) {
		return NULL;
	}
	data = ( class_raylib_vector2_data_t* )mrb_data_get_ptr( mrb, vector2, &class_raylib_vector2_data_type );
	return &data->vector2;
}

static mrb_value
class_raylib_vector2_initialize( mrb_state *mrb, mrb_value self ) {
	class_raylib_vector2_data_t *data = DATA_PTR( self );

	if ( NULL == data ) {
		data = mrb_malloc( mrb, sizeof( class_raylib_vector2_data_t ) );
		if ( NULL == data ) {
			mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
		}
		//data->vector2 = { 0 };
	} else {
		// if ( NULL != &( data->vector2 ) ) {
		// 
		// }
	}
	Vector2 vector2 = { 0 };
	data->vector2 = vector2;
	// if ( NULL == &( data->vector2 ) ) {
	//	mrb_free( mrb, data );
	// }
	DATA_PTR( self ) = data;
	DATA_TYPE( self ) = &class_raylib_vector2_data_type;
	return self;
}

static mrb_value
class_raylib_vector2_get_x( mrb_state *mrb, mrb_value self ) {
	return mrb_float_value( mrb, class_raylib_vector2_get_ptr( mrb, self )->x );
}
	
static mrb_value
class_raylib_vector2_set_x( mrb_state *mrb, mrb_value self ) {
	mrb_float param0;
	mrb_get_args( mrb, "f", &param0 );
	class_raylib_vector2_get_ptr( mrb, self )->x = param0;
	return self;
}
	
static mrb_value
class_raylib_vector2_get_y( mrb_state *mrb, mrb_value self ) {
	return mrb_float_value( mrb, class_raylib_vector2_get_ptr( mrb, self )->y );
}
	
static mrb_value
class_raylib_vector2_set_y( mrb_state *mrb, mrb_value self ) {
	mrb_float param0;
	mrb_get_args( mrb, "f", &param0 );
	class_raylib_vector2_get_ptr( mrb, self )->y = param0;
	return self;
}
	
void
class_raylib_vector2_init( mrb_state *mrb, struct RClass *mod_RayLib ) {
	class_Vector2 = mrb_define_class_under( mrb, mod_RayLib, "Vector2", mrb->object_class );

	MRB_SET_INSTANCE_TT( class_Vector2, MRB_TT_DATA );

	mrb_define_method( mrb, class_Vector2, "initialize", class_raylib_vector2_initialize, MRB_ARGS_NONE() );

	mrb_define_method( mrb, class_Vector2, "x", class_raylib_vector2_get_x, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Vector2, "x=", class_raylib_vector2_set_x, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Vector2, "y", class_raylib_vector2_get_y, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Vector2, "y=", class_raylib_vector2_set_y, MRB_ARGS_REQ( 1 ) );
}
//----------------------------------------------------------------//


//----------------------------------------------------------------//
// Raylib::Vector3
static struct RClass *class_Vector3;

typedef struct class_raylib_vector3_data_t {
	bool is_associated;
	Vector3 vector3;
} class_raylib_vector3_data_t;
		
static void
class_raylib_vector3_data_free( mrb_state *mrb, void *p ) {
	class_raylib_vector3_data_t *data = ( class_raylib_vector3_data_t* )p;
	if ( NULL != data ) {
		mrb_free( mrb, data );
	}
}

static struct mrb_data_type const class_raylib_vector3_data_type = {
	"Vector3", class_raylib_vector3_data_free
};

mrb_value
class_raylib_vector3_2_mrbvalue( mrb_state *mrb, Vector3 *vector3, bool is_associated ) {
	class_raylib_vector3_data_t *data = ( class_raylib_vector3_data_t* )mrb_malloc( mrb, sizeof( class_raylib_vector3_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	data->is_associated = is_associated;
	data->vector3 = *vector3;
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_Vector3, &class_raylib_vector3_data_type, data ) );
}

mrb_value
class_raylib_vector3_2_mrbvalue_direct( mrb_state *mrb, Vector3 const *vector3 ) {
	class_raylib_vector3_data_t *data = ( class_raylib_vector3_data_t* )mrb_malloc( mrb, sizeof( class_raylib_vector3_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	if ( NULL == vector3 ) {
		// Do init
	} else {
		// Do Copy
		data->vector3 = *vector3;
	}
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_Vector3, &class_raylib_vector3_data_type, data ) );
}

Vector3*
class_raylib_vector3_get_ptr( mrb_state *mrb, mrb_value vector3 ) {
	class_raylib_vector3_data_t *data;
	if ( mrb_nil_p( vector3 ) ) {
		return NULL;
	}
	data = ( class_raylib_vector3_data_t* )mrb_data_get_ptr( mrb, vector3, &class_raylib_vector3_data_type );
	return &data->vector3;
}

static mrb_value
class_raylib_vector3_initialize( mrb_state *mrb, mrb_value self ) {
	class_raylib_vector3_data_t *data = DATA_PTR( self );

	if ( NULL == data ) {
		data = mrb_malloc( mrb, sizeof( class_raylib_vector3_data_t ) );
		if ( NULL == data ) {
			mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
		}
		//data->vector3 = { 0 };
	} else {
		// if ( NULL != &( data->vector3 ) ) {
		// 
		// }
	}
	Vector3 vector3 = { 0 };
	data->vector3 = vector3;
	// if ( NULL == &( data->vector3 ) ) {
	//	mrb_free( mrb, data );
	// }
	DATA_PTR( self ) = data;
	DATA_TYPE( self ) = &class_raylib_vector3_data_type;
	return self;
}

static mrb_value
class_raylib_vector3_get_x( mrb_state *mrb, mrb_value self ) {
	return mrb_float_value( mrb, class_raylib_vector3_get_ptr( mrb, self )->x );
}
	
static mrb_value
class_raylib_vector3_set_x( mrb_state *mrb, mrb_value self ) {
	mrb_float param0;
	mrb_get_args( mrb, "f", &param0 );
	class_raylib_vector3_get_ptr( mrb, self )->x = param0;
	return self;
}
	
static mrb_value
class_raylib_vector3_get_y( mrb_state *mrb, mrb_value self ) {
	return mrb_float_value( mrb, class_raylib_vector3_get_ptr( mrb, self )->y );
}
	
static mrb_value
class_raylib_vector3_set_y( mrb_state *mrb, mrb_value self ) {
	mrb_float param0;
	mrb_get_args( mrb, "f", &param0 );
	class_raylib_vector3_get_ptr( mrb, self )->y = param0;
	return self;
}
	
static mrb_value
class_raylib_vector3_get_z( mrb_state *mrb, mrb_value self ) {
	return mrb_float_value( mrb, class_raylib_vector3_get_ptr( mrb, self )->z );
}
	
static mrb_value
class_raylib_vector3_set_z( mrb_state *mrb, mrb_value self ) {
	mrb_float param0;
	mrb_get_args( mrb, "f", &param0 );
	class_raylib_vector3_get_ptr( mrb, self )->z = param0;
	return self;
}
	
void
class_raylib_vector3_init( mrb_state *mrb, struct RClass *mod_RayLib ) {
	class_Vector3 = mrb_define_class_under( mrb, mod_RayLib, "Vector3", mrb->object_class );

	MRB_SET_INSTANCE_TT( class_Vector3, MRB_TT_DATA );

	mrb_define_method( mrb, class_Vector3, "initialize", class_raylib_vector3_initialize, MRB_ARGS_NONE() );

	mrb_define_method( mrb, class_Vector3, "x", class_raylib_vector3_get_x, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Vector3, "x=", class_raylib_vector3_set_x, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Vector3, "y", class_raylib_vector3_get_y, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Vector3, "y=", class_raylib_vector3_set_y, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Vector3, "z", class_raylib_vector3_get_z, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Vector3, "z=", class_raylib_vector3_set_z, MRB_ARGS_REQ( 1 ) );
}
//----------------------------------------------------------------//


//----------------------------------------------------------------//
// Raylib::Vector4
static struct RClass *class_Vector4;

typedef struct class_raylib_vector4_data_t {
	bool is_associated;
	Vector4 vector4;
} class_raylib_vector4_data_t;
		
static void
class_raylib_vector4_data_free( mrb_state *mrb, void *p ) {
	class_raylib_vector4_data_t *data = ( class_raylib_vector4_data_t* )p;
	if ( NULL != data ) {
		mrb_free( mrb, data );
	}
}

static struct mrb_data_type const class_raylib_vector4_data_type = {
	"Vector4", class_raylib_vector4_data_free
};

mrb_value
class_raylib_vector4_2_mrbvalue( mrb_state *mrb, Vector4 *vector4, bool is_associated ) {
	class_raylib_vector4_data_t *data = ( class_raylib_vector4_data_t* )mrb_malloc( mrb, sizeof( class_raylib_vector4_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	data->is_associated = is_associated;
	data->vector4 = *vector4;
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_Vector4, &class_raylib_vector4_data_type, data ) );
}

mrb_value
class_raylib_vector4_2_mrbvalue_direct( mrb_state *mrb, Vector4 const *vector4 ) {
	class_raylib_vector4_data_t *data = ( class_raylib_vector4_data_t* )mrb_malloc( mrb, sizeof( class_raylib_vector4_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	if ( NULL == vector4 ) {
		// Do init
	} else {
		// Do Copy
		data->vector4 = *vector4;
	}
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_Vector4, &class_raylib_vector4_data_type, data ) );
}

Vector4*
class_raylib_vector4_get_ptr( mrb_state *mrb, mrb_value vector4 ) {
	class_raylib_vector4_data_t *data;
	if ( mrb_nil_p( vector4 ) ) {
		return NULL;
	}
	data = ( class_raylib_vector4_data_t* )mrb_data_get_ptr( mrb, vector4, &class_raylib_vector4_data_type );
	return &data->vector4;
}

static mrb_value
class_raylib_vector4_initialize( mrb_state *mrb, mrb_value self ) {
	class_raylib_vector4_data_t *data = DATA_PTR( self );

	if ( NULL == data ) {
		data = mrb_malloc( mrb, sizeof( class_raylib_vector4_data_t ) );
		if ( NULL == data ) {
			mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
		}
		//data->vector4 = { 0 };
	} else {
		// if ( NULL != &( data->vector4 ) ) {
		// 
		// }
	}
	Vector4 vector4 = { 0 };
	data->vector4 = vector4;
	// if ( NULL == &( data->vector4 ) ) {
	//	mrb_free( mrb, data );
	// }
	DATA_PTR( self ) = data;
	DATA_TYPE( self ) = &class_raylib_vector4_data_type;
	return self;
}

static mrb_value
class_raylib_vector4_get_x( mrb_state *mrb, mrb_value self ) {
	return mrb_float_value( mrb, class_raylib_vector4_get_ptr( mrb, self )->x );
}
	
static mrb_value
class_raylib_vector4_set_x( mrb_state *mrb, mrb_value self ) {
	mrb_float param0;
	mrb_get_args( mrb, "f", &param0 );
	class_raylib_vector4_get_ptr( mrb, self )->x = param0;
	return self;
}
	
static mrb_value
class_raylib_vector4_get_y( mrb_state *mrb, mrb_value self ) {
	return mrb_float_value( mrb, class_raylib_vector4_get_ptr( mrb, self )->y );
}
	
static mrb_value
class_raylib_vector4_set_y( mrb_state *mrb, mrb_value self ) {
	mrb_float param0;
	mrb_get_args( mrb, "f", &param0 );
	class_raylib_vector4_get_ptr( mrb, self )->y = param0;
	return self;
}
	
static mrb_value
class_raylib_vector4_get_z( mrb_state *mrb, mrb_value self ) {
	return mrb_float_value( mrb, class_raylib_vector4_get_ptr( mrb, self )->z );
}
	
static mrb_value
class_raylib_vector4_set_z( mrb_state *mrb, mrb_value self ) {
	mrb_float param0;
	mrb_get_args( mrb, "f", &param0 );
	class_raylib_vector4_get_ptr( mrb, self )->z = param0;
	return self;
}
	
static mrb_value
class_raylib_vector4_get_w( mrb_state *mrb, mrb_value self ) {
	return mrb_float_value( mrb, class_raylib_vector4_get_ptr( mrb, self )->w );
}
	
static mrb_value
class_raylib_vector4_set_w( mrb_state *mrb, mrb_value self ) {
	mrb_float param0;
	mrb_get_args( mrb, "f", &param0 );
	class_raylib_vector4_get_ptr( mrb, self )->w = param0;
	return self;
}
	
void
class_raylib_vector4_init( mrb_state *mrb, struct RClass *mod_RayLib ) {
	class_Vector4 = mrb_define_class_under( mrb, mod_RayLib, "Vector4", mrb->object_class );

	MRB_SET_INSTANCE_TT( class_Vector4, MRB_TT_DATA );

	mrb_define_method( mrb, class_Vector4, "initialize", class_raylib_vector4_initialize, MRB_ARGS_NONE() );

	mrb_define_method( mrb, class_Vector4, "x", class_raylib_vector4_get_x, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Vector4, "x=", class_raylib_vector4_set_x, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Vector4, "y", class_raylib_vector4_get_y, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Vector4, "y=", class_raylib_vector4_set_y, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Vector4, "z", class_raylib_vector4_get_z, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Vector4, "z=", class_raylib_vector4_set_z, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Vector4, "w", class_raylib_vector4_get_w, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Vector4, "w=", class_raylib_vector4_set_w, MRB_ARGS_REQ( 1 ) );
}
//----------------------------------------------------------------//


//----------------------------------------------------------------//
// Raylib::Matrix
static struct RClass *class_Matrix;

typedef struct class_raylib_matrix_data_t {
	bool is_associated;
	Matrix matrix;
} class_raylib_matrix_data_t;
		
static void
class_raylib_matrix_data_free( mrb_state *mrb, void *p ) {
	class_raylib_matrix_data_t *data = ( class_raylib_matrix_data_t* )p;
	if ( NULL != data ) {
		mrb_free( mrb, data );
	}
}

static struct mrb_data_type const class_raylib_matrix_data_type = {
	"Matrix", class_raylib_matrix_data_free
};

mrb_value
class_raylib_matrix_2_mrbvalue( mrb_state *mrb, Matrix *matrix, bool is_associated ) {
	class_raylib_matrix_data_t *data = ( class_raylib_matrix_data_t* )mrb_malloc( mrb, sizeof( class_raylib_matrix_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	data->is_associated = is_associated;
	data->matrix = *matrix;
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_Matrix, &class_raylib_matrix_data_type, data ) );
}

mrb_value
class_raylib_matrix_2_mrbvalue_direct( mrb_state *mrb, Matrix const *matrix ) {
	class_raylib_matrix_data_t *data = ( class_raylib_matrix_data_t* )mrb_malloc( mrb, sizeof( class_raylib_matrix_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	if ( NULL == matrix ) {
		// Do init
	} else {
		// Do Copy
		data->matrix = *matrix;
	}
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_Matrix, &class_raylib_matrix_data_type, data ) );
}

Matrix*
class_raylib_matrix_get_ptr( mrb_state *mrb, mrb_value matrix ) {
	class_raylib_matrix_data_t *data;
	if ( mrb_nil_p( matrix ) ) {
		return NULL;
	}
	data = ( class_raylib_matrix_data_t* )mrb_data_get_ptr( mrb, matrix, &class_raylib_matrix_data_type );
	return &data->matrix;
}

static mrb_value
class_raylib_matrix_initialize( mrb_state *mrb, mrb_value self ) {
	class_raylib_matrix_data_t *data = DATA_PTR( self );

	if ( NULL == data ) {
		data = mrb_malloc( mrb, sizeof( class_raylib_matrix_data_t ) );
		if ( NULL == data ) {
			mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
		}
		//data->matrix = { 0 };
	} else {
		// if ( NULL != &( data->matrix ) ) {
		// 
		// }
	}
	Matrix matrix = { 0 };
	data->matrix = matrix;
	// if ( NULL == &( data->matrix ) ) {
	//	mrb_free( mrb, data );
	// }
	DATA_PTR( self ) = data;
	DATA_TYPE( self ) = &class_raylib_matrix_data_type;
	return self;
}

static mrb_value
class_raylib_matrix_get_m0( mrb_state *mrb, mrb_value self ) {
	return mrb_float_value( mrb, class_raylib_matrix_get_ptr( mrb, self )->m0 );
}
	
static mrb_value
class_raylib_matrix_set_m0( mrb_state *mrb, mrb_value self ) {
	mrb_float param0;
	mrb_get_args( mrb, "f", &param0 );
	class_raylib_matrix_get_ptr( mrb, self )->m0 = param0;
	return self;
}
	
static mrb_value
class_raylib_matrix_get_m4( mrb_state *mrb, mrb_value self ) {
	return mrb_float_value( mrb, class_raylib_matrix_get_ptr( mrb, self )->m4 );
}
	
static mrb_value
class_raylib_matrix_set_m4( mrb_state *mrb, mrb_value self ) {
	mrb_float param0;
	mrb_get_args( mrb, "f", &param0 );
	class_raylib_matrix_get_ptr( mrb, self )->m4 = param0;
	return self;
}
	
static mrb_value
class_raylib_matrix_get_m8( mrb_state *mrb, mrb_value self ) {
	return mrb_float_value( mrb, class_raylib_matrix_get_ptr( mrb, self )->m8 );
}
	
static mrb_value
class_raylib_matrix_set_m8( mrb_state *mrb, mrb_value self ) {
	mrb_float param0;
	mrb_get_args( mrb, "f", &param0 );
	class_raylib_matrix_get_ptr( mrb, self )->m8 = param0;
	return self;
}
	
static mrb_value
class_raylib_matrix_get_m12( mrb_state *mrb, mrb_value self ) {
	return mrb_float_value( mrb, class_raylib_matrix_get_ptr( mrb, self )->m12 );
}
	
static mrb_value
class_raylib_matrix_set_m12( mrb_state *mrb, mrb_value self ) {
	mrb_float param0;
	mrb_get_args( mrb, "f", &param0 );
	class_raylib_matrix_get_ptr( mrb, self )->m12 = param0;
	return self;
}
	
static mrb_value
class_raylib_matrix_get_m1( mrb_state *mrb, mrb_value self ) {
	return mrb_float_value( mrb, class_raylib_matrix_get_ptr( mrb, self )->m1 );
}
	
static mrb_value
class_raylib_matrix_set_m1( mrb_state *mrb, mrb_value self ) {
	mrb_float param0;
	mrb_get_args( mrb, "f", &param0 );
	class_raylib_matrix_get_ptr( mrb, self )->m1 = param0;
	return self;
}
	
static mrb_value
class_raylib_matrix_get_m5( mrb_state *mrb, mrb_value self ) {
	return mrb_float_value( mrb, class_raylib_matrix_get_ptr( mrb, self )->m5 );
}
	
static mrb_value
class_raylib_matrix_set_m5( mrb_state *mrb, mrb_value self ) {
	mrb_float param0;
	mrb_get_args( mrb, "f", &param0 );
	class_raylib_matrix_get_ptr( mrb, self )->m5 = param0;
	return self;
}
	
static mrb_value
class_raylib_matrix_get_m9( mrb_state *mrb, mrb_value self ) {
	return mrb_float_value( mrb, class_raylib_matrix_get_ptr( mrb, self )->m9 );
}
	
static mrb_value
class_raylib_matrix_set_m9( mrb_state *mrb, mrb_value self ) {
	mrb_float param0;
	mrb_get_args( mrb, "f", &param0 );
	class_raylib_matrix_get_ptr( mrb, self )->m9 = param0;
	return self;
}
	
static mrb_value
class_raylib_matrix_get_m13( mrb_state *mrb, mrb_value self ) {
	return mrb_float_value( mrb, class_raylib_matrix_get_ptr( mrb, self )->m13 );
}
	
static mrb_value
class_raylib_matrix_set_m13( mrb_state *mrb, mrb_value self ) {
	mrb_float param0;
	mrb_get_args( mrb, "f", &param0 );
	class_raylib_matrix_get_ptr( mrb, self )->m13 = param0;
	return self;
}
	
static mrb_value
class_raylib_matrix_get_m2( mrb_state *mrb, mrb_value self ) {
	return mrb_float_value( mrb, class_raylib_matrix_get_ptr( mrb, self )->m2 );
}
	
static mrb_value
class_raylib_matrix_set_m2( mrb_state *mrb, mrb_value self ) {
	mrb_float param0;
	mrb_get_args( mrb, "f", &param0 );
	class_raylib_matrix_get_ptr( mrb, self )->m2 = param0;
	return self;
}
	
static mrb_value
class_raylib_matrix_get_m6( mrb_state *mrb, mrb_value self ) {
	return mrb_float_value( mrb, class_raylib_matrix_get_ptr( mrb, self )->m6 );
}
	
static mrb_value
class_raylib_matrix_set_m6( mrb_state *mrb, mrb_value self ) {
	mrb_float param0;
	mrb_get_args( mrb, "f", &param0 );
	class_raylib_matrix_get_ptr( mrb, self )->m6 = param0;
	return self;
}
	
static mrb_value
class_raylib_matrix_get_m10( mrb_state *mrb, mrb_value self ) {
	return mrb_float_value( mrb, class_raylib_matrix_get_ptr( mrb, self )->m10 );
}
	
static mrb_value
class_raylib_matrix_set_m10( mrb_state *mrb, mrb_value self ) {
	mrb_float param0;
	mrb_get_args( mrb, "f", &param0 );
	class_raylib_matrix_get_ptr( mrb, self )->m10 = param0;
	return self;
}
	
static mrb_value
class_raylib_matrix_get_m14( mrb_state *mrb, mrb_value self ) {
	return mrb_float_value( mrb, class_raylib_matrix_get_ptr( mrb, self )->m14 );
}
	
static mrb_value
class_raylib_matrix_set_m14( mrb_state *mrb, mrb_value self ) {
	mrb_float param0;
	mrb_get_args( mrb, "f", &param0 );
	class_raylib_matrix_get_ptr( mrb, self )->m14 = param0;
	return self;
}
	
static mrb_value
class_raylib_matrix_get_m3( mrb_state *mrb, mrb_value self ) {
	return mrb_float_value( mrb, class_raylib_matrix_get_ptr( mrb, self )->m3 );
}
	
static mrb_value
class_raylib_matrix_set_m3( mrb_state *mrb, mrb_value self ) {
	mrb_float param0;
	mrb_get_args( mrb, "f", &param0 );
	class_raylib_matrix_get_ptr( mrb, self )->m3 = param0;
	return self;
}
	
static mrb_value
class_raylib_matrix_get_m7( mrb_state *mrb, mrb_value self ) {
	return mrb_float_value( mrb, class_raylib_matrix_get_ptr( mrb, self )->m7 );
}
	
static mrb_value
class_raylib_matrix_set_m7( mrb_state *mrb, mrb_value self ) {
	mrb_float param0;
	mrb_get_args( mrb, "f", &param0 );
	class_raylib_matrix_get_ptr( mrb, self )->m7 = param0;
	return self;
}
	
static mrb_value
class_raylib_matrix_get_m11( mrb_state *mrb, mrb_value self ) {
	return mrb_float_value( mrb, class_raylib_matrix_get_ptr( mrb, self )->m11 );
}
	
static mrb_value
class_raylib_matrix_set_m11( mrb_state *mrb, mrb_value self ) {
	mrb_float param0;
	mrb_get_args( mrb, "f", &param0 );
	class_raylib_matrix_get_ptr( mrb, self )->m11 = param0;
	return self;
}
	
static mrb_value
class_raylib_matrix_get_m15( mrb_state *mrb, mrb_value self ) {
	return mrb_float_value( mrb, class_raylib_matrix_get_ptr( mrb, self )->m15 );
}
	
static mrb_value
class_raylib_matrix_set_m15( mrb_state *mrb, mrb_value self ) {
	mrb_float param0;
	mrb_get_args( mrb, "f", &param0 );
	class_raylib_matrix_get_ptr( mrb, self )->m15 = param0;
	return self;
}
	
void
class_raylib_matrix_init( mrb_state *mrb, struct RClass *mod_RayLib ) {
	class_Matrix = mrb_define_class_under( mrb, mod_RayLib, "Matrix", mrb->object_class );

	MRB_SET_INSTANCE_TT( class_Matrix, MRB_TT_DATA );

	mrb_define_method( mrb, class_Matrix, "initialize", class_raylib_matrix_initialize, MRB_ARGS_NONE() );

	mrb_define_method( mrb, class_Matrix, "m0", class_raylib_matrix_get_m0, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Matrix, "m0=", class_raylib_matrix_set_m0, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Matrix, "m4", class_raylib_matrix_get_m4, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Matrix, "m4=", class_raylib_matrix_set_m4, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Matrix, "m8", class_raylib_matrix_get_m8, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Matrix, "m8=", class_raylib_matrix_set_m8, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Matrix, "m12", class_raylib_matrix_get_m12, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Matrix, "m12=", class_raylib_matrix_set_m12, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Matrix, "m1", class_raylib_matrix_get_m1, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Matrix, "m1=", class_raylib_matrix_set_m1, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Matrix, "m5", class_raylib_matrix_get_m5, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Matrix, "m5=", class_raylib_matrix_set_m5, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Matrix, "m9", class_raylib_matrix_get_m9, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Matrix, "m9=", class_raylib_matrix_set_m9, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Matrix, "m13", class_raylib_matrix_get_m13, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Matrix, "m13=", class_raylib_matrix_set_m13, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Matrix, "m2", class_raylib_matrix_get_m2, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Matrix, "m2=", class_raylib_matrix_set_m2, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Matrix, "m6", class_raylib_matrix_get_m6, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Matrix, "m6=", class_raylib_matrix_set_m6, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Matrix, "m10", class_raylib_matrix_get_m10, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Matrix, "m10=", class_raylib_matrix_set_m10, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Matrix, "m14", class_raylib_matrix_get_m14, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Matrix, "m14=", class_raylib_matrix_set_m14, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Matrix, "m3", class_raylib_matrix_get_m3, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Matrix, "m3=", class_raylib_matrix_set_m3, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Matrix, "m7", class_raylib_matrix_get_m7, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Matrix, "m7=", class_raylib_matrix_set_m7, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Matrix, "m11", class_raylib_matrix_get_m11, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Matrix, "m11=", class_raylib_matrix_set_m11, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Matrix, "m15", class_raylib_matrix_get_m15, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Matrix, "m15=", class_raylib_matrix_set_m15, MRB_ARGS_REQ( 1 ) );
}
//----------------------------------------------------------------//


//----------------------------------------------------------------//
// Raylib::Color
static struct RClass *class_Color;

typedef struct class_raylib_color_data_t {
	bool is_associated;
	Color color;
} class_raylib_color_data_t;
		
static void
class_raylib_color_data_free( mrb_state *mrb, void *p ) {
	class_raylib_color_data_t *data = ( class_raylib_color_data_t* )p;
	if ( NULL != data ) {
		mrb_free( mrb, data );
	}
}

static struct mrb_data_type const class_raylib_color_data_type = {
	"Color", class_raylib_color_data_free
};

mrb_value
class_raylib_color_2_mrbvalue( mrb_state *mrb, Color *color, bool is_associated ) {
	class_raylib_color_data_t *data = ( class_raylib_color_data_t* )mrb_malloc( mrb, sizeof( class_raylib_color_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	data->is_associated = is_associated;
	data->color = *color;
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_Color, &class_raylib_color_data_type, data ) );
}

mrb_value
class_raylib_color_2_mrbvalue_direct( mrb_state *mrb, Color const *color ) {
	class_raylib_color_data_t *data = ( class_raylib_color_data_t* )mrb_malloc( mrb, sizeof( class_raylib_color_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	if ( NULL == color ) {
		// Do init
	} else {
		// Do Copy
		data->color = *color;
	}
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_Color, &class_raylib_color_data_type, data ) );
}

Color*
class_raylib_color_get_ptr( mrb_state *mrb, mrb_value color ) {
	class_raylib_color_data_t *data;
	if ( mrb_nil_p( color ) ) {
		return NULL;
	}
	data = ( class_raylib_color_data_t* )mrb_data_get_ptr( mrb, color, &class_raylib_color_data_type );
	return &data->color;
}

static mrb_value
class_raylib_color_initialize( mrb_state *mrb, mrb_value self ) {
	class_raylib_color_data_t *data = DATA_PTR( self );

	if ( NULL == data ) {
		data = mrb_malloc( mrb, sizeof( class_raylib_color_data_t ) );
		if ( NULL == data ) {
			mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
		}
		//data->color = { 0 };
	} else {
		// if ( NULL != &( data->color ) ) {
		// 
		// }
	}
	Color color = { 0 };
	data->color = color;
	// if ( NULL == &( data->color ) ) {
	//	mrb_free( mrb, data );
	// }
	DATA_PTR( self ) = data;
	DATA_TYPE( self ) = &class_raylib_color_data_type;
	return self;
}

static mrb_value
class_raylib_color_get_r( mrb_state *mrb, mrb_value self ) {
	return mrb_fixnum_value( class_raylib_color_get_ptr( mrb, self )->r );
}
	
static mrb_value
class_raylib_color_set_r( mrb_state *mrb, mrb_value self ) {
	mrb_int param0;
	mrb_get_args( mrb, "i", &param0 );
	class_raylib_color_get_ptr( mrb, self )->r = param0;
	return self;
}
	
static mrb_value
class_raylib_color_get_g( mrb_state *mrb, mrb_value self ) {
	return mrb_fixnum_value( class_raylib_color_get_ptr( mrb, self )->g );
}
	
static mrb_value
class_raylib_color_set_g( mrb_state *mrb, mrb_value self ) {
	mrb_int param0;
	mrb_get_args( mrb, "i", &param0 );
	class_raylib_color_get_ptr( mrb, self )->g = param0;
	return self;
}
	
static mrb_value
class_raylib_color_get_b( mrb_state *mrb, mrb_value self ) {
	return mrb_fixnum_value( class_raylib_color_get_ptr( mrb, self )->b );
}
	
static mrb_value
class_raylib_color_set_b( mrb_state *mrb, mrb_value self ) {
	mrb_int param0;
	mrb_get_args( mrb, "i", &param0 );
	class_raylib_color_get_ptr( mrb, self )->b = param0;
	return self;
}
	
static mrb_value
class_raylib_color_get_a( mrb_state *mrb, mrb_value self ) {
	return mrb_fixnum_value( class_raylib_color_get_ptr( mrb, self )->a );
}
	
static mrb_value
class_raylib_color_set_a( mrb_state *mrb, mrb_value self ) {
	mrb_int param0;
	mrb_get_args( mrb, "i", &param0 );
	class_raylib_color_get_ptr( mrb, self )->a = param0;
	return self;
}
	
void
class_raylib_color_init( mrb_state *mrb, struct RClass *mod_RayLib ) {
	class_Color = mrb_define_class_under( mrb, mod_RayLib, "Color", mrb->object_class );

	MRB_SET_INSTANCE_TT( class_Color, MRB_TT_DATA );

	mrb_define_method( mrb, class_Color, "initialize", class_raylib_color_initialize, MRB_ARGS_NONE() );

	mrb_define_method( mrb, class_Color, "r", class_raylib_color_get_r, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Color, "r=", class_raylib_color_set_r, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Color, "g", class_raylib_color_get_g, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Color, "g=", class_raylib_color_set_g, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Color, "b", class_raylib_color_get_b, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Color, "b=", class_raylib_color_set_b, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Color, "a", class_raylib_color_get_a, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Color, "a=", class_raylib_color_set_a, MRB_ARGS_REQ( 1 ) );
}
//----------------------------------------------------------------//


//----------------------------------------------------------------//
// Raylib::Rectangle
static struct RClass *class_Rectangle;

typedef struct class_raylib_rectangle_data_t {
	bool is_associated;
	Rectangle rectangle;
} class_raylib_rectangle_data_t;
		
static void
class_raylib_rectangle_data_free( mrb_state *mrb, void *p ) {
	class_raylib_rectangle_data_t *data = ( class_raylib_rectangle_data_t* )p;
	if ( NULL != data ) {
		mrb_free( mrb, data );
	}
}

static struct mrb_data_type const class_raylib_rectangle_data_type = {
	"Rectangle", class_raylib_rectangle_data_free
};

mrb_value
class_raylib_rectangle_2_mrbvalue( mrb_state *mrb, Rectangle *rectangle, bool is_associated ) {
	class_raylib_rectangle_data_t *data = ( class_raylib_rectangle_data_t* )mrb_malloc( mrb, sizeof( class_raylib_rectangle_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	data->is_associated = is_associated;
	data->rectangle = *rectangle;
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_Rectangle, &class_raylib_rectangle_data_type, data ) );
}

mrb_value
class_raylib_rectangle_2_mrbvalue_direct( mrb_state *mrb, Rectangle const *rectangle ) {
	class_raylib_rectangle_data_t *data = ( class_raylib_rectangle_data_t* )mrb_malloc( mrb, sizeof( class_raylib_rectangle_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	if ( NULL == rectangle ) {
		// Do init
	} else {
		// Do Copy
		data->rectangle = *rectangle;
	}
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_Rectangle, &class_raylib_rectangle_data_type, data ) );
}

Rectangle*
class_raylib_rectangle_get_ptr( mrb_state *mrb, mrb_value rectangle ) {
	class_raylib_rectangle_data_t *data;
	if ( mrb_nil_p( rectangle ) ) {
		return NULL;
	}
	data = ( class_raylib_rectangle_data_t* )mrb_data_get_ptr( mrb, rectangle, &class_raylib_rectangle_data_type );
	return &data->rectangle;
}

static mrb_value
class_raylib_rectangle_initialize( mrb_state *mrb, mrb_value self ) {
	class_raylib_rectangle_data_t *data = DATA_PTR( self );

	if ( NULL == data ) {
		data = mrb_malloc( mrb, sizeof( class_raylib_rectangle_data_t ) );
		if ( NULL == data ) {
			mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
		}
		//data->rectangle = { 0 };
	} else {
		// if ( NULL != &( data->rectangle ) ) {
		// 
		// }
	}
	Rectangle rectangle = { 0 };
	data->rectangle = rectangle;
	// if ( NULL == &( data->rectangle ) ) {
	//	mrb_free( mrb, data );
	// }
	DATA_PTR( self ) = data;
	DATA_TYPE( self ) = &class_raylib_rectangle_data_type;
	return self;
}

static mrb_value
class_raylib_rectangle_get_x( mrb_state *mrb, mrb_value self ) {
	return mrb_float_value( mrb, class_raylib_rectangle_get_ptr( mrb, self )->x );
}
	
static mrb_value
class_raylib_rectangle_set_x( mrb_state *mrb, mrb_value self ) {
	mrb_float param0;
	mrb_get_args( mrb, "f", &param0 );
	class_raylib_rectangle_get_ptr( mrb, self )->x = param0;
	return self;
}
	
static mrb_value
class_raylib_rectangle_get_y( mrb_state *mrb, mrb_value self ) {
	return mrb_float_value( mrb, class_raylib_rectangle_get_ptr( mrb, self )->y );
}
	
static mrb_value
class_raylib_rectangle_set_y( mrb_state *mrb, mrb_value self ) {
	mrb_float param0;
	mrb_get_args( mrb, "f", &param0 );
	class_raylib_rectangle_get_ptr( mrb, self )->y = param0;
	return self;
}
	
static mrb_value
class_raylib_rectangle_get_width( mrb_state *mrb, mrb_value self ) {
	return mrb_float_value( mrb, class_raylib_rectangle_get_ptr( mrb, self )->width );
}
	
static mrb_value
class_raylib_rectangle_set_width( mrb_state *mrb, mrb_value self ) {
	mrb_float param0;
	mrb_get_args( mrb, "f", &param0 );
	class_raylib_rectangle_get_ptr( mrb, self )->width = param0;
	return self;
}
	
static mrb_value
class_raylib_rectangle_get_height( mrb_state *mrb, mrb_value self ) {
	return mrb_float_value( mrb, class_raylib_rectangle_get_ptr( mrb, self )->height );
}
	
static mrb_value
class_raylib_rectangle_set_height( mrb_state *mrb, mrb_value self ) {
	mrb_float param0;
	mrb_get_args( mrb, "f", &param0 );
	class_raylib_rectangle_get_ptr( mrb, self )->height = param0;
	return self;
}
	
void
class_raylib_rectangle_init( mrb_state *mrb, struct RClass *mod_RayLib ) {
	class_Rectangle = mrb_define_class_under( mrb, mod_RayLib, "Rectangle", mrb->object_class );

	MRB_SET_INSTANCE_TT( class_Rectangle, MRB_TT_DATA );

	mrb_define_method( mrb, class_Rectangle, "initialize", class_raylib_rectangle_initialize, MRB_ARGS_NONE() );

	mrb_define_method( mrb, class_Rectangle, "x", class_raylib_rectangle_get_x, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Rectangle, "x=", class_raylib_rectangle_set_x, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Rectangle, "y", class_raylib_rectangle_get_y, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Rectangle, "y=", class_raylib_rectangle_set_y, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Rectangle, "width", class_raylib_rectangle_get_width, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Rectangle, "width=", class_raylib_rectangle_set_width, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Rectangle, "height", class_raylib_rectangle_get_height, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Rectangle, "height=", class_raylib_rectangle_set_height, MRB_ARGS_REQ( 1 ) );
}
//----------------------------------------------------------------//


//----------------------------------------------------------------//
// Raylib::Image
static struct RClass *class_Image;

typedef struct class_raylib_image_data_t {
	bool is_associated;
	Image image;
} class_raylib_image_data_t;
		
static void
class_raylib_image_data_free( mrb_state *mrb, void *p ) {
	class_raylib_image_data_t *data = ( class_raylib_image_data_t* )p;
	if ( NULL != data ) {
		mrb_free( mrb, data );
	}
}

static struct mrb_data_type const class_raylib_image_data_type = {
	"Image", class_raylib_image_data_free
};

mrb_value
class_raylib_image_2_mrbvalue( mrb_state *mrb, Image *image, bool is_associated ) {
	class_raylib_image_data_t *data = ( class_raylib_image_data_t* )mrb_malloc( mrb, sizeof( class_raylib_image_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	data->is_associated = is_associated;
	data->image = *image;
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_Image, &class_raylib_image_data_type, data ) );
}

mrb_value
class_raylib_image_2_mrbvalue_direct( mrb_state *mrb, Image const *image ) {
	class_raylib_image_data_t *data = ( class_raylib_image_data_t* )mrb_malloc( mrb, sizeof( class_raylib_image_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	if ( NULL == image ) {
		// Do init
	} else {
		// Do Copy
		data->image = *image;
	}
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_Image, &class_raylib_image_data_type, data ) );
}

Image*
class_raylib_image_get_ptr( mrb_state *mrb, mrb_value image ) {
	class_raylib_image_data_t *data;
	if ( mrb_nil_p( image ) ) {
		return NULL;
	}
	data = ( class_raylib_image_data_t* )mrb_data_get_ptr( mrb, image, &class_raylib_image_data_type );
	return &data->image;
}

static mrb_value
class_raylib_image_initialize( mrb_state *mrb, mrb_value self ) {
	class_raylib_image_data_t *data = DATA_PTR( self );

	if ( NULL == data ) {
		data = mrb_malloc( mrb, sizeof( class_raylib_image_data_t ) );
		if ( NULL == data ) {
			mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
		}
		//data->image = { 0 };
	} else {
		// if ( NULL != &( data->image ) ) {
		// 
		// }
	}
	Image image = { 0 };
	data->image = image;
	// if ( NULL == &( data->image ) ) {
	//	mrb_free( mrb, data );
	// }
	DATA_PTR( self ) = data;
	DATA_TYPE( self ) = &class_raylib_image_data_type;
	return self;
}

static mrb_value
class_raylib_image_get_data( mrb_state *mrb, mrb_value self ) {
	return mrb_cptr_value( mrb, class_raylib_image_get_ptr( mrb, self )->data );
}
	
static mrb_value
class_raylib_image_set_data( mrb_state *mrb, mrb_value self ) {
	mrb_value param0;
	mrb_get_args( mrb, "d", &param0 );
	class_raylib_image_get_ptr( mrb, self )->data = mrb_cptr( param0 );
	return self;
}
	
static mrb_value
class_raylib_image_get_width( mrb_state *mrb, mrb_value self ) {
	return mrb_fixnum_value( class_raylib_image_get_ptr( mrb, self )->width );
}
	
static mrb_value
class_raylib_image_set_width( mrb_state *mrb, mrb_value self ) {
	mrb_int param0;
	mrb_get_args( mrb, "i", &param0 );
	class_raylib_image_get_ptr( mrb, self )->width = param0;
	return self;
}
	
static mrb_value
class_raylib_image_get_height( mrb_state *mrb, mrb_value self ) {
	return mrb_fixnum_value( class_raylib_image_get_ptr( mrb, self )->height );
}
	
static mrb_value
class_raylib_image_set_height( mrb_state *mrb, mrb_value self ) {
	mrb_int param0;
	mrb_get_args( mrb, "i", &param0 );
	class_raylib_image_get_ptr( mrb, self )->height = param0;
	return self;
}
	
static mrb_value
class_raylib_image_get_mipmaps( mrb_state *mrb, mrb_value self ) {
	return mrb_fixnum_value( class_raylib_image_get_ptr( mrb, self )->mipmaps );
}
	
static mrb_value
class_raylib_image_set_mipmaps( mrb_state *mrb, mrb_value self ) {
	mrb_int param0;
	mrb_get_args( mrb, "i", &param0 );
	class_raylib_image_get_ptr( mrb, self )->mipmaps = param0;
	return self;
}
	
static mrb_value
class_raylib_image_get_format( mrb_state *mrb, mrb_value self ) {
	return mrb_fixnum_value( class_raylib_image_get_ptr( mrb, self )->format );
}
	
static mrb_value
class_raylib_image_set_format( mrb_state *mrb, mrb_value self ) {
	mrb_int param0;
	mrb_get_args( mrb, "i", &param0 );
	class_raylib_image_get_ptr( mrb, self )->format = param0;
	return self;
}
	
void
class_raylib_image_init( mrb_state *mrb, struct RClass *mod_RayLib ) {
	class_Image = mrb_define_class_under( mrb, mod_RayLib, "Image", mrb->object_class );

	MRB_SET_INSTANCE_TT( class_Image, MRB_TT_DATA );

	mrb_define_method( mrb, class_Image, "initialize", class_raylib_image_initialize, MRB_ARGS_NONE() );

	mrb_define_method( mrb, class_Image, "data", class_raylib_image_get_data, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Image, "data=", class_raylib_image_set_data, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Image, "width", class_raylib_image_get_width, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Image, "width=", class_raylib_image_set_width, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Image, "height", class_raylib_image_get_height, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Image, "height=", class_raylib_image_set_height, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Image, "mipmaps", class_raylib_image_get_mipmaps, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Image, "mipmaps=", class_raylib_image_set_mipmaps, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Image, "format", class_raylib_image_get_format, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Image, "format=", class_raylib_image_set_format, MRB_ARGS_REQ( 1 ) );
}
//----------------------------------------------------------------//


//----------------------------------------------------------------//
// Raylib::Texture
static struct RClass *class_Texture;

typedef struct class_raylib_texture_data_t {
	bool is_associated;
	Texture texture;
} class_raylib_texture_data_t;
		
static void
class_raylib_texture_data_free( mrb_state *mrb, void *p ) {
	class_raylib_texture_data_t *data = ( class_raylib_texture_data_t* )p;
	if ( NULL != data ) {
		mrb_free( mrb, data );
	}
}

static struct mrb_data_type const class_raylib_texture_data_type = {
	"Texture", class_raylib_texture_data_free
};

mrb_value
class_raylib_texture_2_mrbvalue( mrb_state *mrb, Texture *texture, bool is_associated ) {
	class_raylib_texture_data_t *data = ( class_raylib_texture_data_t* )mrb_malloc( mrb, sizeof( class_raylib_texture_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	data->is_associated = is_associated;
	data->texture = *texture;
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_Texture, &class_raylib_texture_data_type, data ) );
}

mrb_value
class_raylib_texture_2_mrbvalue_direct( mrb_state *mrb, Texture const *texture ) {
	class_raylib_texture_data_t *data = ( class_raylib_texture_data_t* )mrb_malloc( mrb, sizeof( class_raylib_texture_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	if ( NULL == texture ) {
		// Do init
	} else {
		// Do Copy
		data->texture = *texture;
	}
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_Texture, &class_raylib_texture_data_type, data ) );
}

Texture*
class_raylib_texture_get_ptr( mrb_state *mrb, mrb_value texture ) {
	class_raylib_texture_data_t *data;
	if ( mrb_nil_p( texture ) ) {
		return NULL;
	}
	data = ( class_raylib_texture_data_t* )mrb_data_get_ptr( mrb, texture, &class_raylib_texture_data_type );
	return &data->texture;
}

static mrb_value
class_raylib_texture_initialize( mrb_state *mrb, mrb_value self ) {
	class_raylib_texture_data_t *data = DATA_PTR( self );

	if ( NULL == data ) {
		data = mrb_malloc( mrb, sizeof( class_raylib_texture_data_t ) );
		if ( NULL == data ) {
			mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
		}
		//data->texture = { 0 };
	} else {
		// if ( NULL != &( data->texture ) ) {
		// 
		// }
	}
	Texture texture = { 0 };
	data->texture = texture;
	// if ( NULL == &( data->texture ) ) {
	//	mrb_free( mrb, data );
	// }
	DATA_PTR( self ) = data;
	DATA_TYPE( self ) = &class_raylib_texture_data_type;
	return self;
}

static mrb_value
class_raylib_texture_get_id( mrb_state *mrb, mrb_value self ) {
	return mrb_fixnum_value( class_raylib_texture_get_ptr( mrb, self )->id );
}
	
static mrb_value
class_raylib_texture_set_id( mrb_state *mrb, mrb_value self ) {
	mrb_int param0;
	mrb_get_args( mrb, "i", &param0 );
	class_raylib_texture_get_ptr( mrb, self )->id = param0;
	return self;
}
	
static mrb_value
class_raylib_texture_get_width( mrb_state *mrb, mrb_value self ) {
	return mrb_fixnum_value( class_raylib_texture_get_ptr( mrb, self )->width );
}
	
static mrb_value
class_raylib_texture_set_width( mrb_state *mrb, mrb_value self ) {
	mrb_int param0;
	mrb_get_args( mrb, "i", &param0 );
	class_raylib_texture_get_ptr( mrb, self )->width = param0;
	return self;
}
	
static mrb_value
class_raylib_texture_get_height( mrb_state *mrb, mrb_value self ) {
	return mrb_fixnum_value( class_raylib_texture_get_ptr( mrb, self )->height );
}
	
static mrb_value
class_raylib_texture_set_height( mrb_state *mrb, mrb_value self ) {
	mrb_int param0;
	mrb_get_args( mrb, "i", &param0 );
	class_raylib_texture_get_ptr( mrb, self )->height = param0;
	return self;
}
	
static mrb_value
class_raylib_texture_get_mipmaps( mrb_state *mrb, mrb_value self ) {
	return mrb_fixnum_value( class_raylib_texture_get_ptr( mrb, self )->mipmaps );
}
	
static mrb_value
class_raylib_texture_set_mipmaps( mrb_state *mrb, mrb_value self ) {
	mrb_int param0;
	mrb_get_args( mrb, "i", &param0 );
	class_raylib_texture_get_ptr( mrb, self )->mipmaps = param0;
	return self;
}
	
static mrb_value
class_raylib_texture_get_format( mrb_state *mrb, mrb_value self ) {
	return mrb_fixnum_value( class_raylib_texture_get_ptr( mrb, self )->format );
}
	
static mrb_value
class_raylib_texture_set_format( mrb_state *mrb, mrb_value self ) {
	mrb_int param0;
	mrb_get_args( mrb, "i", &param0 );
	class_raylib_texture_get_ptr( mrb, self )->format = param0;
	return self;
}
	
void
class_raylib_texture_init( mrb_state *mrb, struct RClass *mod_RayLib ) {
	class_Texture = mrb_define_class_under( mrb, mod_RayLib, "Texture", mrb->object_class );

	MRB_SET_INSTANCE_TT( class_Texture, MRB_TT_DATA );

	mrb_define_method( mrb, class_Texture, "initialize", class_raylib_texture_initialize, MRB_ARGS_NONE() );

	mrb_define_method( mrb, class_Texture, "id", class_raylib_texture_get_id, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Texture, "id=", class_raylib_texture_set_id, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Texture, "width", class_raylib_texture_get_width, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Texture, "width=", class_raylib_texture_set_width, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Texture, "height", class_raylib_texture_get_height, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Texture, "height=", class_raylib_texture_set_height, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Texture, "mipmaps", class_raylib_texture_get_mipmaps, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Texture, "mipmaps=", class_raylib_texture_set_mipmaps, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Texture, "format", class_raylib_texture_get_format, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Texture, "format=", class_raylib_texture_set_format, MRB_ARGS_REQ( 1 ) );
}
//----------------------------------------------------------------//


//----------------------------------------------------------------//
// Raylib::RenderTexture
static struct RClass *class_RenderTexture;

typedef struct class_raylib_rendertexture_data_t {
	bool is_associated;
	RenderTexture rendertexture;
} class_raylib_rendertexture_data_t;
		
static void
class_raylib_rendertexture_data_free( mrb_state *mrb, void *p ) {
	class_raylib_rendertexture_data_t *data = ( class_raylib_rendertexture_data_t* )p;
	if ( NULL != data ) {
		mrb_free( mrb, data );
	}
}

static struct mrb_data_type const class_raylib_rendertexture_data_type = {
	"RenderTexture", class_raylib_rendertexture_data_free
};

mrb_value
class_raylib_rendertexture_2_mrbvalue( mrb_state *mrb, RenderTexture *rendertexture, bool is_associated ) {
	class_raylib_rendertexture_data_t *data = ( class_raylib_rendertexture_data_t* )mrb_malloc( mrb, sizeof( class_raylib_rendertexture_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	data->is_associated = is_associated;
	data->rendertexture = *rendertexture;
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_RenderTexture, &class_raylib_rendertexture_data_type, data ) );
}

mrb_value
class_raylib_rendertexture_2_mrbvalue_direct( mrb_state *mrb, RenderTexture const *rendertexture ) {
	class_raylib_rendertexture_data_t *data = ( class_raylib_rendertexture_data_t* )mrb_malloc( mrb, sizeof( class_raylib_rendertexture_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	if ( NULL == rendertexture ) {
		// Do init
	} else {
		// Do Copy
		data->rendertexture = *rendertexture;
	}
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_RenderTexture, &class_raylib_rendertexture_data_type, data ) );
}

RenderTexture*
class_raylib_rendertexture_get_ptr( mrb_state *mrb, mrb_value rendertexture ) {
	class_raylib_rendertexture_data_t *data;
	if ( mrb_nil_p( rendertexture ) ) {
		return NULL;
	}
	data = ( class_raylib_rendertexture_data_t* )mrb_data_get_ptr( mrb, rendertexture, &class_raylib_rendertexture_data_type );
	return &data->rendertexture;
}

static mrb_value
class_raylib_rendertexture_initialize( mrb_state *mrb, mrb_value self ) {
	class_raylib_rendertexture_data_t *data = DATA_PTR( self );

	if ( NULL == data ) {
		data = mrb_malloc( mrb, sizeof( class_raylib_rendertexture_data_t ) );
		if ( NULL == data ) {
			mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
		}
		//data->rendertexture = { 0 };
	} else {
		// if ( NULL != &( data->rendertexture ) ) {
		// 
		// }
	}
	RenderTexture rendertexture = { 0 };
	data->rendertexture = rendertexture;
	// if ( NULL == &( data->rendertexture ) ) {
	//	mrb_free( mrb, data );
	// }
	DATA_PTR( self ) = data;
	DATA_TYPE( self ) = &class_raylib_rendertexture_data_type;
	return self;
}

static mrb_value
class_raylib_rendertexture_get_id( mrb_state *mrb, mrb_value self ) {
	return mrb_fixnum_value( class_raylib_rendertexture_get_ptr( mrb, self )->id );
}
	
static mrb_value
class_raylib_rendertexture_set_id( mrb_state *mrb, mrb_value self ) {
	mrb_int param0;
	mrb_get_args( mrb, "i", &param0 );
	class_raylib_rendertexture_get_ptr( mrb, self )->id = param0;
	return self;
}
	
static mrb_value
class_raylib_rendertexture_get_texture( mrb_state *mrb, mrb_value self ) {
	return class_raylib_texture_2_mrbvalue( mrb, &class_raylib_rendertexture_get_ptr( mrb, self )->texture, 0 );
}
	
static mrb_value
class_raylib_rendertexture_set_texture( mrb_state *mrb, mrb_value self ) {
	mrb_value param0;
	mrb_get_args( mrb, "o", &param0 );
	class_raylib_rendertexture_get_ptr( mrb, self )->texture = *class_raylib_texture_get_ptr( mrb, param0 );
	return self;
}
	
static mrb_value
class_raylib_rendertexture_get_depth( mrb_state *mrb, mrb_value self ) {
	return class_raylib_texture_2_mrbvalue( mrb, &class_raylib_rendertexture_get_ptr( mrb, self )->depth, 0 );
}
	
static mrb_value
class_raylib_rendertexture_set_depth( mrb_state *mrb, mrb_value self ) {
	mrb_value param0;
	mrb_get_args( mrb, "o", &param0 );
	class_raylib_rendertexture_get_ptr( mrb, self )->depth = *class_raylib_texture_get_ptr( mrb, param0 );
	return self;
}
	
void
class_raylib_rendertexture_init( mrb_state *mrb, struct RClass *mod_RayLib ) {
	class_RenderTexture = mrb_define_class_under( mrb, mod_RayLib, "RenderTexture", mrb->object_class );

	MRB_SET_INSTANCE_TT( class_RenderTexture, MRB_TT_DATA );

	mrb_define_method( mrb, class_RenderTexture, "initialize", class_raylib_rendertexture_initialize, MRB_ARGS_NONE() );

	mrb_define_method( mrb, class_RenderTexture, "id", class_raylib_rendertexture_get_id, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_RenderTexture, "id=", class_raylib_rendertexture_set_id, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_RenderTexture, "texture", class_raylib_rendertexture_get_texture, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_RenderTexture, "texture=", class_raylib_rendertexture_set_texture, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_RenderTexture, "depth", class_raylib_rendertexture_get_depth, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_RenderTexture, "depth=", class_raylib_rendertexture_set_depth, MRB_ARGS_REQ( 1 ) );
}
//----------------------------------------------------------------//


//----------------------------------------------------------------//
// Raylib::NPatchInfo
static struct RClass *class_NPatchInfo;

typedef struct class_raylib_npatchinfo_data_t {
	bool is_associated;
	NPatchInfo npatchinfo;
} class_raylib_npatchinfo_data_t;
		
static void
class_raylib_npatchinfo_data_free( mrb_state *mrb, void *p ) {
	class_raylib_npatchinfo_data_t *data = ( class_raylib_npatchinfo_data_t* )p;
	if ( NULL != data ) {
		mrb_free( mrb, data );
	}
}

static struct mrb_data_type const class_raylib_npatchinfo_data_type = {
	"NPatchInfo", class_raylib_npatchinfo_data_free
};

mrb_value
class_raylib_npatchinfo_2_mrbvalue( mrb_state *mrb, NPatchInfo *npatchinfo, bool is_associated ) {
	class_raylib_npatchinfo_data_t *data = ( class_raylib_npatchinfo_data_t* )mrb_malloc( mrb, sizeof( class_raylib_npatchinfo_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	data->is_associated = is_associated;
	data->npatchinfo = *npatchinfo;
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_NPatchInfo, &class_raylib_npatchinfo_data_type, data ) );
}

mrb_value
class_raylib_npatchinfo_2_mrbvalue_direct( mrb_state *mrb, NPatchInfo const *npatchinfo ) {
	class_raylib_npatchinfo_data_t *data = ( class_raylib_npatchinfo_data_t* )mrb_malloc( mrb, sizeof( class_raylib_npatchinfo_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	if ( NULL == npatchinfo ) {
		// Do init
	} else {
		// Do Copy
		data->npatchinfo = *npatchinfo;
	}
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_NPatchInfo, &class_raylib_npatchinfo_data_type, data ) );
}

NPatchInfo*
class_raylib_npatchinfo_get_ptr( mrb_state *mrb, mrb_value npatchinfo ) {
	class_raylib_npatchinfo_data_t *data;
	if ( mrb_nil_p( npatchinfo ) ) {
		return NULL;
	}
	data = ( class_raylib_npatchinfo_data_t* )mrb_data_get_ptr( mrb, npatchinfo, &class_raylib_npatchinfo_data_type );
	return &data->npatchinfo;
}

static mrb_value
class_raylib_npatchinfo_initialize( mrb_state *mrb, mrb_value self ) {
	class_raylib_npatchinfo_data_t *data = DATA_PTR( self );

	if ( NULL == data ) {
		data = mrb_malloc( mrb, sizeof( class_raylib_npatchinfo_data_t ) );
		if ( NULL == data ) {
			mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
		}
		//data->npatchinfo = { 0 };
	} else {
		// if ( NULL != &( data->npatchinfo ) ) {
		// 
		// }
	}
	NPatchInfo npatchinfo = { 0 };
	data->npatchinfo = npatchinfo;
	// if ( NULL == &( data->npatchinfo ) ) {
	//	mrb_free( mrb, data );
	// }
	DATA_PTR( self ) = data;
	DATA_TYPE( self ) = &class_raylib_npatchinfo_data_type;
	return self;
}

static mrb_value
class_raylib_npatchinfo_get_source( mrb_state *mrb, mrb_value self ) {
	return class_raylib_rectangle_2_mrbvalue( mrb, &class_raylib_npatchinfo_get_ptr( mrb, self )->source, 0 );
}
	
static mrb_value
class_raylib_npatchinfo_set_source( mrb_state *mrb, mrb_value self ) {
	mrb_value param0;
	mrb_get_args( mrb, "o", &param0 );
	class_raylib_npatchinfo_get_ptr( mrb, self )->source = *class_raylib_rectangle_get_ptr( mrb, param0 );
	return self;
}
	
static mrb_value
class_raylib_npatchinfo_get_left( mrb_state *mrb, mrb_value self ) {
	return mrb_fixnum_value( class_raylib_npatchinfo_get_ptr( mrb, self )->left );
}
	
static mrb_value
class_raylib_npatchinfo_set_left( mrb_state *mrb, mrb_value self ) {
	mrb_int param0;
	mrb_get_args( mrb, "i", &param0 );
	class_raylib_npatchinfo_get_ptr( mrb, self )->left = param0;
	return self;
}
	
static mrb_value
class_raylib_npatchinfo_get_top( mrb_state *mrb, mrb_value self ) {
	return mrb_fixnum_value( class_raylib_npatchinfo_get_ptr( mrb, self )->top );
}
	
static mrb_value
class_raylib_npatchinfo_set_top( mrb_state *mrb, mrb_value self ) {
	mrb_int param0;
	mrb_get_args( mrb, "i", &param0 );
	class_raylib_npatchinfo_get_ptr( mrb, self )->top = param0;
	return self;
}
	
static mrb_value
class_raylib_npatchinfo_get_right( mrb_state *mrb, mrb_value self ) {
	return mrb_fixnum_value( class_raylib_npatchinfo_get_ptr( mrb, self )->right );
}
	
static mrb_value
class_raylib_npatchinfo_set_right( mrb_state *mrb, mrb_value self ) {
	mrb_int param0;
	mrb_get_args( mrb, "i", &param0 );
	class_raylib_npatchinfo_get_ptr( mrb, self )->right = param0;
	return self;
}
	
static mrb_value
class_raylib_npatchinfo_get_bottom( mrb_state *mrb, mrb_value self ) {
	return mrb_fixnum_value( class_raylib_npatchinfo_get_ptr( mrb, self )->bottom );
}
	
static mrb_value
class_raylib_npatchinfo_set_bottom( mrb_state *mrb, mrb_value self ) {
	mrb_int param0;
	mrb_get_args( mrb, "i", &param0 );
	class_raylib_npatchinfo_get_ptr( mrb, self )->bottom = param0;
	return self;
}
	
static mrb_value
class_raylib_npatchinfo_get_layout( mrb_state *mrb, mrb_value self ) {
	return mrb_fixnum_value( class_raylib_npatchinfo_get_ptr( mrb, self )->layout );
}
	
static mrb_value
class_raylib_npatchinfo_set_layout( mrb_state *mrb, mrb_value self ) {
	mrb_int param0;
	mrb_get_args( mrb, "i", &param0 );
	class_raylib_npatchinfo_get_ptr( mrb, self )->layout = param0;
	return self;
}
	
void
class_raylib_npatchinfo_init( mrb_state *mrb, struct RClass *mod_RayLib ) {
	class_NPatchInfo = mrb_define_class_under( mrb, mod_RayLib, "NPatchInfo", mrb->object_class );

	MRB_SET_INSTANCE_TT( class_NPatchInfo, MRB_TT_DATA );

	mrb_define_method( mrb, class_NPatchInfo, "initialize", class_raylib_npatchinfo_initialize, MRB_ARGS_NONE() );

	mrb_define_method( mrb, class_NPatchInfo, "source", class_raylib_npatchinfo_get_source, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_NPatchInfo, "source=", class_raylib_npatchinfo_set_source, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_NPatchInfo, "left", class_raylib_npatchinfo_get_left, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_NPatchInfo, "left=", class_raylib_npatchinfo_set_left, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_NPatchInfo, "top", class_raylib_npatchinfo_get_top, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_NPatchInfo, "top=", class_raylib_npatchinfo_set_top, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_NPatchInfo, "right", class_raylib_npatchinfo_get_right, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_NPatchInfo, "right=", class_raylib_npatchinfo_set_right, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_NPatchInfo, "bottom", class_raylib_npatchinfo_get_bottom, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_NPatchInfo, "bottom=", class_raylib_npatchinfo_set_bottom, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_NPatchInfo, "layout", class_raylib_npatchinfo_get_layout, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_NPatchInfo, "layout=", class_raylib_npatchinfo_set_layout, MRB_ARGS_REQ( 1 ) );
}
//----------------------------------------------------------------//


//----------------------------------------------------------------//
// Raylib::GlyphInfo
static struct RClass *class_GlyphInfo;

typedef struct class_raylib_glyphinfo_data_t {
	bool is_associated;
	GlyphInfo glyphinfo;
} class_raylib_glyphinfo_data_t;
		
static void
class_raylib_glyphinfo_data_free( mrb_state *mrb, void *p ) {
	class_raylib_glyphinfo_data_t *data = ( class_raylib_glyphinfo_data_t* )p;
	if ( NULL != data ) {
		mrb_free( mrb, data );
	}
}

static struct mrb_data_type const class_raylib_glyphinfo_data_type = {
	"GlyphInfo", class_raylib_glyphinfo_data_free
};

mrb_value
class_raylib_glyphinfo_2_mrbvalue( mrb_state *mrb, GlyphInfo *glyphinfo, bool is_associated ) {
	class_raylib_glyphinfo_data_t *data = ( class_raylib_glyphinfo_data_t* )mrb_malloc( mrb, sizeof( class_raylib_glyphinfo_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	data->is_associated = is_associated;
	data->glyphinfo = *glyphinfo;
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_GlyphInfo, &class_raylib_glyphinfo_data_type, data ) );
}

mrb_value
class_raylib_glyphinfo_2_mrbvalue_direct( mrb_state *mrb, GlyphInfo const *glyphinfo ) {
	class_raylib_glyphinfo_data_t *data = ( class_raylib_glyphinfo_data_t* )mrb_malloc( mrb, sizeof( class_raylib_glyphinfo_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	if ( NULL == glyphinfo ) {
		// Do init
	} else {
		// Do Copy
		data->glyphinfo = *glyphinfo;
	}
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_GlyphInfo, &class_raylib_glyphinfo_data_type, data ) );
}

GlyphInfo*
class_raylib_glyphinfo_get_ptr( mrb_state *mrb, mrb_value glyphinfo ) {
	class_raylib_glyphinfo_data_t *data;
	if ( mrb_nil_p( glyphinfo ) ) {
		return NULL;
	}
	data = ( class_raylib_glyphinfo_data_t* )mrb_data_get_ptr( mrb, glyphinfo, &class_raylib_glyphinfo_data_type );
	return &data->glyphinfo;
}

static mrb_value
class_raylib_glyphinfo_initialize( mrb_state *mrb, mrb_value self ) {
	class_raylib_glyphinfo_data_t *data = DATA_PTR( self );

	if ( NULL == data ) {
		data = mrb_malloc( mrb, sizeof( class_raylib_glyphinfo_data_t ) );
		if ( NULL == data ) {
			mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
		}
		//data->glyphinfo = { 0 };
	} else {
		// if ( NULL != &( data->glyphinfo ) ) {
		// 
		// }
	}
	GlyphInfo glyphinfo = { 0 };
	data->glyphinfo = glyphinfo;
	// if ( NULL == &( data->glyphinfo ) ) {
	//	mrb_free( mrb, data );
	// }
	DATA_PTR( self ) = data;
	DATA_TYPE( self ) = &class_raylib_glyphinfo_data_type;
	return self;
}

static mrb_value
class_raylib_glyphinfo_get_value( mrb_state *mrb, mrb_value self ) {
	return mrb_fixnum_value( class_raylib_glyphinfo_get_ptr( mrb, self )->value );
}
	
static mrb_value
class_raylib_glyphinfo_set_value( mrb_state *mrb, mrb_value self ) {
	mrb_int param0;
	mrb_get_args( mrb, "i", &param0 );
	class_raylib_glyphinfo_get_ptr( mrb, self )->value = param0;
	return self;
}
	
static mrb_value
class_raylib_glyphinfo_get_offsetX( mrb_state *mrb, mrb_value self ) {
	return mrb_fixnum_value( class_raylib_glyphinfo_get_ptr( mrb, self )->offsetX );
}
	
static mrb_value
class_raylib_glyphinfo_set_offsetX( mrb_state *mrb, mrb_value self ) {
	mrb_int param0;
	mrb_get_args( mrb, "i", &param0 );
	class_raylib_glyphinfo_get_ptr( mrb, self )->offsetX = param0;
	return self;
}
	
static mrb_value
class_raylib_glyphinfo_get_offsetY( mrb_state *mrb, mrb_value self ) {
	return mrb_fixnum_value( class_raylib_glyphinfo_get_ptr( mrb, self )->offsetY );
}
	
static mrb_value
class_raylib_glyphinfo_set_offsetY( mrb_state *mrb, mrb_value self ) {
	mrb_int param0;
	mrb_get_args( mrb, "i", &param0 );
	class_raylib_glyphinfo_get_ptr( mrb, self )->offsetY = param0;
	return self;
}
	
static mrb_value
class_raylib_glyphinfo_get_advanceX( mrb_state *mrb, mrb_value self ) {
	return mrb_fixnum_value( class_raylib_glyphinfo_get_ptr( mrb, self )->advanceX );
}
	
static mrb_value
class_raylib_glyphinfo_set_advanceX( mrb_state *mrb, mrb_value self ) {
	mrb_int param0;
	mrb_get_args( mrb, "i", &param0 );
	class_raylib_glyphinfo_get_ptr( mrb, self )->advanceX = param0;
	return self;
}
	
static mrb_value
class_raylib_glyphinfo_get_image( mrb_state *mrb, mrb_value self ) {
	return class_raylib_image_2_mrbvalue( mrb, &class_raylib_glyphinfo_get_ptr( mrb, self )->image, 0 );
}
	
static mrb_value
class_raylib_glyphinfo_set_image( mrb_state *mrb, mrb_value self ) {
	mrb_value param0;
	mrb_get_args( mrb, "o", &param0 );
	class_raylib_glyphinfo_get_ptr( mrb, self )->image = *class_raylib_image_get_ptr( mrb, param0 );
	return self;
}
	
void
class_raylib_glyphinfo_init( mrb_state *mrb, struct RClass *mod_RayLib ) {
	class_GlyphInfo = mrb_define_class_under( mrb, mod_RayLib, "GlyphInfo", mrb->object_class );

	MRB_SET_INSTANCE_TT( class_GlyphInfo, MRB_TT_DATA );

	mrb_define_method( mrb, class_GlyphInfo, "initialize", class_raylib_glyphinfo_initialize, MRB_ARGS_NONE() );

	mrb_define_method( mrb, class_GlyphInfo, "value", class_raylib_glyphinfo_get_value, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_GlyphInfo, "value=", class_raylib_glyphinfo_set_value, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_GlyphInfo, "offset_x", class_raylib_glyphinfo_get_offsetX, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_GlyphInfo, "offset_x=", class_raylib_glyphinfo_set_offsetX, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_GlyphInfo, "offset_y", class_raylib_glyphinfo_get_offsetY, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_GlyphInfo, "offset_y=", class_raylib_glyphinfo_set_offsetY, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_GlyphInfo, "advance_x", class_raylib_glyphinfo_get_advanceX, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_GlyphInfo, "advance_x=", class_raylib_glyphinfo_set_advanceX, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_GlyphInfo, "image", class_raylib_glyphinfo_get_image, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_GlyphInfo, "image=", class_raylib_glyphinfo_set_image, MRB_ARGS_REQ( 1 ) );
}
//----------------------------------------------------------------//


//----------------------------------------------------------------//
// Raylib::Font
static struct RClass *class_Font;

typedef struct class_raylib_font_data_t {
	bool is_associated;
	Font font;
} class_raylib_font_data_t;
		
static void
class_raylib_font_data_free( mrb_state *mrb, void *p ) {
	class_raylib_font_data_t *data = ( class_raylib_font_data_t* )p;
	if ( NULL != data ) {
		mrb_free( mrb, data );
	}
}

static struct mrb_data_type const class_raylib_font_data_type = {
	"Font", class_raylib_font_data_free
};

mrb_value
class_raylib_font_2_mrbvalue( mrb_state *mrb, Font *font, bool is_associated ) {
	class_raylib_font_data_t *data = ( class_raylib_font_data_t* )mrb_malloc( mrb, sizeof( class_raylib_font_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	data->is_associated = is_associated;
	data->font = *font;
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_Font, &class_raylib_font_data_type, data ) );
}

mrb_value
class_raylib_font_2_mrbvalue_direct( mrb_state *mrb, Font const *font ) {
	class_raylib_font_data_t *data = ( class_raylib_font_data_t* )mrb_malloc( mrb, sizeof( class_raylib_font_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	if ( NULL == font ) {
		// Do init
	} else {
		// Do Copy
		data->font = *font;
	}
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_Font, &class_raylib_font_data_type, data ) );
}

Font*
class_raylib_font_get_ptr( mrb_state *mrb, mrb_value font ) {
	class_raylib_font_data_t *data;
	if ( mrb_nil_p( font ) ) {
		return NULL;
	}
	data = ( class_raylib_font_data_t* )mrb_data_get_ptr( mrb, font, &class_raylib_font_data_type );
	return &data->font;
}

static mrb_value
class_raylib_font_initialize( mrb_state *mrb, mrb_value self ) {
	class_raylib_font_data_t *data = DATA_PTR( self );

	if ( NULL == data ) {
		data = mrb_malloc( mrb, sizeof( class_raylib_font_data_t ) );
		if ( NULL == data ) {
			mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
		}
		//data->font = { 0 };
	} else {
		// if ( NULL != &( data->font ) ) {
		// 
		// }
	}
	Font font = { 0 };
	data->font = font;
	// if ( NULL == &( data->font ) ) {
	//	mrb_free( mrb, data );
	// }
	DATA_PTR( self ) = data;
	DATA_TYPE( self ) = &class_raylib_font_data_type;
	return self;
}

static mrb_value
class_raylib_font_get_baseSize( mrb_state *mrb, mrb_value self ) {
	return mrb_fixnum_value( class_raylib_font_get_ptr( mrb, self )->baseSize );
}
	
static mrb_value
class_raylib_font_set_baseSize( mrb_state *mrb, mrb_value self ) {
	mrb_int param0;
	mrb_get_args( mrb, "i", &param0 );
	class_raylib_font_get_ptr( mrb, self )->baseSize = param0;
	return self;
}
	
static mrb_value
class_raylib_font_get_glyphCount( mrb_state *mrb, mrb_value self ) {
	return mrb_fixnum_value( class_raylib_font_get_ptr( mrb, self )->glyphCount );
}
	
static mrb_value
class_raylib_font_set_glyphCount( mrb_state *mrb, mrb_value self ) {
	mrb_int param0;
	mrb_get_args( mrb, "i", &param0 );
	class_raylib_font_get_ptr( mrb, self )->glyphCount = param0;
	return self;
}
	
static mrb_value
class_raylib_font_get_glyphPadding( mrb_state *mrb, mrb_value self ) {
	return mrb_fixnum_value( class_raylib_font_get_ptr( mrb, self )->glyphPadding );
}
	
static mrb_value
class_raylib_font_set_glyphPadding( mrb_state *mrb, mrb_value self ) {
	mrb_int param0;
	mrb_get_args( mrb, "i", &param0 );
	class_raylib_font_get_ptr( mrb, self )->glyphPadding = param0;
	return self;
}
	
static mrb_value
class_raylib_font_get_texture( mrb_state *mrb, mrb_value self ) {
	return class_raylib_texture_2_mrbvalue( mrb, &class_raylib_font_get_ptr( mrb, self )->texture, 0 );
}
	
static mrb_value
class_raylib_font_set_texture( mrb_state *mrb, mrb_value self ) {
	mrb_value param0;
	mrb_get_args( mrb, "d", &param0 );
	class_raylib_font_get_ptr( mrb, self )->texture = *class_raylib_texture_get_ptr( mrb, param0 );
	return self;
}
	
static mrb_value
class_raylib_font_get_recs( mrb_state *mrb, mrb_value self ) {
	return class_raylib_rectangle_2_mrbvalue( mrb, class_raylib_font_get_ptr( mrb, self )->recs, 0 );
}
	
static mrb_value
class_raylib_font_set_recs( mrb_state *mrb, mrb_value self ) {
	mrb_value param0;
	mrb_get_args( mrb, "!d", &param0 );
	class_raylib_font_get_ptr( mrb, self )->recs = class_raylib_rectangle_get_ptr( mrb, param0 );
	return self;
}
	
static mrb_value
class_raylib_font_get_glyphs( mrb_state *mrb, mrb_value self ) {
	return class_raylib_glyphinfo_2_mrbvalue( mrb, class_raylib_font_get_ptr( mrb, self )->glyphs, 0 );
}
	
static mrb_value
class_raylib_font_set_glyphs( mrb_state *mrb, mrb_value self ) {
	mrb_value param0;
	mrb_get_args( mrb, "!d", &param0 );
	class_raylib_font_get_ptr( mrb, self )->glyphs = class_raylib_glyphinfo_get_ptr( mrb, param0 );
	return self;
}
	
void
class_raylib_font_init( mrb_state *mrb, struct RClass *mod_RayLib ) {
	class_Font = mrb_define_class_under( mrb, mod_RayLib, "Font", mrb->object_class );

	MRB_SET_INSTANCE_TT( class_Font, MRB_TT_DATA );

	mrb_define_method( mrb, class_Font, "initialize", class_raylib_font_initialize, MRB_ARGS_NONE() );

	mrb_define_method( mrb, class_Font, "base_size", class_raylib_font_get_baseSize, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Font, "base_size=", class_raylib_font_set_baseSize, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Font, "glyph_count", class_raylib_font_get_glyphCount, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Font, "glyph_count=", class_raylib_font_set_glyphCount, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Font, "glyph_padding", class_raylib_font_get_glyphPadding, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Font, "glyph_padding=", class_raylib_font_set_glyphPadding, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Font, "texture", class_raylib_font_get_texture, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Font, "texture=", class_raylib_font_set_texture, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Font, "recs", class_raylib_font_get_recs, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Font, "recs=", class_raylib_font_set_recs, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Font, "glyphs", class_raylib_font_get_glyphs, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Font, "glyphs=", class_raylib_font_set_glyphs, MRB_ARGS_REQ( 1 ) );
}
//----------------------------------------------------------------//


//----------------------------------------------------------------//
// Raylib::Camera3D
static struct RClass *class_Camera3D;

typedef struct class_raylib_camera3d_data_t {
	bool is_associated;
	Camera3D camera3d;
} class_raylib_camera3d_data_t;
		
static void
class_raylib_camera3d_data_free( mrb_state *mrb, void *p ) {
	class_raylib_camera3d_data_t *data = ( class_raylib_camera3d_data_t* )p;
	if ( NULL != data ) {
		mrb_free( mrb, data );
	}
}

static struct mrb_data_type const class_raylib_camera3d_data_type = {
	"Camera3D", class_raylib_camera3d_data_free
};

mrb_value
class_raylib_camera3d_2_mrbvalue( mrb_state *mrb, Camera3D *camera3d, bool is_associated ) {
	class_raylib_camera3d_data_t *data = ( class_raylib_camera3d_data_t* )mrb_malloc( mrb, sizeof( class_raylib_camera3d_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	data->is_associated = is_associated;
	data->camera3d = *camera3d;
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_Camera3D, &class_raylib_camera3d_data_type, data ) );
}

mrb_value
class_raylib_camera3d_2_mrbvalue_direct( mrb_state *mrb, Camera3D const *camera3d ) {
	class_raylib_camera3d_data_t *data = ( class_raylib_camera3d_data_t* )mrb_malloc( mrb, sizeof( class_raylib_camera3d_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	if ( NULL == camera3d ) {
		// Do init
	} else {
		// Do Copy
		data->camera3d = *camera3d;
	}
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_Camera3D, &class_raylib_camera3d_data_type, data ) );
}

Camera3D*
class_raylib_camera3d_get_ptr( mrb_state *mrb, mrb_value camera3d ) {
	class_raylib_camera3d_data_t *data;
	if ( mrb_nil_p( camera3d ) ) {
		return NULL;
	}
	data = ( class_raylib_camera3d_data_t* )mrb_data_get_ptr( mrb, camera3d, &class_raylib_camera3d_data_type );
	return &data->camera3d;
}

static mrb_value
class_raylib_camera3d_initialize( mrb_state *mrb, mrb_value self ) {
	class_raylib_camera3d_data_t *data = DATA_PTR( self );

	if ( NULL == data ) {
		data = mrb_malloc( mrb, sizeof( class_raylib_camera3d_data_t ) );
		if ( NULL == data ) {
			mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
		}
		//data->camera3d = { 0 };
	} else {
		// if ( NULL != &( data->camera3d ) ) {
		// 
		// }
	}
	Camera3D camera3d = { 0 };
	data->camera3d = camera3d;
	// if ( NULL == &( data->camera3d ) ) {
	//	mrb_free( mrb, data );
	// }
	DATA_PTR( self ) = data;
	DATA_TYPE( self ) = &class_raylib_camera3d_data_type;
	return self;
}

static mrb_value
class_raylib_camera3d_get_position( mrb_state *mrb, mrb_value self ) {
	return class_raylib_vector3_2_mrbvalue( mrb, &class_raylib_camera3d_get_ptr( mrb, self )->position, 0 );
}
	
static mrb_value
class_raylib_camera3d_set_position( mrb_state *mrb, mrb_value self ) {
	mrb_value param0;
	mrb_get_args( mrb, "o", &param0 );
	class_raylib_camera3d_get_ptr( mrb, self )->position = *class_raylib_vector3_get_ptr( mrb, param0 );
	return self;
}
	
static mrb_value
class_raylib_camera3d_get_target( mrb_state *mrb, mrb_value self ) {
	return class_raylib_vector3_2_mrbvalue( mrb, &class_raylib_camera3d_get_ptr( mrb, self )->target, 0 );
}
	
static mrb_value
class_raylib_camera3d_set_target( mrb_state *mrb, mrb_value self ) {
	mrb_value param0;
	mrb_get_args( mrb, "o", &param0 );
	class_raylib_camera3d_get_ptr( mrb, self )->target = *class_raylib_vector3_get_ptr( mrb, param0 );
	return self;
}
	
static mrb_value
class_raylib_camera3d_get_up( mrb_state *mrb, mrb_value self ) {
	return class_raylib_vector3_2_mrbvalue( mrb, &class_raylib_camera3d_get_ptr( mrb, self )->up, 0 );
}
	
static mrb_value
class_raylib_camera3d_set_up( mrb_state *mrb, mrb_value self ) {
	mrb_value param0;
	mrb_get_args( mrb, "o", &param0 );
	class_raylib_camera3d_get_ptr( mrb, self )->up = *class_raylib_vector3_get_ptr( mrb, param0 );
	return self;
}
	
static mrb_value
class_raylib_camera3d_get_fovy( mrb_state *mrb, mrb_value self ) {
	return mrb_float_value( mrb, class_raylib_camera3d_get_ptr( mrb, self )->fovy );
}
	
static mrb_value
class_raylib_camera3d_set_fovy( mrb_state *mrb, mrb_value self ) {
	mrb_float param0;
	mrb_get_args( mrb, "f", &param0 );
	class_raylib_camera3d_get_ptr( mrb, self )->fovy = param0;
	return self;
}
	
static mrb_value
class_raylib_camera3d_get_projection( mrb_state *mrb, mrb_value self ) {
	return mrb_fixnum_value( class_raylib_camera3d_get_ptr( mrb, self )->projection );
}
	
static mrb_value
class_raylib_camera3d_set_projection( mrb_state *mrb, mrb_value self ) {
	mrb_int param0;
	mrb_get_args( mrb, "i", &param0 );
	class_raylib_camera3d_get_ptr( mrb, self )->projection = param0;
	return self;
}
	
void
class_raylib_camera3d_init( mrb_state *mrb, struct RClass *mod_RayLib ) {
	class_Camera3D = mrb_define_class_under( mrb, mod_RayLib, "Camera3D", mrb->object_class );

	MRB_SET_INSTANCE_TT( class_Camera3D, MRB_TT_DATA );

	mrb_define_method( mrb, class_Camera3D, "initialize", class_raylib_camera3d_initialize, MRB_ARGS_NONE() );

	mrb_define_method( mrb, class_Camera3D, "position", class_raylib_camera3d_get_position, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Camera3D, "position=", class_raylib_camera3d_set_position, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Camera3D, "target", class_raylib_camera3d_get_target, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Camera3D, "target=", class_raylib_camera3d_set_target, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Camera3D, "up", class_raylib_camera3d_get_up, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Camera3D, "up=", class_raylib_camera3d_set_up, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Camera3D, "fovy", class_raylib_camera3d_get_fovy, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Camera3D, "fovy=", class_raylib_camera3d_set_fovy, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Camera3D, "projection", class_raylib_camera3d_get_projection, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Camera3D, "projection=", class_raylib_camera3d_set_projection, MRB_ARGS_REQ( 1 ) );
}
//----------------------------------------------------------------//


//----------------------------------------------------------------//
// Raylib::Camera2D
static struct RClass *class_Camera2D;

typedef struct class_raylib_camera2d_data_t {
	bool is_associated;
	Camera2D camera2d;
} class_raylib_camera2d_data_t;
		
static void
class_raylib_camera2d_data_free( mrb_state *mrb, void *p ) {
	class_raylib_camera2d_data_t *data = ( class_raylib_camera2d_data_t* )p;
	if ( NULL != data ) {
		mrb_free( mrb, data );
	}
}

static struct mrb_data_type const class_raylib_camera2d_data_type = {
	"Camera2D", class_raylib_camera2d_data_free
};

mrb_value
class_raylib_camera2d_2_mrbvalue( mrb_state *mrb, Camera2D *camera2d, bool is_associated ) {
	class_raylib_camera2d_data_t *data = ( class_raylib_camera2d_data_t* )mrb_malloc( mrb, sizeof( class_raylib_camera2d_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	data->is_associated = is_associated;
	data->camera2d = *camera2d;
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_Camera2D, &class_raylib_camera2d_data_type, data ) );
}

mrb_value
class_raylib_camera2d_2_mrbvalue_direct( mrb_state *mrb, Camera2D const *camera2d ) {
	class_raylib_camera2d_data_t *data = ( class_raylib_camera2d_data_t* )mrb_malloc( mrb, sizeof( class_raylib_camera2d_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	if ( NULL == camera2d ) {
		// Do init
	} else {
		// Do Copy
		data->camera2d = *camera2d;
	}
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_Camera2D, &class_raylib_camera2d_data_type, data ) );
}

Camera2D*
class_raylib_camera2d_get_ptr( mrb_state *mrb, mrb_value camera2d ) {
	class_raylib_camera2d_data_t *data;
	if ( mrb_nil_p( camera2d ) ) {
		return NULL;
	}
	data = ( class_raylib_camera2d_data_t* )mrb_data_get_ptr( mrb, camera2d, &class_raylib_camera2d_data_type );
	return &data->camera2d;
}

static mrb_value
class_raylib_camera2d_initialize( mrb_state *mrb, mrb_value self ) {
	class_raylib_camera2d_data_t *data = DATA_PTR( self );

	if ( NULL == data ) {
		data = mrb_malloc( mrb, sizeof( class_raylib_camera2d_data_t ) );
		if ( NULL == data ) {
			mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
		}
		//data->camera2d = { 0 };
	} else {
		// if ( NULL != &( data->camera2d ) ) {
		// 
		// }
	}
	Camera2D camera2d = { 0 };
	data->camera2d = camera2d;
	// if ( NULL == &( data->camera2d ) ) {
	//	mrb_free( mrb, data );
	// }
	DATA_PTR( self ) = data;
	DATA_TYPE( self ) = &class_raylib_camera2d_data_type;
	return self;
}

static mrb_value
class_raylib_camera2d_get_offset( mrb_state *mrb, mrb_value self ) {
	return class_raylib_vector2_2_mrbvalue( mrb, &class_raylib_camera2d_get_ptr( mrb, self )->offset, 0 );
}
	
static mrb_value
class_raylib_camera2d_set_offset( mrb_state *mrb, mrb_value self ) {
	mrb_value param0;
	mrb_get_args( mrb, "o", &param0 );
	class_raylib_camera2d_get_ptr( mrb, self )->offset = *class_raylib_vector2_get_ptr( mrb, param0 );
	return self;
}
	
static mrb_value
class_raylib_camera2d_get_target( mrb_state *mrb, mrb_value self ) {
	return class_raylib_vector2_2_mrbvalue( mrb, &class_raylib_camera2d_get_ptr( mrb, self )->target, 0 );
}
	
static mrb_value
class_raylib_camera2d_set_target( mrb_state *mrb, mrb_value self ) {
	mrb_value param0;
	mrb_get_args( mrb, "o", &param0 );
	class_raylib_camera2d_get_ptr( mrb, self )->target = *class_raylib_vector2_get_ptr( mrb, param0 );
	return self;
}
	
static mrb_value
class_raylib_camera2d_get_rotation( mrb_state *mrb, mrb_value self ) {
	return mrb_float_value( mrb, class_raylib_camera2d_get_ptr( mrb, self )->rotation );
}
	
static mrb_value
class_raylib_camera2d_set_rotation( mrb_state *mrb, mrb_value self ) {
	mrb_float param0;
	mrb_get_args( mrb, "f", &param0 );
	class_raylib_camera2d_get_ptr( mrb, self )->rotation = param0;
	return self;
}
	
static mrb_value
class_raylib_camera2d_get_zoom( mrb_state *mrb, mrb_value self ) {
	return mrb_float_value( mrb, class_raylib_camera2d_get_ptr( mrb, self )->zoom );
}
	
static mrb_value
class_raylib_camera2d_set_zoom( mrb_state *mrb, mrb_value self ) {
	mrb_float param0;
	mrb_get_args( mrb, "f", &param0 );
	class_raylib_camera2d_get_ptr( mrb, self )->zoom = param0;
	return self;
}
	
void
class_raylib_camera2d_init( mrb_state *mrb, struct RClass *mod_RayLib ) {
	class_Camera2D = mrb_define_class_under( mrb, mod_RayLib, "Camera2D", mrb->object_class );

	MRB_SET_INSTANCE_TT( class_Camera2D, MRB_TT_DATA );

	mrb_define_method( mrb, class_Camera2D, "initialize", class_raylib_camera2d_initialize, MRB_ARGS_NONE() );

	mrb_define_method( mrb, class_Camera2D, "offset", class_raylib_camera2d_get_offset, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Camera2D, "offset=", class_raylib_camera2d_set_offset, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Camera2D, "target", class_raylib_camera2d_get_target, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Camera2D, "target=", class_raylib_camera2d_set_target, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Camera2D, "rotation", class_raylib_camera2d_get_rotation, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Camera2D, "rotation=", class_raylib_camera2d_set_rotation, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Camera2D, "zoom", class_raylib_camera2d_get_zoom, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Camera2D, "zoom=", class_raylib_camera2d_set_zoom, MRB_ARGS_REQ( 1 ) );
}
//----------------------------------------------------------------//


//----------------------------------------------------------------//
// Raylib::Mesh
static struct RClass *class_Mesh;

typedef struct class_raylib_mesh_data_t {
	bool is_associated;
	Mesh mesh;
} class_raylib_mesh_data_t;
		
static void
class_raylib_mesh_data_free( mrb_state *mrb, void *p ) {
	class_raylib_mesh_data_t *data = ( class_raylib_mesh_data_t* )p;
	if ( NULL != data ) {
		mrb_free( mrb, data );
	}
}

static struct mrb_data_type const class_raylib_mesh_data_type = {
	"Mesh", class_raylib_mesh_data_free
};

mrb_value
class_raylib_mesh_2_mrbvalue( mrb_state *mrb, Mesh *mesh, bool is_associated ) {
	class_raylib_mesh_data_t *data = ( class_raylib_mesh_data_t* )mrb_malloc( mrb, sizeof( class_raylib_mesh_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	data->is_associated = is_associated;
	data->mesh = *mesh;
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_Mesh, &class_raylib_mesh_data_type, data ) );
}

mrb_value
class_raylib_mesh_2_mrbvalue_direct( mrb_state *mrb, Mesh const *mesh ) {
	class_raylib_mesh_data_t *data = ( class_raylib_mesh_data_t* )mrb_malloc( mrb, sizeof( class_raylib_mesh_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	if ( NULL == mesh ) {
		// Do init
	} else {
		// Do Copy
		data->mesh = *mesh;
	}
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_Mesh, &class_raylib_mesh_data_type, data ) );
}

Mesh*
class_raylib_mesh_get_ptr( mrb_state *mrb, mrb_value mesh ) {
	class_raylib_mesh_data_t *data;
	if ( mrb_nil_p( mesh ) ) {
		return NULL;
	}
	data = ( class_raylib_mesh_data_t* )mrb_data_get_ptr( mrb, mesh, &class_raylib_mesh_data_type );
	return &data->mesh;
}

static mrb_value
class_raylib_mesh_initialize( mrb_state *mrb, mrb_value self ) {
	class_raylib_mesh_data_t *data = DATA_PTR( self );

	if ( NULL == data ) {
		data = mrb_malloc( mrb, sizeof( class_raylib_mesh_data_t ) );
		if ( NULL == data ) {
			mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
		}
		//data->mesh = { 0 };
	} else {
		// if ( NULL != &( data->mesh ) ) {
		// 
		// }
	}
	Mesh mesh = { 0 };
	data->mesh = mesh;
	// if ( NULL == &( data->mesh ) ) {
	//	mrb_free( mrb, data );
	// }
	DATA_PTR( self ) = data;
	DATA_TYPE( self ) = &class_raylib_mesh_data_type;
	return self;
}

static mrb_value
class_raylib_mesh_get_vertexCount( mrb_state *mrb, mrb_value self ) {
	return mrb_fixnum_value( class_raylib_mesh_get_ptr( mrb, self )->vertexCount );
}
	
static mrb_value
class_raylib_mesh_set_vertexCount( mrb_state *mrb, mrb_value self ) {
	mrb_int param0;
	mrb_get_args( mrb, "i", &param0 );
	class_raylib_mesh_get_ptr( mrb, self )->vertexCount = param0;
	return self;
}
	
static mrb_value
class_raylib_mesh_get_triangleCount( mrb_state *mrb, mrb_value self ) {
	return mrb_fixnum_value( class_raylib_mesh_get_ptr( mrb, self )->triangleCount );
}
	
static mrb_value
class_raylib_mesh_set_triangleCount( mrb_state *mrb, mrb_value self ) {
	mrb_int param0;
	mrb_get_args( mrb, "i", &param0 );
	class_raylib_mesh_get_ptr( mrb, self )->triangleCount = param0;
	return self;
}
	
static mrb_value
class_raylib_mesh_get_vertices( mrb_state *mrb, mrb_value self ) {
	return mrb_cptr_value( mrb, ( void* )( class_raylib_mesh_get_ptr( mrb, self )->vertices ) );
}
	
static mrb_value
class_raylib_mesh_set_vertices( mrb_state *mrb, mrb_value self ) {
	mrb_value param0;
	mrb_get_args( mrb, "*", &param0 );
	class_raylib_mesh_get_ptr( mrb, self )->vertices = mrb_cptr( param0 );
	return self;
}
	
static mrb_value
class_raylib_mesh_get_texcoords( mrb_state *mrb, mrb_value self ) {
	return mrb_cptr_value( mrb, ( void* )( class_raylib_mesh_get_ptr( mrb, self )->texcoords ) );
}
	
static mrb_value
class_raylib_mesh_set_texcoords( mrb_state *mrb, mrb_value self ) {
	mrb_value param0;
	mrb_get_args( mrb, "*", &param0 );
	class_raylib_mesh_get_ptr( mrb, self )->texcoords = mrb_cptr( param0 );
	return self;
}
	
static mrb_value
class_raylib_mesh_get_texcoords2( mrb_state *mrb, mrb_value self ) {
	return mrb_cptr_value( mrb, ( void* )( class_raylib_mesh_get_ptr( mrb, self )->texcoords2 ) );
}
	
static mrb_value
class_raylib_mesh_set_texcoords2( mrb_state *mrb, mrb_value self ) {
	mrb_value param0;
	mrb_get_args( mrb, "*", &param0 );
	class_raylib_mesh_get_ptr( mrb, self )->texcoords2 = mrb_cptr( param0 );
	return self;
}
	
static mrb_value
class_raylib_mesh_get_normals( mrb_state *mrb, mrb_value self ) {
	return mrb_cptr_value( mrb, ( void* )( class_raylib_mesh_get_ptr( mrb, self )->normals ) );
}
	
static mrb_value
class_raylib_mesh_set_normals( mrb_state *mrb, mrb_value self ) {
	mrb_value param0;
	mrb_get_args( mrb, "*", &param0 );
	class_raylib_mesh_get_ptr( mrb, self )->normals = mrb_cptr( param0 );
	return self;
}
	
static mrb_value
class_raylib_mesh_get_tangents( mrb_state *mrb, mrb_value self ) {
	return mrb_cptr_value( mrb, ( void* )( class_raylib_mesh_get_ptr( mrb, self )->tangents ) );
}
	
static mrb_value
class_raylib_mesh_set_tangents( mrb_state *mrb, mrb_value self ) {
	mrb_value param0;
	mrb_get_args( mrb, "*", &param0 );
	class_raylib_mesh_get_ptr( mrb, self )->tangents = mrb_cptr( param0 );
	return self;
}
	
static mrb_value
class_raylib_mesh_get_colors( mrb_state *mrb, mrb_value self ) {
	return mrb_cptr_value( mrb, ( void* )( class_raylib_mesh_get_ptr( mrb, self )->colors ) );
}
	
static mrb_value
class_raylib_mesh_set_colors( mrb_state *mrb, mrb_value self ) {
	mrb_value param0;
	mrb_get_args( mrb, "*", &param0 );
	class_raylib_mesh_get_ptr( mrb, self )->colors = mrb_cptr( param0 );
	return self;
}
	
static mrb_value
class_raylib_mesh_get_indices( mrb_state *mrb, mrb_value self ) {
	return mrb_cptr_value( mrb, ( void* )( class_raylib_mesh_get_ptr( mrb, self )->indices ) );
}
	
static mrb_value
class_raylib_mesh_set_indices( mrb_state *mrb, mrb_value self ) {
	mrb_value param0;
	mrb_get_args( mrb, "*", &param0 );
	class_raylib_mesh_get_ptr( mrb, self )->indices = mrb_cptr( param0 );
	return self;
}
	
static mrb_value
class_raylib_mesh_get_animVertices( mrb_state *mrb, mrb_value self ) {
	return mrb_cptr_value( mrb, ( void* )( class_raylib_mesh_get_ptr( mrb, self )->animVertices ) );
}
	
static mrb_value
class_raylib_mesh_set_animVertices( mrb_state *mrb, mrb_value self ) {
	mrb_value param0;
	mrb_get_args( mrb, "*", &param0 );
	class_raylib_mesh_get_ptr( mrb, self )->animVertices = mrb_cptr( param0 );
	return self;
}
	
static mrb_value
class_raylib_mesh_get_animNormals( mrb_state *mrb, mrb_value self ) {
	return mrb_cptr_value( mrb, ( void* )( class_raylib_mesh_get_ptr( mrb, self )->animNormals ) );
}
	
static mrb_value
class_raylib_mesh_set_animNormals( mrb_state *mrb, mrb_value self ) {
	mrb_value param0;
	mrb_get_args( mrb, "*", &param0 );
	class_raylib_mesh_get_ptr( mrb, self )->animNormals = mrb_cptr( param0 );
	return self;
}
	
static mrb_value
class_raylib_mesh_get_boneIds( mrb_state *mrb, mrb_value self ) {
	return mrb_cptr_value( mrb, ( void* )( class_raylib_mesh_get_ptr( mrb, self )->boneIds ) );
}
	
static mrb_value
class_raylib_mesh_set_boneIds( mrb_state *mrb, mrb_value self ) {
	mrb_value param0;
	mrb_get_args( mrb, "*", &param0 );
	class_raylib_mesh_get_ptr( mrb, self )->boneIds = mrb_cptr( param0 );
	return self;
}
	
static mrb_value
class_raylib_mesh_get_boneWeights( mrb_state *mrb, mrb_value self ) {
	return mrb_cptr_value( mrb, ( void* )( class_raylib_mesh_get_ptr( mrb, self )->boneWeights ) );
}
	
static mrb_value
class_raylib_mesh_set_boneWeights( mrb_state *mrb, mrb_value self ) {
	mrb_value param0;
	mrb_get_args( mrb, "*", &param0 );
	class_raylib_mesh_get_ptr( mrb, self )->boneWeights = mrb_cptr( param0 );
	return self;
}
	
static mrb_value
class_raylib_mesh_get_vaoId( mrb_state *mrb, mrb_value self ) {
	return mrb_fixnum_value( class_raylib_mesh_get_ptr( mrb, self )->vaoId );
}
	
static mrb_value
class_raylib_mesh_set_vaoId( mrb_state *mrb, mrb_value self ) {
	mrb_int param0;
	mrb_get_args( mrb, "i", &param0 );
	class_raylib_mesh_get_ptr( mrb, self )->vaoId = param0;
	return self;
}
	
static mrb_value
class_raylib_mesh_get_vboId( mrb_state *mrb, mrb_value self ) {
	return mrb_cptr_value( mrb, ( void* )( class_raylib_mesh_get_ptr( mrb, self )->vboId ) );
}
	
static mrb_value
class_raylib_mesh_set_vboId( mrb_state *mrb, mrb_value self ) {
	mrb_value param0;
	mrb_get_args( mrb, "*", &param0 );
	class_raylib_mesh_get_ptr( mrb, self )->vboId = mrb_cptr( param0 );
	return self;
}
	
void
class_raylib_mesh_init( mrb_state *mrb, struct RClass *mod_RayLib ) {
	class_Mesh = mrb_define_class_under( mrb, mod_RayLib, "Mesh", mrb->object_class );

	MRB_SET_INSTANCE_TT( class_Mesh, MRB_TT_DATA );

	mrb_define_method( mrb, class_Mesh, "initialize", class_raylib_mesh_initialize, MRB_ARGS_NONE() );

	mrb_define_method( mrb, class_Mesh, "vertex_count", class_raylib_mesh_get_vertexCount, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Mesh, "vertex_count=", class_raylib_mesh_set_vertexCount, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Mesh, "triangle_count", class_raylib_mesh_get_triangleCount, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Mesh, "triangle_count=", class_raylib_mesh_set_triangleCount, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Mesh, "vertices", class_raylib_mesh_get_vertices, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Mesh, "vertices=", class_raylib_mesh_set_vertices, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Mesh, "texcoords", class_raylib_mesh_get_texcoords, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Mesh, "texcoords=", class_raylib_mesh_set_texcoords, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Mesh, "texcoords2", class_raylib_mesh_get_texcoords2, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Mesh, "texcoords2=", class_raylib_mesh_set_texcoords2, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Mesh, "normals", class_raylib_mesh_get_normals, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Mesh, "normals=", class_raylib_mesh_set_normals, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Mesh, "tangents", class_raylib_mesh_get_tangents, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Mesh, "tangents=", class_raylib_mesh_set_tangents, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Mesh, "colors", class_raylib_mesh_get_colors, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Mesh, "colors=", class_raylib_mesh_set_colors, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Mesh, "indices", class_raylib_mesh_get_indices, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Mesh, "indices=", class_raylib_mesh_set_indices, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Mesh, "anim_vertices", class_raylib_mesh_get_animVertices, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Mesh, "anim_vertices=", class_raylib_mesh_set_animVertices, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Mesh, "anim_normals", class_raylib_mesh_get_animNormals, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Mesh, "anim_normals=", class_raylib_mesh_set_animNormals, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Mesh, "bone_ids", class_raylib_mesh_get_boneIds, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Mesh, "bone_ids=", class_raylib_mesh_set_boneIds, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Mesh, "bone_weights", class_raylib_mesh_get_boneWeights, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Mesh, "bone_weights=", class_raylib_mesh_set_boneWeights, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Mesh, "vao_id", class_raylib_mesh_get_vaoId, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Mesh, "vao_id=", class_raylib_mesh_set_vaoId, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Mesh, "vbo_id", class_raylib_mesh_get_vboId, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Mesh, "vbo_id=", class_raylib_mesh_set_vboId, MRB_ARGS_REQ( 1 ) );
}
//----------------------------------------------------------------//


//----------------------------------------------------------------//
// Raylib::Shader
static struct RClass *class_Shader;

typedef struct class_raylib_shader_data_t {
	bool is_associated;
	Shader shader;
} class_raylib_shader_data_t;
		
static void
class_raylib_shader_data_free( mrb_state *mrb, void *p ) {
	class_raylib_shader_data_t *data = ( class_raylib_shader_data_t* )p;
	if ( NULL != data ) {
		mrb_free( mrb, data );
	}
}

static struct mrb_data_type const class_raylib_shader_data_type = {
	"Shader", class_raylib_shader_data_free
};

mrb_value
class_raylib_shader_2_mrbvalue( mrb_state *mrb, Shader *shader, bool is_associated ) {
	class_raylib_shader_data_t *data = ( class_raylib_shader_data_t* )mrb_malloc( mrb, sizeof( class_raylib_shader_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	data->is_associated = is_associated;
	data->shader = *shader;
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_Shader, &class_raylib_shader_data_type, data ) );
}

mrb_value
class_raylib_shader_2_mrbvalue_direct( mrb_state *mrb, Shader const *shader ) {
	class_raylib_shader_data_t *data = ( class_raylib_shader_data_t* )mrb_malloc( mrb, sizeof( class_raylib_shader_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	if ( NULL == shader ) {
		// Do init
	} else {
		// Do Copy
		data->shader = *shader;
	}
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_Shader, &class_raylib_shader_data_type, data ) );
}

Shader*
class_raylib_shader_get_ptr( mrb_state *mrb, mrb_value shader ) {
	class_raylib_shader_data_t *data;
	if ( mrb_nil_p( shader ) ) {
		return NULL;
	}
	data = ( class_raylib_shader_data_t* )mrb_data_get_ptr( mrb, shader, &class_raylib_shader_data_type );
	return &data->shader;
}

static mrb_value
class_raylib_shader_initialize( mrb_state *mrb, mrb_value self ) {
	class_raylib_shader_data_t *data = DATA_PTR( self );

	if ( NULL == data ) {
		data = mrb_malloc( mrb, sizeof( class_raylib_shader_data_t ) );
		if ( NULL == data ) {
			mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
		}
		//data->shader = { 0 };
	} else {
		// if ( NULL != &( data->shader ) ) {
		// 
		// }
	}
	Shader shader = { 0 };
	data->shader = shader;
	// if ( NULL == &( data->shader ) ) {
	//	mrb_free( mrb, data );
	// }
	DATA_PTR( self ) = data;
	DATA_TYPE( self ) = &class_raylib_shader_data_type;
	return self;
}

static mrb_value
class_raylib_shader_get_id( mrb_state *mrb, mrb_value self ) {
	return mrb_fixnum_value( class_raylib_shader_get_ptr( mrb, self )->id );
}
	
static mrb_value
class_raylib_shader_set_id( mrb_state *mrb, mrb_value self ) {
	mrb_int param0;
	mrb_get_args( mrb, "i", &param0 );
	class_raylib_shader_get_ptr( mrb, self )->id = param0;
	return self;
}
	
static mrb_value
class_raylib_shader_get_locs( mrb_state *mrb, mrb_value self ) {
	return mrb_cptr_value( mrb, ( void* )( class_raylib_shader_get_ptr( mrb, self )->locs ) );
}
	
static mrb_value
class_raylib_shader_set_locs( mrb_state *mrb, mrb_value self ) {
	mrb_value param0;
	mrb_get_args( mrb, "*", &param0 );
	class_raylib_shader_get_ptr( mrb, self )->locs = mrb_cptr( param0 );
	return self;
}
	
void
class_raylib_shader_init( mrb_state *mrb, struct RClass *mod_RayLib ) {
	class_Shader = mrb_define_class_under( mrb, mod_RayLib, "Shader", mrb->object_class );

	MRB_SET_INSTANCE_TT( class_Shader, MRB_TT_DATA );

	mrb_define_method( mrb, class_Shader, "initialize", class_raylib_shader_initialize, MRB_ARGS_NONE() );

	mrb_define_method( mrb, class_Shader, "id", class_raylib_shader_get_id, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Shader, "id=", class_raylib_shader_set_id, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Shader, "locs", class_raylib_shader_get_locs, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Shader, "locs=", class_raylib_shader_set_locs, MRB_ARGS_REQ( 1 ) );
}
//----------------------------------------------------------------//


//----------------------------------------------------------------//
// Raylib::MaterialMap
static struct RClass *class_MaterialMap;

typedef struct class_raylib_materialmap_data_t {
	bool is_associated;
	MaterialMap materialmap;
} class_raylib_materialmap_data_t;
		
static void
class_raylib_materialmap_data_free( mrb_state *mrb, void *p ) {
	class_raylib_materialmap_data_t *data = ( class_raylib_materialmap_data_t* )p;
	if ( NULL != data ) {
		mrb_free( mrb, data );
	}
}

static struct mrb_data_type const class_raylib_materialmap_data_type = {
	"MaterialMap", class_raylib_materialmap_data_free
};

mrb_value
class_raylib_materialmap_2_mrbvalue( mrb_state *mrb, MaterialMap *materialmap, bool is_associated ) {
	class_raylib_materialmap_data_t *data = ( class_raylib_materialmap_data_t* )mrb_malloc( mrb, sizeof( class_raylib_materialmap_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	data->is_associated = is_associated;
	data->materialmap = *materialmap;
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_MaterialMap, &class_raylib_materialmap_data_type, data ) );
}

mrb_value
class_raylib_materialmap_2_mrbvalue_direct( mrb_state *mrb, MaterialMap const *materialmap ) {
	class_raylib_materialmap_data_t *data = ( class_raylib_materialmap_data_t* )mrb_malloc( mrb, sizeof( class_raylib_materialmap_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	if ( NULL == materialmap ) {
		// Do init
	} else {
		// Do Copy
		data->materialmap = *materialmap;
	}
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_MaterialMap, &class_raylib_materialmap_data_type, data ) );
}

MaterialMap*
class_raylib_materialmap_get_ptr( mrb_state *mrb, mrb_value materialmap ) {
	class_raylib_materialmap_data_t *data;
	if ( mrb_nil_p( materialmap ) ) {
		return NULL;
	}
	data = ( class_raylib_materialmap_data_t* )mrb_data_get_ptr( mrb, materialmap, &class_raylib_materialmap_data_type );
	return &data->materialmap;
}

static mrb_value
class_raylib_materialmap_initialize( mrb_state *mrb, mrb_value self ) {
	class_raylib_materialmap_data_t *data = DATA_PTR( self );

	if ( NULL == data ) {
		data = mrb_malloc( mrb, sizeof( class_raylib_materialmap_data_t ) );
		if ( NULL == data ) {
			mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
		}
		//data->materialmap = { 0 };
	} else {
		// if ( NULL != &( data->materialmap ) ) {
		// 
		// }
	}
	MaterialMap materialmap = { 0 };
	data->materialmap = materialmap;
	// if ( NULL == &( data->materialmap ) ) {
	//	mrb_free( mrb, data );
	// }
	DATA_PTR( self ) = data;
	DATA_TYPE( self ) = &class_raylib_materialmap_data_type;
	return self;
}

static mrb_value
class_raylib_materialmap_get_texture( mrb_state *mrb, mrb_value self ) {
	return class_raylib_texture_2_mrbvalue( mrb, &class_raylib_materialmap_get_ptr( mrb, self )->texture, 0 );
}
	
static mrb_value
class_raylib_materialmap_set_texture( mrb_state *mrb, mrb_value self ) {
	mrb_value param0;
	mrb_get_args( mrb, "d", &param0 );
	class_raylib_materialmap_get_ptr( mrb, self )->texture = *class_raylib_texture_get_ptr( mrb, param0 );
	return self;
}
	
static mrb_value
class_raylib_materialmap_get_color( mrb_state *mrb, mrb_value self ) {
	return class_raylib_color_2_mrbvalue( mrb, &class_raylib_materialmap_get_ptr( mrb, self )->color, 0 );
}
	
static mrb_value
class_raylib_materialmap_set_color( mrb_state *mrb, mrb_value self ) {
	mrb_value param0;
	mrb_get_args( mrb, "o", &param0 );
	class_raylib_materialmap_get_ptr( mrb, self )->color = *class_raylib_color_get_ptr( mrb, param0 );
	return self;
}
	
static mrb_value
class_raylib_materialmap_get_value( mrb_state *mrb, mrb_value self ) {
	return mrb_float_value( mrb, class_raylib_materialmap_get_ptr( mrb, self )->value );
}
	
static mrb_value
class_raylib_materialmap_set_value( mrb_state *mrb, mrb_value self ) {
	mrb_float param0;
	mrb_get_args( mrb, "f", &param0 );
	class_raylib_materialmap_get_ptr( mrb, self )->value = param0;
	return self;
}
	
void
class_raylib_materialmap_init( mrb_state *mrb, struct RClass *mod_RayLib ) {
	class_MaterialMap = mrb_define_class_under( mrb, mod_RayLib, "MaterialMap", mrb->object_class );

	MRB_SET_INSTANCE_TT( class_MaterialMap, MRB_TT_DATA );

	mrb_define_method( mrb, class_MaterialMap, "initialize", class_raylib_materialmap_initialize, MRB_ARGS_NONE() );

	mrb_define_method( mrb, class_MaterialMap, "texture", class_raylib_materialmap_get_texture, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_MaterialMap, "texture=", class_raylib_materialmap_set_texture, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_MaterialMap, "color", class_raylib_materialmap_get_color, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_MaterialMap, "color=", class_raylib_materialmap_set_color, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_MaterialMap, "value", class_raylib_materialmap_get_value, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_MaterialMap, "value=", class_raylib_materialmap_set_value, MRB_ARGS_REQ( 1 ) );
}
//----------------------------------------------------------------//


//----------------------------------------------------------------//
// Raylib::Material
static struct RClass *class_Material;

typedef struct class_raylib_material_data_t {
	bool is_associated;
	Material material;
} class_raylib_material_data_t;
		
static void
class_raylib_material_data_free( mrb_state *mrb, void *p ) {
	class_raylib_material_data_t *data = ( class_raylib_material_data_t* )p;
	if ( NULL != data ) {
		mrb_free( mrb, data );
	}
}

static struct mrb_data_type const class_raylib_material_data_type = {
	"Material", class_raylib_material_data_free
};

mrb_value
class_raylib_material_2_mrbvalue( mrb_state *mrb, Material *material, bool is_associated ) {
	class_raylib_material_data_t *data = ( class_raylib_material_data_t* )mrb_malloc( mrb, sizeof( class_raylib_material_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	data->is_associated = is_associated;
	data->material = *material;
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_Material, &class_raylib_material_data_type, data ) );
}

mrb_value
class_raylib_material_2_mrbvalue_direct( mrb_state *mrb, Material const *material ) {
	class_raylib_material_data_t *data = ( class_raylib_material_data_t* )mrb_malloc( mrb, sizeof( class_raylib_material_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	if ( NULL == material ) {
		// Do init
	} else {
		// Do Copy
		data->material = *material;
	}
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_Material, &class_raylib_material_data_type, data ) );
}

Material*
class_raylib_material_get_ptr( mrb_state *mrb, mrb_value material ) {
	class_raylib_material_data_t *data;
	if ( mrb_nil_p( material ) ) {
		return NULL;
	}
	data = ( class_raylib_material_data_t* )mrb_data_get_ptr( mrb, material, &class_raylib_material_data_type );
	return &data->material;
}

static mrb_value
class_raylib_material_initialize( mrb_state *mrb, mrb_value self ) {
	class_raylib_material_data_t *data = DATA_PTR( self );

	if ( NULL == data ) {
		data = mrb_malloc( mrb, sizeof( class_raylib_material_data_t ) );
		if ( NULL == data ) {
			mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
		}
		//data->material = { 0 };
	} else {
		// if ( NULL != &( data->material ) ) {
		// 
		// }
	}
	Material material = { 0 };
	data->material = material;
	// if ( NULL == &( data->material ) ) {
	//	mrb_free( mrb, data );
	// }
	DATA_PTR( self ) = data;
	DATA_TYPE( self ) = &class_raylib_material_data_type;
	return self;
}

static mrb_value
class_raylib_material_get_shader( mrb_state *mrb, mrb_value self ) {
	return class_raylib_shader_2_mrbvalue( mrb, &class_raylib_material_get_ptr( mrb, self )->shader, 0 );
}
	
static mrb_value
class_raylib_material_set_shader( mrb_state *mrb, mrb_value self ) {
	mrb_value param0;
	mrb_get_args( mrb, "o", &param0 );
	class_raylib_material_get_ptr( mrb, self )->shader = *class_raylib_shader_get_ptr( mrb, param0 );
	return self;
}
	
static mrb_value
class_raylib_material_get_maps( mrb_state *mrb, mrb_value self ) {
	return class_raylib_materialmap_2_mrbvalue( mrb, class_raylib_material_get_ptr( mrb, self )->maps, 0 );
}
	
static mrb_value
class_raylib_material_set_maps( mrb_state *mrb, mrb_value self ) {
	mrb_value param0;
	mrb_get_args( mrb, "!d", &param0 );
	class_raylib_material_get_ptr( mrb, self )->maps = class_raylib_materialmap_get_ptr( mrb, param0 );
	return self;
}
	
static mrb_value
class_raylib_material_get_params( mrb_state *mrb, mrb_value self ) {
	mrb_value arr = mrb_ary_new( mrb );
mrb_ary_push( mrb, arr, mrb_float_value( mrb, class_raylib_material_get_ptr( mrb, self )->params[ 0 ] ) );
mrb_ary_push( mrb, arr, mrb_float_value( mrb, class_raylib_material_get_ptr( mrb, self )->params[ 1 ] ) );
mrb_ary_push( mrb, arr, mrb_float_value( mrb, class_raylib_material_get_ptr( mrb, self )->params[ 2 ] ) );
mrb_ary_push( mrb, arr, mrb_float_value( mrb, class_raylib_material_get_ptr( mrb, self )->params[ 3 ] ) );
return arr;
}
	
static mrb_value
class_raylib_material_set_params( mrb_state *mrb, mrb_value self ) {
	// TODO: set params
	return self;
}
	
void
class_raylib_material_init( mrb_state *mrb, struct RClass *mod_RayLib ) {
	class_Material = mrb_define_class_under( mrb, mod_RayLib, "Material", mrb->object_class );

	MRB_SET_INSTANCE_TT( class_Material, MRB_TT_DATA );

	mrb_define_method( mrb, class_Material, "initialize", class_raylib_material_initialize, MRB_ARGS_NONE() );

	mrb_define_method( mrb, class_Material, "shader", class_raylib_material_get_shader, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Material, "shader=", class_raylib_material_set_shader, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Material, "maps", class_raylib_material_get_maps, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Material, "maps=", class_raylib_material_set_maps, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Material, "params", class_raylib_material_get_params, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Material, "params=", class_raylib_material_set_params, MRB_ARGS_REQ( 1 ) );
}
//----------------------------------------------------------------//


//----------------------------------------------------------------//
// Raylib::Transform
static struct RClass *class_Transform;

typedef struct class_raylib_transform_data_t {
	bool is_associated;
	Transform transform;
} class_raylib_transform_data_t;
		
static void
class_raylib_transform_data_free( mrb_state *mrb, void *p ) {
	class_raylib_transform_data_t *data = ( class_raylib_transform_data_t* )p;
	if ( NULL != data ) {
		mrb_free( mrb, data );
	}
}

static struct mrb_data_type const class_raylib_transform_data_type = {
	"Transform", class_raylib_transform_data_free
};

mrb_value
class_raylib_transform_2_mrbvalue( mrb_state *mrb, Transform *transform, bool is_associated ) {
	class_raylib_transform_data_t *data = ( class_raylib_transform_data_t* )mrb_malloc( mrb, sizeof( class_raylib_transform_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	data->is_associated = is_associated;
	data->transform = *transform;
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_Transform, &class_raylib_transform_data_type, data ) );
}

mrb_value
class_raylib_transform_2_mrbvalue_direct( mrb_state *mrb, Transform const *transform ) {
	class_raylib_transform_data_t *data = ( class_raylib_transform_data_t* )mrb_malloc( mrb, sizeof( class_raylib_transform_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	if ( NULL == transform ) {
		// Do init
	} else {
		// Do Copy
		data->transform = *transform;
	}
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_Transform, &class_raylib_transform_data_type, data ) );
}

Transform*
class_raylib_transform_get_ptr( mrb_state *mrb, mrb_value transform ) {
	class_raylib_transform_data_t *data;
	if ( mrb_nil_p( transform ) ) {
		return NULL;
	}
	data = ( class_raylib_transform_data_t* )mrb_data_get_ptr( mrb, transform, &class_raylib_transform_data_type );
	return &data->transform;
}

static mrb_value
class_raylib_transform_initialize( mrb_state *mrb, mrb_value self ) {
	class_raylib_transform_data_t *data = DATA_PTR( self );

	if ( NULL == data ) {
		data = mrb_malloc( mrb, sizeof( class_raylib_transform_data_t ) );
		if ( NULL == data ) {
			mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
		}
		//data->transform = { 0 };
	} else {
		// if ( NULL != &( data->transform ) ) {
		// 
		// }
	}
	Transform transform = { 0 };
	data->transform = transform;
	// if ( NULL == &( data->transform ) ) {
	//	mrb_free( mrb, data );
	// }
	DATA_PTR( self ) = data;
	DATA_TYPE( self ) = &class_raylib_transform_data_type;
	return self;
}

static mrb_value
class_raylib_transform_get_translation( mrb_state *mrb, mrb_value self ) {
	return class_raylib_vector3_2_mrbvalue( mrb, &class_raylib_transform_get_ptr( mrb, self )->translation, 0 );
}
	
static mrb_value
class_raylib_transform_set_translation( mrb_state *mrb, mrb_value self ) {
	mrb_value param0;
	mrb_get_args( mrb, "o", &param0 );
	class_raylib_transform_get_ptr( mrb, self )->translation = *class_raylib_vector3_get_ptr( mrb, param0 );
	return self;
}
	
static mrb_value
class_raylib_transform_get_rotation( mrb_state *mrb, mrb_value self ) {
	return class_raylib_vector4_2_mrbvalue( mrb, &class_raylib_transform_get_ptr( mrb, self )->rotation, 0 );
}
	
static mrb_value
class_raylib_transform_set_rotation( mrb_state *mrb, mrb_value self ) {
	mrb_value param0;
	mrb_get_args( mrb, "d", &param0 );
	class_raylib_transform_get_ptr( mrb, self )->rotation = *class_raylib_vector4_get_ptr( mrb, param0 );
	return self;
}
	
static mrb_value
class_raylib_transform_get_scale( mrb_state *mrb, mrb_value self ) {
	return class_raylib_vector3_2_mrbvalue( mrb, &class_raylib_transform_get_ptr( mrb, self )->scale, 0 );
}
	
static mrb_value
class_raylib_transform_set_scale( mrb_state *mrb, mrb_value self ) {
	mrb_value param0;
	mrb_get_args( mrb, "o", &param0 );
	class_raylib_transform_get_ptr( mrb, self )->scale = *class_raylib_vector3_get_ptr( mrb, param0 );
	return self;
}
	
void
class_raylib_transform_init( mrb_state *mrb, struct RClass *mod_RayLib ) {
	class_Transform = mrb_define_class_under( mrb, mod_RayLib, "Transform", mrb->object_class );

	MRB_SET_INSTANCE_TT( class_Transform, MRB_TT_DATA );

	mrb_define_method( mrb, class_Transform, "initialize", class_raylib_transform_initialize, MRB_ARGS_NONE() );

	mrb_define_method( mrb, class_Transform, "translation", class_raylib_transform_get_translation, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Transform, "translation=", class_raylib_transform_set_translation, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Transform, "rotation", class_raylib_transform_get_rotation, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Transform, "rotation=", class_raylib_transform_set_rotation, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Transform, "scale", class_raylib_transform_get_scale, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Transform, "scale=", class_raylib_transform_set_scale, MRB_ARGS_REQ( 1 ) );
}
//----------------------------------------------------------------//


//----------------------------------------------------------------//
// Raylib::BoneInfo
static struct RClass *class_BoneInfo;

typedef struct class_raylib_boneinfo_data_t {
	bool is_associated;
	BoneInfo boneinfo;
} class_raylib_boneinfo_data_t;
		
static void
class_raylib_boneinfo_data_free( mrb_state *mrb, void *p ) {
	class_raylib_boneinfo_data_t *data = ( class_raylib_boneinfo_data_t* )p;
	if ( NULL != data ) {
		mrb_free( mrb, data );
	}
}

static struct mrb_data_type const class_raylib_boneinfo_data_type = {
	"BoneInfo", class_raylib_boneinfo_data_free
};

mrb_value
class_raylib_boneinfo_2_mrbvalue( mrb_state *mrb, BoneInfo *boneinfo, bool is_associated ) {
	class_raylib_boneinfo_data_t *data = ( class_raylib_boneinfo_data_t* )mrb_malloc( mrb, sizeof( class_raylib_boneinfo_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	data->is_associated = is_associated;
	data->boneinfo = *boneinfo;
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_BoneInfo, &class_raylib_boneinfo_data_type, data ) );
}

mrb_value
class_raylib_boneinfo_2_mrbvalue_direct( mrb_state *mrb, BoneInfo const *boneinfo ) {
	class_raylib_boneinfo_data_t *data = ( class_raylib_boneinfo_data_t* )mrb_malloc( mrb, sizeof( class_raylib_boneinfo_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	if ( NULL == boneinfo ) {
		// Do init
	} else {
		// Do Copy
		data->boneinfo = *boneinfo;
	}
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_BoneInfo, &class_raylib_boneinfo_data_type, data ) );
}

BoneInfo*
class_raylib_boneinfo_get_ptr( mrb_state *mrb, mrb_value boneinfo ) {
	class_raylib_boneinfo_data_t *data;
	if ( mrb_nil_p( boneinfo ) ) {
		return NULL;
	}
	data = ( class_raylib_boneinfo_data_t* )mrb_data_get_ptr( mrb, boneinfo, &class_raylib_boneinfo_data_type );
	return &data->boneinfo;
}

static mrb_value
class_raylib_boneinfo_initialize( mrb_state *mrb, mrb_value self ) {
	class_raylib_boneinfo_data_t *data = DATA_PTR( self );

	if ( NULL == data ) {
		data = mrb_malloc( mrb, sizeof( class_raylib_boneinfo_data_t ) );
		if ( NULL == data ) {
			mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
		}
		//data->boneinfo = { 0 };
	} else {
		// if ( NULL != &( data->boneinfo ) ) {
		// 
		// }
	}
	BoneInfo boneinfo = { 0 };
	data->boneinfo = boneinfo;
	// if ( NULL == &( data->boneinfo ) ) {
	//	mrb_free( mrb, data );
	// }
	DATA_PTR( self ) = data;
	DATA_TYPE( self ) = &class_raylib_boneinfo_data_type;
	return self;
}

static mrb_value
class_raylib_boneinfo_get_name( mrb_state *mrb, mrb_value self ) {
	mrb_value arr = mrb_ary_new( mrb );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_boneinfo_get_ptr( mrb, self )->name[ 0 ] ) );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_boneinfo_get_ptr( mrb, self )->name[ 1 ] ) );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_boneinfo_get_ptr( mrb, self )->name[ 2 ] ) );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_boneinfo_get_ptr( mrb, self )->name[ 3 ] ) );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_boneinfo_get_ptr( mrb, self )->name[ 4 ] ) );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_boneinfo_get_ptr( mrb, self )->name[ 5 ] ) );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_boneinfo_get_ptr( mrb, self )->name[ 6 ] ) );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_boneinfo_get_ptr( mrb, self )->name[ 7 ] ) );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_boneinfo_get_ptr( mrb, self )->name[ 8 ] ) );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_boneinfo_get_ptr( mrb, self )->name[ 9 ] ) );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_boneinfo_get_ptr( mrb, self )->name[ 10 ] ) );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_boneinfo_get_ptr( mrb, self )->name[ 11 ] ) );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_boneinfo_get_ptr( mrb, self )->name[ 12 ] ) );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_boneinfo_get_ptr( mrb, self )->name[ 13 ] ) );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_boneinfo_get_ptr( mrb, self )->name[ 14 ] ) );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_boneinfo_get_ptr( mrb, self )->name[ 15 ] ) );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_boneinfo_get_ptr( mrb, self )->name[ 16 ] ) );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_boneinfo_get_ptr( mrb, self )->name[ 17 ] ) );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_boneinfo_get_ptr( mrb, self )->name[ 18 ] ) );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_boneinfo_get_ptr( mrb, self )->name[ 19 ] ) );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_boneinfo_get_ptr( mrb, self )->name[ 20 ] ) );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_boneinfo_get_ptr( mrb, self )->name[ 21 ] ) );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_boneinfo_get_ptr( mrb, self )->name[ 22 ] ) );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_boneinfo_get_ptr( mrb, self )->name[ 23 ] ) );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_boneinfo_get_ptr( mrb, self )->name[ 24 ] ) );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_boneinfo_get_ptr( mrb, self )->name[ 25 ] ) );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_boneinfo_get_ptr( mrb, self )->name[ 26 ] ) );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_boneinfo_get_ptr( mrb, self )->name[ 27 ] ) );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_boneinfo_get_ptr( mrb, self )->name[ 28 ] ) );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_boneinfo_get_ptr( mrb, self )->name[ 29 ] ) );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_boneinfo_get_ptr( mrb, self )->name[ 30 ] ) );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_boneinfo_get_ptr( mrb, self )->name[ 31 ] ) );
return arr;
}
	
static mrb_value
class_raylib_boneinfo_set_name( mrb_state *mrb, mrb_value self ) {
	// TODO: set name
	return self;
}
	
static mrb_value
class_raylib_boneinfo_get_parent( mrb_state *mrb, mrb_value self ) {
	return mrb_fixnum_value( class_raylib_boneinfo_get_ptr( mrb, self )->parent );
}
	
static mrb_value
class_raylib_boneinfo_set_parent( mrb_state *mrb, mrb_value self ) {
	mrb_int param0;
	mrb_get_args( mrb, "i", &param0 );
	class_raylib_boneinfo_get_ptr( mrb, self )->parent = param0;
	return self;
}
	
void
class_raylib_boneinfo_init( mrb_state *mrb, struct RClass *mod_RayLib ) {
	class_BoneInfo = mrb_define_class_under( mrb, mod_RayLib, "BoneInfo", mrb->object_class );

	MRB_SET_INSTANCE_TT( class_BoneInfo, MRB_TT_DATA );

	mrb_define_method( mrb, class_BoneInfo, "initialize", class_raylib_boneinfo_initialize, MRB_ARGS_NONE() );

	mrb_define_method( mrb, class_BoneInfo, "name", class_raylib_boneinfo_get_name, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_BoneInfo, "name=", class_raylib_boneinfo_set_name, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_BoneInfo, "parent", class_raylib_boneinfo_get_parent, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_BoneInfo, "parent=", class_raylib_boneinfo_set_parent, MRB_ARGS_REQ( 1 ) );
}
//----------------------------------------------------------------//


//----------------------------------------------------------------//
// Raylib::Model
static struct RClass *class_Model;

typedef struct class_raylib_model_data_t {
	bool is_associated;
	Model model;
} class_raylib_model_data_t;
		
static void
class_raylib_model_data_free( mrb_state *mrb, void *p ) {
	class_raylib_model_data_t *data = ( class_raylib_model_data_t* )p;
	if ( NULL != data ) {
		mrb_free( mrb, data );
	}
}

static struct mrb_data_type const class_raylib_model_data_type = {
	"Model", class_raylib_model_data_free
};

mrb_value
class_raylib_model_2_mrbvalue( mrb_state *mrb, Model *model, bool is_associated ) {
	class_raylib_model_data_t *data = ( class_raylib_model_data_t* )mrb_malloc( mrb, sizeof( class_raylib_model_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	data->is_associated = is_associated;
	data->model = *model;
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_Model, &class_raylib_model_data_type, data ) );
}

mrb_value
class_raylib_model_2_mrbvalue_direct( mrb_state *mrb, Model const *model ) {
	class_raylib_model_data_t *data = ( class_raylib_model_data_t* )mrb_malloc( mrb, sizeof( class_raylib_model_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	if ( NULL == model ) {
		// Do init
	} else {
		// Do Copy
		data->model = *model;
	}
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_Model, &class_raylib_model_data_type, data ) );
}

Model*
class_raylib_model_get_ptr( mrb_state *mrb, mrb_value model ) {
	class_raylib_model_data_t *data;
	if ( mrb_nil_p( model ) ) {
		return NULL;
	}
	data = ( class_raylib_model_data_t* )mrb_data_get_ptr( mrb, model, &class_raylib_model_data_type );
	return &data->model;
}

static mrb_value
class_raylib_model_initialize( mrb_state *mrb, mrb_value self ) {
	class_raylib_model_data_t *data = DATA_PTR( self );

	if ( NULL == data ) {
		data = mrb_malloc( mrb, sizeof( class_raylib_model_data_t ) );
		if ( NULL == data ) {
			mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
		}
		//data->model = { 0 };
	} else {
		// if ( NULL != &( data->model ) ) {
		// 
		// }
	}
	Model model = { 0 };
	data->model = model;
	// if ( NULL == &( data->model ) ) {
	//	mrb_free( mrb, data );
	// }
	DATA_PTR( self ) = data;
	DATA_TYPE( self ) = &class_raylib_model_data_type;
	return self;
}

static mrb_value
class_raylib_model_get_transform( mrb_state *mrb, mrb_value self ) {
	return class_raylib_matrix_2_mrbvalue( mrb, &class_raylib_model_get_ptr( mrb, self )->transform, 0 );
}
	
static mrb_value
class_raylib_model_set_transform( mrb_state *mrb, mrb_value self ) {
	mrb_value param0;
	mrb_get_args( mrb, "o", &param0 );
	class_raylib_model_get_ptr( mrb, self )->transform = *class_raylib_matrix_get_ptr( mrb, param0 );
	return self;
}
	
static mrb_value
class_raylib_model_get_meshCount( mrb_state *mrb, mrb_value self ) {
	return mrb_fixnum_value( class_raylib_model_get_ptr( mrb, self )->meshCount );
}
	
static mrb_value
class_raylib_model_set_meshCount( mrb_state *mrb, mrb_value self ) {
	mrb_int param0;
	mrb_get_args( mrb, "i", &param0 );
	class_raylib_model_get_ptr( mrb, self )->meshCount = param0;
	return self;
}
	
static mrb_value
class_raylib_model_get_materialCount( mrb_state *mrb, mrb_value self ) {
	return mrb_fixnum_value( class_raylib_model_get_ptr( mrb, self )->materialCount );
}
	
static mrb_value
class_raylib_model_set_materialCount( mrb_state *mrb, mrb_value self ) {
	mrb_int param0;
	mrb_get_args( mrb, "i", &param0 );
	class_raylib_model_get_ptr( mrb, self )->materialCount = param0;
	return self;
}
	
static mrb_value
class_raylib_model_get_meshes( mrb_state *mrb, mrb_value self ) {
	return class_raylib_mesh_2_mrbvalue( mrb, class_raylib_model_get_ptr( mrb, self )->meshes, 0 );
}
	
static mrb_value
class_raylib_model_set_meshes( mrb_state *mrb, mrb_value self ) {
	mrb_value param0;
	mrb_get_args( mrb, "!d", &param0 );
	class_raylib_model_get_ptr( mrb, self )->meshes = class_raylib_mesh_get_ptr( mrb, param0 );
	return self;
}
	
static mrb_value
class_raylib_model_get_materials( mrb_state *mrb, mrb_value self ) {
	return class_raylib_material_2_mrbvalue( mrb, class_raylib_model_get_ptr( mrb, self )->materials, 0 );
}
	
static mrb_value
class_raylib_model_set_materials( mrb_state *mrb, mrb_value self ) {
	mrb_value param0;
	mrb_get_args( mrb, "!d", &param0 );
	class_raylib_model_get_ptr( mrb, self )->materials = class_raylib_material_get_ptr( mrb, param0 );
	return self;
}
	
static mrb_value
class_raylib_model_get_meshMaterial( mrb_state *mrb, mrb_value self ) {
	return mrb_cptr_value( mrb, ( void* )( class_raylib_model_get_ptr( mrb, self )->meshMaterial ) );
}
	
static mrb_value
class_raylib_model_set_meshMaterial( mrb_state *mrb, mrb_value self ) {
	mrb_value param0;
	mrb_get_args( mrb, "*", &param0 );
	class_raylib_model_get_ptr( mrb, self )->meshMaterial = mrb_cptr( param0 );
	return self;
}
	
static mrb_value
class_raylib_model_get_boneCount( mrb_state *mrb, mrb_value self ) {
	return mrb_fixnum_value( class_raylib_model_get_ptr( mrb, self )->boneCount );
}
	
static mrb_value
class_raylib_model_set_boneCount( mrb_state *mrb, mrb_value self ) {
	mrb_int param0;
	mrb_get_args( mrb, "i", &param0 );
	class_raylib_model_get_ptr( mrb, self )->boneCount = param0;
	return self;
}
	
static mrb_value
class_raylib_model_get_bones( mrb_state *mrb, mrb_value self ) {
	return class_raylib_boneinfo_2_mrbvalue( mrb, class_raylib_model_get_ptr( mrb, self )->bones, 0 );
}
	
static mrb_value
class_raylib_model_set_bones( mrb_state *mrb, mrb_value self ) {
	mrb_value param0;
	mrb_get_args( mrb, "!d", &param0 );
	class_raylib_model_get_ptr( mrb, self )->bones = class_raylib_boneinfo_get_ptr( mrb, param0 );
	return self;
}
	
static mrb_value
class_raylib_model_get_bindPose( mrb_state *mrb, mrb_value self ) {
	return class_raylib_transform_2_mrbvalue( mrb, class_raylib_model_get_ptr( mrb, self )->bindPose, 0 );
}
	
static mrb_value
class_raylib_model_set_bindPose( mrb_state *mrb, mrb_value self ) {
	mrb_value param0;
	mrb_get_args( mrb, "!d", &param0 );
	class_raylib_model_get_ptr( mrb, self )->bindPose = class_raylib_transform_get_ptr( mrb, param0 );
	return self;
}
	
void
class_raylib_model_init( mrb_state *mrb, struct RClass *mod_RayLib ) {
	class_Model = mrb_define_class_under( mrb, mod_RayLib, "Model", mrb->object_class );

	MRB_SET_INSTANCE_TT( class_Model, MRB_TT_DATA );

	mrb_define_method( mrb, class_Model, "initialize", class_raylib_model_initialize, MRB_ARGS_NONE() );

	mrb_define_method( mrb, class_Model, "transform", class_raylib_model_get_transform, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Model, "transform=", class_raylib_model_set_transform, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Model, "mesh_count", class_raylib_model_get_meshCount, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Model, "mesh_count=", class_raylib_model_set_meshCount, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Model, "material_count", class_raylib_model_get_materialCount, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Model, "material_count=", class_raylib_model_set_materialCount, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Model, "meshes", class_raylib_model_get_meshes, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Model, "meshes=", class_raylib_model_set_meshes, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Model, "materials", class_raylib_model_get_materials, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Model, "materials=", class_raylib_model_set_materials, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Model, "mesh_material", class_raylib_model_get_meshMaterial, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Model, "mesh_material=", class_raylib_model_set_meshMaterial, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Model, "bone_count", class_raylib_model_get_boneCount, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Model, "bone_count=", class_raylib_model_set_boneCount, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Model, "bones", class_raylib_model_get_bones, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Model, "bones=", class_raylib_model_set_bones, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Model, "bind_pose", class_raylib_model_get_bindPose, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Model, "bind_pose=", class_raylib_model_set_bindPose, MRB_ARGS_REQ( 1 ) );
}
//----------------------------------------------------------------//


//----------------------------------------------------------------//
// Raylib::ModelAnimation
static struct RClass *class_ModelAnimation;

typedef struct class_raylib_modelanimation_data_t {
	bool is_associated;
	ModelAnimation modelanimation;
} class_raylib_modelanimation_data_t;
		
static void
class_raylib_modelanimation_data_free( mrb_state *mrb, void *p ) {
	class_raylib_modelanimation_data_t *data = ( class_raylib_modelanimation_data_t* )p;
	if ( NULL != data ) {
		mrb_free( mrb, data );
	}
}

static struct mrb_data_type const class_raylib_modelanimation_data_type = {
	"ModelAnimation", class_raylib_modelanimation_data_free
};

mrb_value
class_raylib_modelanimation_2_mrbvalue( mrb_state *mrb, ModelAnimation *modelanimation, bool is_associated ) {
	class_raylib_modelanimation_data_t *data = ( class_raylib_modelanimation_data_t* )mrb_malloc( mrb, sizeof( class_raylib_modelanimation_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	data->is_associated = is_associated;
	data->modelanimation = *modelanimation;
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_ModelAnimation, &class_raylib_modelanimation_data_type, data ) );
}

mrb_value
class_raylib_modelanimation_2_mrbvalue_direct( mrb_state *mrb, ModelAnimation const *modelanimation ) {
	class_raylib_modelanimation_data_t *data = ( class_raylib_modelanimation_data_t* )mrb_malloc( mrb, sizeof( class_raylib_modelanimation_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	if ( NULL == modelanimation ) {
		// Do init
	} else {
		// Do Copy
		data->modelanimation = *modelanimation;
	}
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_ModelAnimation, &class_raylib_modelanimation_data_type, data ) );
}

ModelAnimation*
class_raylib_modelanimation_get_ptr( mrb_state *mrb, mrb_value modelanimation ) {
	class_raylib_modelanimation_data_t *data;
	if ( mrb_nil_p( modelanimation ) ) {
		return NULL;
	}
	data = ( class_raylib_modelanimation_data_t* )mrb_data_get_ptr( mrb, modelanimation, &class_raylib_modelanimation_data_type );
	return &data->modelanimation;
}

static mrb_value
class_raylib_modelanimation_initialize( mrb_state *mrb, mrb_value self ) {
	class_raylib_modelanimation_data_t *data = DATA_PTR( self );

	if ( NULL == data ) {
		data = mrb_malloc( mrb, sizeof( class_raylib_modelanimation_data_t ) );
		if ( NULL == data ) {
			mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
		}
		//data->modelanimation = { 0 };
	} else {
		// if ( NULL != &( data->modelanimation ) ) {
		// 
		// }
	}
	ModelAnimation modelanimation = { 0 };
	data->modelanimation = modelanimation;
	// if ( NULL == &( data->modelanimation ) ) {
	//	mrb_free( mrb, data );
	// }
	DATA_PTR( self ) = data;
	DATA_TYPE( self ) = &class_raylib_modelanimation_data_type;
	return self;
}

static mrb_value
class_raylib_modelanimation_get_boneCount( mrb_state *mrb, mrb_value self ) {
	return mrb_fixnum_value( class_raylib_modelanimation_get_ptr( mrb, self )->boneCount );
}
	
static mrb_value
class_raylib_modelanimation_set_boneCount( mrb_state *mrb, mrb_value self ) {
	mrb_int param0;
	mrb_get_args( mrb, "i", &param0 );
	class_raylib_modelanimation_get_ptr( mrb, self )->boneCount = param0;
	return self;
}
	
static mrb_value
class_raylib_modelanimation_get_frameCount( mrb_state *mrb, mrb_value self ) {
	return mrb_fixnum_value( class_raylib_modelanimation_get_ptr( mrb, self )->frameCount );
}
	
static mrb_value
class_raylib_modelanimation_set_frameCount( mrb_state *mrb, mrb_value self ) {
	mrb_int param0;
	mrb_get_args( mrb, "i", &param0 );
	class_raylib_modelanimation_get_ptr( mrb, self )->frameCount = param0;
	return self;
}
	
static mrb_value
class_raylib_modelanimation_get_bones( mrb_state *mrb, mrb_value self ) {
	return class_raylib_boneinfo_2_mrbvalue( mrb, class_raylib_modelanimation_get_ptr( mrb, self )->bones, 0 );
}
	
static mrb_value
class_raylib_modelanimation_set_bones( mrb_state *mrb, mrb_value self ) {
	mrb_value param0;
	mrb_get_args( mrb, "!d", &param0 );
	class_raylib_modelanimation_get_ptr( mrb, self )->bones = class_raylib_boneinfo_get_ptr( mrb, param0 );
	return self;
}
	
static mrb_value
class_raylib_modelanimation_get_framePoses( mrb_state *mrb, mrb_value self ) {
	return mrb_cptr_value( mrb, ( void* )( class_raylib_modelanimation_get_ptr( mrb, self )->framePoses ) );
}
	
static mrb_value
class_raylib_modelanimation_set_framePoses( mrb_state *mrb, mrb_value self ) {
	mrb_value param0;
	mrb_get_args( mrb, "!d", &param0 );
	class_raylib_modelanimation_get_ptr( mrb, self )->framePoses = mrb_cptr( param0 );
	return self;
}
	
static mrb_value
class_raylib_modelanimation_get_name( mrb_state *mrb, mrb_value self ) {
	mrb_value arr = mrb_ary_new( mrb );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_modelanimation_get_ptr( mrb, self )->name[ 0 ] ) );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_modelanimation_get_ptr( mrb, self )->name[ 1 ] ) );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_modelanimation_get_ptr( mrb, self )->name[ 2 ] ) );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_modelanimation_get_ptr( mrb, self )->name[ 3 ] ) );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_modelanimation_get_ptr( mrb, self )->name[ 4 ] ) );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_modelanimation_get_ptr( mrb, self )->name[ 5 ] ) );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_modelanimation_get_ptr( mrb, self )->name[ 6 ] ) );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_modelanimation_get_ptr( mrb, self )->name[ 7 ] ) );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_modelanimation_get_ptr( mrb, self )->name[ 8 ] ) );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_modelanimation_get_ptr( mrb, self )->name[ 9 ] ) );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_modelanimation_get_ptr( mrb, self )->name[ 10 ] ) );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_modelanimation_get_ptr( mrb, self )->name[ 11 ] ) );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_modelanimation_get_ptr( mrb, self )->name[ 12 ] ) );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_modelanimation_get_ptr( mrb, self )->name[ 13 ] ) );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_modelanimation_get_ptr( mrb, self )->name[ 14 ] ) );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_modelanimation_get_ptr( mrb, self )->name[ 15 ] ) );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_modelanimation_get_ptr( mrb, self )->name[ 16 ] ) );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_modelanimation_get_ptr( mrb, self )->name[ 17 ] ) );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_modelanimation_get_ptr( mrb, self )->name[ 18 ] ) );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_modelanimation_get_ptr( mrb, self )->name[ 19 ] ) );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_modelanimation_get_ptr( mrb, self )->name[ 20 ] ) );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_modelanimation_get_ptr( mrb, self )->name[ 21 ] ) );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_modelanimation_get_ptr( mrb, self )->name[ 22 ] ) );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_modelanimation_get_ptr( mrb, self )->name[ 23 ] ) );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_modelanimation_get_ptr( mrb, self )->name[ 24 ] ) );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_modelanimation_get_ptr( mrb, self )->name[ 25 ] ) );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_modelanimation_get_ptr( mrb, self )->name[ 26 ] ) );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_modelanimation_get_ptr( mrb, self )->name[ 27 ] ) );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_modelanimation_get_ptr( mrb, self )->name[ 28 ] ) );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_modelanimation_get_ptr( mrb, self )->name[ 29 ] ) );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_modelanimation_get_ptr( mrb, self )->name[ 30 ] ) );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_modelanimation_get_ptr( mrb, self )->name[ 31 ] ) );
return arr;
}
	
static mrb_value
class_raylib_modelanimation_set_name( mrb_state *mrb, mrb_value self ) {
	// TODO: set name
	return self;
}
	
void
class_raylib_modelanimation_init( mrb_state *mrb, struct RClass *mod_RayLib ) {
	class_ModelAnimation = mrb_define_class_under( mrb, mod_RayLib, "ModelAnimation", mrb->object_class );

	MRB_SET_INSTANCE_TT( class_ModelAnimation, MRB_TT_DATA );

	mrb_define_method( mrb, class_ModelAnimation, "initialize", class_raylib_modelanimation_initialize, MRB_ARGS_NONE() );

	mrb_define_method( mrb, class_ModelAnimation, "bone_count", class_raylib_modelanimation_get_boneCount, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_ModelAnimation, "bone_count=", class_raylib_modelanimation_set_boneCount, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_ModelAnimation, "frame_count", class_raylib_modelanimation_get_frameCount, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_ModelAnimation, "frame_count=", class_raylib_modelanimation_set_frameCount, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_ModelAnimation, "bones", class_raylib_modelanimation_get_bones, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_ModelAnimation, "bones=", class_raylib_modelanimation_set_bones, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_ModelAnimation, "frame_poses", class_raylib_modelanimation_get_framePoses, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_ModelAnimation, "frame_poses=", class_raylib_modelanimation_set_framePoses, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_ModelAnimation, "name", class_raylib_modelanimation_get_name, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_ModelAnimation, "name=", class_raylib_modelanimation_set_name, MRB_ARGS_REQ( 1 ) );
}
//----------------------------------------------------------------//


//----------------------------------------------------------------//
// Raylib::Ray
static struct RClass *class_Ray;

typedef struct class_raylib_ray_data_t {
	bool is_associated;
	Ray ray;
} class_raylib_ray_data_t;
		
static void
class_raylib_ray_data_free( mrb_state *mrb, void *p ) {
	class_raylib_ray_data_t *data = ( class_raylib_ray_data_t* )p;
	if ( NULL != data ) {
		mrb_free( mrb, data );
	}
}

static struct mrb_data_type const class_raylib_ray_data_type = {
	"Ray", class_raylib_ray_data_free
};

mrb_value
class_raylib_ray_2_mrbvalue( mrb_state *mrb, Ray *ray, bool is_associated ) {
	class_raylib_ray_data_t *data = ( class_raylib_ray_data_t* )mrb_malloc( mrb, sizeof( class_raylib_ray_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	data->is_associated = is_associated;
	data->ray = *ray;
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_Ray, &class_raylib_ray_data_type, data ) );
}

mrb_value
class_raylib_ray_2_mrbvalue_direct( mrb_state *mrb, Ray const *ray ) {
	class_raylib_ray_data_t *data = ( class_raylib_ray_data_t* )mrb_malloc( mrb, sizeof( class_raylib_ray_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	if ( NULL == ray ) {
		// Do init
	} else {
		// Do Copy
		data->ray = *ray;
	}
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_Ray, &class_raylib_ray_data_type, data ) );
}

Ray*
class_raylib_ray_get_ptr( mrb_state *mrb, mrb_value ray ) {
	class_raylib_ray_data_t *data;
	if ( mrb_nil_p( ray ) ) {
		return NULL;
	}
	data = ( class_raylib_ray_data_t* )mrb_data_get_ptr( mrb, ray, &class_raylib_ray_data_type );
	return &data->ray;
}

static mrb_value
class_raylib_ray_initialize( mrb_state *mrb, mrb_value self ) {
	class_raylib_ray_data_t *data = DATA_PTR( self );

	if ( NULL == data ) {
		data = mrb_malloc( mrb, sizeof( class_raylib_ray_data_t ) );
		if ( NULL == data ) {
			mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
		}
		//data->ray = { 0 };
	} else {
		// if ( NULL != &( data->ray ) ) {
		// 
		// }
	}
	Ray ray = { 0 };
	data->ray = ray;
	// if ( NULL == &( data->ray ) ) {
	//	mrb_free( mrb, data );
	// }
	DATA_PTR( self ) = data;
	DATA_TYPE( self ) = &class_raylib_ray_data_type;
	return self;
}

static mrb_value
class_raylib_ray_get_position( mrb_state *mrb, mrb_value self ) {
	return class_raylib_vector3_2_mrbvalue( mrb, &class_raylib_ray_get_ptr( mrb, self )->position, 0 );
}
	
static mrb_value
class_raylib_ray_set_position( mrb_state *mrb, mrb_value self ) {
	mrb_value param0;
	mrb_get_args( mrb, "o", &param0 );
	class_raylib_ray_get_ptr( mrb, self )->position = *class_raylib_vector3_get_ptr( mrb, param0 );
	return self;
}
	
static mrb_value
class_raylib_ray_get_direction( mrb_state *mrb, mrb_value self ) {
	return class_raylib_vector3_2_mrbvalue( mrb, &class_raylib_ray_get_ptr( mrb, self )->direction, 0 );
}
	
static mrb_value
class_raylib_ray_set_direction( mrb_state *mrb, mrb_value self ) {
	mrb_value param0;
	mrb_get_args( mrb, "o", &param0 );
	class_raylib_ray_get_ptr( mrb, self )->direction = *class_raylib_vector3_get_ptr( mrb, param0 );
	return self;
}
	
void
class_raylib_ray_init( mrb_state *mrb, struct RClass *mod_RayLib ) {
	class_Ray = mrb_define_class_under( mrb, mod_RayLib, "Ray", mrb->object_class );

	MRB_SET_INSTANCE_TT( class_Ray, MRB_TT_DATA );

	mrb_define_method( mrb, class_Ray, "initialize", class_raylib_ray_initialize, MRB_ARGS_NONE() );

	mrb_define_method( mrb, class_Ray, "position", class_raylib_ray_get_position, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Ray, "position=", class_raylib_ray_set_position, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Ray, "direction", class_raylib_ray_get_direction, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Ray, "direction=", class_raylib_ray_set_direction, MRB_ARGS_REQ( 1 ) );
}
//----------------------------------------------------------------//


//----------------------------------------------------------------//
// Raylib::RayCollision
static struct RClass *class_RayCollision;

typedef struct class_raylib_raycollision_data_t {
	bool is_associated;
	RayCollision raycollision;
} class_raylib_raycollision_data_t;
		
static void
class_raylib_raycollision_data_free( mrb_state *mrb, void *p ) {
	class_raylib_raycollision_data_t *data = ( class_raylib_raycollision_data_t* )p;
	if ( NULL != data ) {
		mrb_free( mrb, data );
	}
}

static struct mrb_data_type const class_raylib_raycollision_data_type = {
	"RayCollision", class_raylib_raycollision_data_free
};

mrb_value
class_raylib_raycollision_2_mrbvalue( mrb_state *mrb, RayCollision *raycollision, bool is_associated ) {
	class_raylib_raycollision_data_t *data = ( class_raylib_raycollision_data_t* )mrb_malloc( mrb, sizeof( class_raylib_raycollision_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	data->is_associated = is_associated;
	data->raycollision = *raycollision;
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_RayCollision, &class_raylib_raycollision_data_type, data ) );
}

mrb_value
class_raylib_raycollision_2_mrbvalue_direct( mrb_state *mrb, RayCollision const *raycollision ) {
	class_raylib_raycollision_data_t *data = ( class_raylib_raycollision_data_t* )mrb_malloc( mrb, sizeof( class_raylib_raycollision_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	if ( NULL == raycollision ) {
		// Do init
	} else {
		// Do Copy
		data->raycollision = *raycollision;
	}
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_RayCollision, &class_raylib_raycollision_data_type, data ) );
}

RayCollision*
class_raylib_raycollision_get_ptr( mrb_state *mrb, mrb_value raycollision ) {
	class_raylib_raycollision_data_t *data;
	if ( mrb_nil_p( raycollision ) ) {
		return NULL;
	}
	data = ( class_raylib_raycollision_data_t* )mrb_data_get_ptr( mrb, raycollision, &class_raylib_raycollision_data_type );
	return &data->raycollision;
}

static mrb_value
class_raylib_raycollision_initialize( mrb_state *mrb, mrb_value self ) {
	class_raylib_raycollision_data_t *data = DATA_PTR( self );

	if ( NULL == data ) {
		data = mrb_malloc( mrb, sizeof( class_raylib_raycollision_data_t ) );
		if ( NULL == data ) {
			mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
		}
		//data->raycollision = { 0 };
	} else {
		// if ( NULL != &( data->raycollision ) ) {
		// 
		// }
	}
	RayCollision raycollision = { 0 };
	data->raycollision = raycollision;
	// if ( NULL == &( data->raycollision ) ) {
	//	mrb_free( mrb, data );
	// }
	DATA_PTR( self ) = data;
	DATA_TYPE( self ) = &class_raylib_raycollision_data_type;
	return self;
}

static mrb_value
class_raylib_raycollision_get_hit( mrb_state *mrb, mrb_value self ) {
	return mrb_bool_value( class_raylib_raycollision_get_ptr( mrb, self )->hit );
}
	
static mrb_value
class_raylib_raycollision_set_hit( mrb_state *mrb, mrb_value self ) {
	mrb_bool param0;
	mrb_get_args( mrb, "b", &param0 );
	class_raylib_raycollision_get_ptr( mrb, self )->hit = param0;
	return self;
}
	
static mrb_value
class_raylib_raycollision_get_distance( mrb_state *mrb, mrb_value self ) {
	return mrb_float_value( mrb, class_raylib_raycollision_get_ptr( mrb, self )->distance );
}
	
static mrb_value
class_raylib_raycollision_set_distance( mrb_state *mrb, mrb_value self ) {
	mrb_float param0;
	mrb_get_args( mrb, "f", &param0 );
	class_raylib_raycollision_get_ptr( mrb, self )->distance = param0;
	return self;
}
	
static mrb_value
class_raylib_raycollision_get_point( mrb_state *mrb, mrb_value self ) {
	return class_raylib_vector3_2_mrbvalue( mrb, &class_raylib_raycollision_get_ptr( mrb, self )->point, 0 );
}
	
static mrb_value
class_raylib_raycollision_set_point( mrb_state *mrb, mrb_value self ) {
	mrb_value param0;
	mrb_get_args( mrb, "o", &param0 );
	class_raylib_raycollision_get_ptr( mrb, self )->point = *class_raylib_vector3_get_ptr( mrb, param0 );
	return self;
}
	
static mrb_value
class_raylib_raycollision_get_normal( mrb_state *mrb, mrb_value self ) {
	return class_raylib_vector3_2_mrbvalue( mrb, &class_raylib_raycollision_get_ptr( mrb, self )->normal, 0 );
}
	
static mrb_value
class_raylib_raycollision_set_normal( mrb_state *mrb, mrb_value self ) {
	mrb_value param0;
	mrb_get_args( mrb, "o", &param0 );
	class_raylib_raycollision_get_ptr( mrb, self )->normal = *class_raylib_vector3_get_ptr( mrb, param0 );
	return self;
}
	
void
class_raylib_raycollision_init( mrb_state *mrb, struct RClass *mod_RayLib ) {
	class_RayCollision = mrb_define_class_under( mrb, mod_RayLib, "RayCollision", mrb->object_class );

	MRB_SET_INSTANCE_TT( class_RayCollision, MRB_TT_DATA );

	mrb_define_method( mrb, class_RayCollision, "initialize", class_raylib_raycollision_initialize, MRB_ARGS_NONE() );

	mrb_define_method( mrb, class_RayCollision, "hit", class_raylib_raycollision_get_hit, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_RayCollision, "hit=", class_raylib_raycollision_set_hit, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_RayCollision, "distance", class_raylib_raycollision_get_distance, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_RayCollision, "distance=", class_raylib_raycollision_set_distance, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_RayCollision, "point", class_raylib_raycollision_get_point, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_RayCollision, "point=", class_raylib_raycollision_set_point, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_RayCollision, "normal", class_raylib_raycollision_get_normal, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_RayCollision, "normal=", class_raylib_raycollision_set_normal, MRB_ARGS_REQ( 1 ) );
}
//----------------------------------------------------------------//


//----------------------------------------------------------------//
// Raylib::BoundingBox
static struct RClass *class_BoundingBox;

typedef struct class_raylib_boundingbox_data_t {
	bool is_associated;
	BoundingBox boundingbox;
} class_raylib_boundingbox_data_t;
		
static void
class_raylib_boundingbox_data_free( mrb_state *mrb, void *p ) {
	class_raylib_boundingbox_data_t *data = ( class_raylib_boundingbox_data_t* )p;
	if ( NULL != data ) {
		mrb_free( mrb, data );
	}
}

static struct mrb_data_type const class_raylib_boundingbox_data_type = {
	"BoundingBox", class_raylib_boundingbox_data_free
};

mrb_value
class_raylib_boundingbox_2_mrbvalue( mrb_state *mrb, BoundingBox *boundingbox, bool is_associated ) {
	class_raylib_boundingbox_data_t *data = ( class_raylib_boundingbox_data_t* )mrb_malloc( mrb, sizeof( class_raylib_boundingbox_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	data->is_associated = is_associated;
	data->boundingbox = *boundingbox;
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_BoundingBox, &class_raylib_boundingbox_data_type, data ) );
}

mrb_value
class_raylib_boundingbox_2_mrbvalue_direct( mrb_state *mrb, BoundingBox const *boundingbox ) {
	class_raylib_boundingbox_data_t *data = ( class_raylib_boundingbox_data_t* )mrb_malloc( mrb, sizeof( class_raylib_boundingbox_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	if ( NULL == boundingbox ) {
		// Do init
	} else {
		// Do Copy
		data->boundingbox = *boundingbox;
	}
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_BoundingBox, &class_raylib_boundingbox_data_type, data ) );
}

BoundingBox*
class_raylib_boundingbox_get_ptr( mrb_state *mrb, mrb_value boundingbox ) {
	class_raylib_boundingbox_data_t *data;
	if ( mrb_nil_p( boundingbox ) ) {
		return NULL;
	}
	data = ( class_raylib_boundingbox_data_t* )mrb_data_get_ptr( mrb, boundingbox, &class_raylib_boundingbox_data_type );
	return &data->boundingbox;
}

static mrb_value
class_raylib_boundingbox_initialize( mrb_state *mrb, mrb_value self ) {
	class_raylib_boundingbox_data_t *data = DATA_PTR( self );

	if ( NULL == data ) {
		data = mrb_malloc( mrb, sizeof( class_raylib_boundingbox_data_t ) );
		if ( NULL == data ) {
			mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
		}
		//data->boundingbox = { 0 };
	} else {
		// if ( NULL != &( data->boundingbox ) ) {
		// 
		// }
	}
	BoundingBox boundingbox = { 0 };
	data->boundingbox = boundingbox;
	// if ( NULL == &( data->boundingbox ) ) {
	//	mrb_free( mrb, data );
	// }
	DATA_PTR( self ) = data;
	DATA_TYPE( self ) = &class_raylib_boundingbox_data_type;
	return self;
}

static mrb_value
class_raylib_boundingbox_get_min( mrb_state *mrb, mrb_value self ) {
	return class_raylib_vector3_2_mrbvalue( mrb, &class_raylib_boundingbox_get_ptr( mrb, self )->min, 0 );
}
	
static mrb_value
class_raylib_boundingbox_set_min( mrb_state *mrb, mrb_value self ) {
	mrb_value param0;
	mrb_get_args( mrb, "o", &param0 );
	class_raylib_boundingbox_get_ptr( mrb, self )->min = *class_raylib_vector3_get_ptr( mrb, param0 );
	return self;
}
	
static mrb_value
class_raylib_boundingbox_get_max( mrb_state *mrb, mrb_value self ) {
	return class_raylib_vector3_2_mrbvalue( mrb, &class_raylib_boundingbox_get_ptr( mrb, self )->max, 0 );
}
	
static mrb_value
class_raylib_boundingbox_set_max( mrb_state *mrb, mrb_value self ) {
	mrb_value param0;
	mrb_get_args( mrb, "o", &param0 );
	class_raylib_boundingbox_get_ptr( mrb, self )->max = *class_raylib_vector3_get_ptr( mrb, param0 );
	return self;
}
	
void
class_raylib_boundingbox_init( mrb_state *mrb, struct RClass *mod_RayLib ) {
	class_BoundingBox = mrb_define_class_under( mrb, mod_RayLib, "BoundingBox", mrb->object_class );

	MRB_SET_INSTANCE_TT( class_BoundingBox, MRB_TT_DATA );

	mrb_define_method( mrb, class_BoundingBox, "initialize", class_raylib_boundingbox_initialize, MRB_ARGS_NONE() );

	mrb_define_method( mrb, class_BoundingBox, "min", class_raylib_boundingbox_get_min, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_BoundingBox, "min=", class_raylib_boundingbox_set_min, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_BoundingBox, "max", class_raylib_boundingbox_get_max, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_BoundingBox, "max=", class_raylib_boundingbox_set_max, MRB_ARGS_REQ( 1 ) );
}
//----------------------------------------------------------------//


//----------------------------------------------------------------//
// Raylib::Wave
static struct RClass *class_Wave;

typedef struct class_raylib_wave_data_t {
	bool is_associated;
	Wave wave;
} class_raylib_wave_data_t;
		
static void
class_raylib_wave_data_free( mrb_state *mrb, void *p ) {
	class_raylib_wave_data_t *data = ( class_raylib_wave_data_t* )p;
	if ( NULL != data ) {
		mrb_free( mrb, data );
	}
}

static struct mrb_data_type const class_raylib_wave_data_type = {
	"Wave", class_raylib_wave_data_free
};

mrb_value
class_raylib_wave_2_mrbvalue( mrb_state *mrb, Wave *wave, bool is_associated ) {
	class_raylib_wave_data_t *data = ( class_raylib_wave_data_t* )mrb_malloc( mrb, sizeof( class_raylib_wave_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	data->is_associated = is_associated;
	data->wave = *wave;
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_Wave, &class_raylib_wave_data_type, data ) );
}

mrb_value
class_raylib_wave_2_mrbvalue_direct( mrb_state *mrb, Wave const *wave ) {
	class_raylib_wave_data_t *data = ( class_raylib_wave_data_t* )mrb_malloc( mrb, sizeof( class_raylib_wave_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	if ( NULL == wave ) {
		// Do init
	} else {
		// Do Copy
		data->wave = *wave;
	}
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_Wave, &class_raylib_wave_data_type, data ) );
}

Wave*
class_raylib_wave_get_ptr( mrb_state *mrb, mrb_value wave ) {
	class_raylib_wave_data_t *data;
	if ( mrb_nil_p( wave ) ) {
		return NULL;
	}
	data = ( class_raylib_wave_data_t* )mrb_data_get_ptr( mrb, wave, &class_raylib_wave_data_type );
	return &data->wave;
}

static mrb_value
class_raylib_wave_initialize( mrb_state *mrb, mrb_value self ) {
	class_raylib_wave_data_t *data = DATA_PTR( self );

	if ( NULL == data ) {
		data = mrb_malloc( mrb, sizeof( class_raylib_wave_data_t ) );
		if ( NULL == data ) {
			mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
		}
		//data->wave = { 0 };
	} else {
		// if ( NULL != &( data->wave ) ) {
		// 
		// }
	}
	Wave wave = { 0 };
	data->wave = wave;
	// if ( NULL == &( data->wave ) ) {
	//	mrb_free( mrb, data );
	// }
	DATA_PTR( self ) = data;
	DATA_TYPE( self ) = &class_raylib_wave_data_type;
	return self;
}

static mrb_value
class_raylib_wave_get_frameCount( mrb_state *mrb, mrb_value self ) {
	return mrb_fixnum_value( class_raylib_wave_get_ptr( mrb, self )->frameCount );
}
	
static mrb_value
class_raylib_wave_set_frameCount( mrb_state *mrb, mrb_value self ) {
	mrb_int param0;
	mrb_get_args( mrb, "i", &param0 );
	class_raylib_wave_get_ptr( mrb, self )->frameCount = param0;
	return self;
}
	
static mrb_value
class_raylib_wave_get_sampleRate( mrb_state *mrb, mrb_value self ) {
	return mrb_fixnum_value( class_raylib_wave_get_ptr( mrb, self )->sampleRate );
}
	
static mrb_value
class_raylib_wave_set_sampleRate( mrb_state *mrb, mrb_value self ) {
	mrb_int param0;
	mrb_get_args( mrb, "i", &param0 );
	class_raylib_wave_get_ptr( mrb, self )->sampleRate = param0;
	return self;
}
	
static mrb_value
class_raylib_wave_get_sampleSize( mrb_state *mrb, mrb_value self ) {
	return mrb_fixnum_value( class_raylib_wave_get_ptr( mrb, self )->sampleSize );
}
	
static mrb_value
class_raylib_wave_set_sampleSize( mrb_state *mrb, mrb_value self ) {
	mrb_int param0;
	mrb_get_args( mrb, "i", &param0 );
	class_raylib_wave_get_ptr( mrb, self )->sampleSize = param0;
	return self;
}
	
static mrb_value
class_raylib_wave_get_channels( mrb_state *mrb, mrb_value self ) {
	return mrb_fixnum_value( class_raylib_wave_get_ptr( mrb, self )->channels );
}
	
static mrb_value
class_raylib_wave_set_channels( mrb_state *mrb, mrb_value self ) {
	mrb_int param0;
	mrb_get_args( mrb, "i", &param0 );
	class_raylib_wave_get_ptr( mrb, self )->channels = param0;
	return self;
}
	
static mrb_value
class_raylib_wave_get_data( mrb_state *mrb, mrb_value self ) {
	return mrb_cptr_value( mrb, class_raylib_wave_get_ptr( mrb, self )->data );
}
	
static mrb_value
class_raylib_wave_set_data( mrb_state *mrb, mrb_value self ) {
	mrb_value param0;
	mrb_get_args( mrb, "d", &param0 );
	class_raylib_wave_get_ptr( mrb, self )->data = mrb_cptr( param0 );
	return self;
}
	
void
class_raylib_wave_init( mrb_state *mrb, struct RClass *mod_RayLib ) {
	class_Wave = mrb_define_class_under( mrb, mod_RayLib, "Wave", mrb->object_class );

	MRB_SET_INSTANCE_TT( class_Wave, MRB_TT_DATA );

	mrb_define_method( mrb, class_Wave, "initialize", class_raylib_wave_initialize, MRB_ARGS_NONE() );

	mrb_define_method( mrb, class_Wave, "frame_count", class_raylib_wave_get_frameCount, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Wave, "frame_count=", class_raylib_wave_set_frameCount, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Wave, "sample_rate", class_raylib_wave_get_sampleRate, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Wave, "sample_rate=", class_raylib_wave_set_sampleRate, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Wave, "sample_size", class_raylib_wave_get_sampleSize, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Wave, "sample_size=", class_raylib_wave_set_sampleSize, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Wave, "channels", class_raylib_wave_get_channels, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Wave, "channels=", class_raylib_wave_set_channels, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Wave, "data", class_raylib_wave_get_data, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Wave, "data=", class_raylib_wave_set_data, MRB_ARGS_REQ( 1 ) );
}
//----------------------------------------------------------------//


//----------------------------------------------------------------//
// Raylib::rAudioBuffer
static struct RClass *class_rAudioBuffer;

typedef struct class_raylib_raudiobuffer_data_t {
	bool is_associated;
	rAudioBuffer raudiobuffer;
} class_raylib_raudiobuffer_data_t;
		
static void
class_raylib_raudiobuffer_data_free( mrb_state *mrb, void *p ) {
	class_raylib_raudiobuffer_data_t *data = ( class_raylib_raudiobuffer_data_t* )p;
	if ( NULL != data ) {
		mrb_free( mrb, data );
	}
}

static struct mrb_data_type const class_raylib_raudiobuffer_data_type = {
	"rAudioBuffer", class_raylib_raudiobuffer_data_free
};

mrb_value
class_raylib_raudiobuffer_2_mrbvalue( mrb_state *mrb, rAudioBuffer *raudiobuffer, bool is_associated ) {
	class_raylib_raudiobuffer_data_t *data = ( class_raylib_raudiobuffer_data_t* )mrb_malloc( mrb, sizeof( class_raylib_raudiobuffer_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	data->is_associated = is_associated;
	data->raudiobuffer = *raudiobuffer;
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_rAudioBuffer, &class_raylib_raudiobuffer_data_type, data ) );
}

mrb_value
class_raylib_raudiobuffer_2_mrbvalue_direct( mrb_state *mrb, rAudioBuffer const *raudiobuffer ) {
	class_raylib_raudiobuffer_data_t *data = ( class_raylib_raudiobuffer_data_t* )mrb_malloc( mrb, sizeof( class_raylib_raudiobuffer_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	if ( NULL == raudiobuffer ) {
		// Do init
	} else {
		// Do Copy
		data->raudiobuffer = *raudiobuffer;
	}
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_rAudioBuffer, &class_raylib_raudiobuffer_data_type, data ) );
}

rAudioBuffer*
class_raylib_raudiobuffer_get_ptr( mrb_state *mrb, mrb_value raudiobuffer ) {
	class_raylib_raudiobuffer_data_t *data;
	if ( mrb_nil_p( raudiobuffer ) ) {
		return NULL;
	}
	data = ( class_raylib_raudiobuffer_data_t* )mrb_data_get_ptr( mrb, raudiobuffer, &class_raylib_raudiobuffer_data_type );
	return &data->raudiobuffer;
}

static mrb_value
class_raylib_raudiobuffer_initialize( mrb_state *mrb, mrb_value self ) {
	class_raylib_raudiobuffer_data_t *data = DATA_PTR( self );

	if ( NULL == data ) {
		data = mrb_malloc( mrb, sizeof( class_raylib_raudiobuffer_data_t ) );
		if ( NULL == data ) {
			mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
		}
		//data->raudiobuffer = { 0 };
	} else {
		// if ( NULL != &( data->raudiobuffer ) ) {
		// 
		// }
	}
	rAudioBuffer raudiobuffer = { 0 };
	data->raudiobuffer = raudiobuffer;
	// if ( NULL == &( data->raudiobuffer ) ) {
	//	mrb_free( mrb, data );
	// }
	DATA_PTR( self ) = data;
	DATA_TYPE( self ) = &class_raylib_raudiobuffer_data_type;
	return self;
}

void
class_raylib_raudiobuffer_init( mrb_state *mrb, struct RClass *mod_RayLib ) {
	class_rAudioBuffer = mrb_define_class_under( mrb, mod_RayLib, "rAudioBuffer", mrb->object_class );

	MRB_SET_INSTANCE_TT( class_rAudioBuffer, MRB_TT_DATA );

	mrb_define_method( mrb, class_rAudioBuffer, "initialize", class_raylib_raudiobuffer_initialize, MRB_ARGS_NONE() );

}
//----------------------------------------------------------------//


//----------------------------------------------------------------//
// Raylib::rAudioProcessor
static struct RClass *class_rAudioProcessor;

typedef struct class_raylib_raudioprocessor_data_t {
	bool is_associated;
	rAudioProcessor raudioprocessor;
} class_raylib_raudioprocessor_data_t;
		
static void
class_raylib_raudioprocessor_data_free( mrb_state *mrb, void *p ) {
	class_raylib_raudioprocessor_data_t *data = ( class_raylib_raudioprocessor_data_t* )p;
	if ( NULL != data ) {
		mrb_free( mrb, data );
	}
}

static struct mrb_data_type const class_raylib_raudioprocessor_data_type = {
	"rAudioProcessor", class_raylib_raudioprocessor_data_free
};

mrb_value
class_raylib_raudioprocessor_2_mrbvalue( mrb_state *mrb, rAudioProcessor *raudioprocessor, bool is_associated ) {
	class_raylib_raudioprocessor_data_t *data = ( class_raylib_raudioprocessor_data_t* )mrb_malloc( mrb, sizeof( class_raylib_raudioprocessor_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	data->is_associated = is_associated;
	data->raudioprocessor = *raudioprocessor;
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_rAudioProcessor, &class_raylib_raudioprocessor_data_type, data ) );
}

mrb_value
class_raylib_raudioprocessor_2_mrbvalue_direct( mrb_state *mrb, rAudioProcessor const *raudioprocessor ) {
	class_raylib_raudioprocessor_data_t *data = ( class_raylib_raudioprocessor_data_t* )mrb_malloc( mrb, sizeof( class_raylib_raudioprocessor_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	if ( NULL == raudioprocessor ) {
		// Do init
	} else {
		// Do Copy
		data->raudioprocessor = *raudioprocessor;
	}
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_rAudioProcessor, &class_raylib_raudioprocessor_data_type, data ) );
}

rAudioProcessor*
class_raylib_raudioprocessor_get_ptr( mrb_state *mrb, mrb_value raudioprocessor ) {
	class_raylib_raudioprocessor_data_t *data;
	if ( mrb_nil_p( raudioprocessor ) ) {
		return NULL;
	}
	data = ( class_raylib_raudioprocessor_data_t* )mrb_data_get_ptr( mrb, raudioprocessor, &class_raylib_raudioprocessor_data_type );
	return &data->raudioprocessor;
}

static mrb_value
class_raylib_raudioprocessor_initialize( mrb_state *mrb, mrb_value self ) {
	class_raylib_raudioprocessor_data_t *data = DATA_PTR( self );

	if ( NULL == data ) {
		data = mrb_malloc( mrb, sizeof( class_raylib_raudioprocessor_data_t ) );
		if ( NULL == data ) {
			mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
		}
		//data->raudioprocessor = { 0 };
	} else {
		// if ( NULL != &( data->raudioprocessor ) ) {
		// 
		// }
	}
	rAudioProcessor raudioprocessor = { 0 };
	data->raudioprocessor = raudioprocessor;
	// if ( NULL == &( data->raudioprocessor ) ) {
	//	mrb_free( mrb, data );
	// }
	DATA_PTR( self ) = data;
	DATA_TYPE( self ) = &class_raylib_raudioprocessor_data_type;
	return self;
}

void
class_raylib_raudioprocessor_init( mrb_state *mrb, struct RClass *mod_RayLib ) {
	class_rAudioProcessor = mrb_define_class_under( mrb, mod_RayLib, "rAudioProcessor", mrb->object_class );

	MRB_SET_INSTANCE_TT( class_rAudioProcessor, MRB_TT_DATA );

	mrb_define_method( mrb, class_rAudioProcessor, "initialize", class_raylib_raudioprocessor_initialize, MRB_ARGS_NONE() );

}
//----------------------------------------------------------------//


//----------------------------------------------------------------//
// Raylib::AudioStream
static struct RClass *class_AudioStream;

typedef struct class_raylib_audiostream_data_t {
	bool is_associated;
	AudioStream audiostream;
} class_raylib_audiostream_data_t;
		
static void
class_raylib_audiostream_data_free( mrb_state *mrb, void *p ) {
	class_raylib_audiostream_data_t *data = ( class_raylib_audiostream_data_t* )p;
	if ( NULL != data ) {
		mrb_free( mrb, data );
	}
}

static struct mrb_data_type const class_raylib_audiostream_data_type = {
	"AudioStream", class_raylib_audiostream_data_free
};

mrb_value
class_raylib_audiostream_2_mrbvalue( mrb_state *mrb, AudioStream *audiostream, bool is_associated ) {
	class_raylib_audiostream_data_t *data = ( class_raylib_audiostream_data_t* )mrb_malloc( mrb, sizeof( class_raylib_audiostream_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	data->is_associated = is_associated;
	data->audiostream = *audiostream;
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_AudioStream, &class_raylib_audiostream_data_type, data ) );
}

mrb_value
class_raylib_audiostream_2_mrbvalue_direct( mrb_state *mrb, AudioStream const *audiostream ) {
	class_raylib_audiostream_data_t *data = ( class_raylib_audiostream_data_t* )mrb_malloc( mrb, sizeof( class_raylib_audiostream_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	if ( NULL == audiostream ) {
		// Do init
	} else {
		// Do Copy
		data->audiostream = *audiostream;
	}
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_AudioStream, &class_raylib_audiostream_data_type, data ) );
}

AudioStream*
class_raylib_audiostream_get_ptr( mrb_state *mrb, mrb_value audiostream ) {
	class_raylib_audiostream_data_t *data;
	if ( mrb_nil_p( audiostream ) ) {
		return NULL;
	}
	data = ( class_raylib_audiostream_data_t* )mrb_data_get_ptr( mrb, audiostream, &class_raylib_audiostream_data_type );
	return &data->audiostream;
}

static mrb_value
class_raylib_audiostream_initialize( mrb_state *mrb, mrb_value self ) {
	class_raylib_audiostream_data_t *data = DATA_PTR( self );

	if ( NULL == data ) {
		data = mrb_malloc( mrb, sizeof( class_raylib_audiostream_data_t ) );
		if ( NULL == data ) {
			mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
		}
		//data->audiostream = { 0 };
	} else {
		// if ( NULL != &( data->audiostream ) ) {
		// 
		// }
	}
	AudioStream audiostream = { 0 };
	data->audiostream = audiostream;
	// if ( NULL == &( data->audiostream ) ) {
	//	mrb_free( mrb, data );
	// }
	DATA_PTR( self ) = data;
	DATA_TYPE( self ) = &class_raylib_audiostream_data_type;
	return self;
}

static mrb_value
class_raylib_audiostream_get_buffer( mrb_state *mrb, mrb_value self ) {
	return class_raylib_raudiobuffer_2_mrbvalue( mrb, class_raylib_audiostream_get_ptr( mrb, self )->buffer, 0 );
}
	
static mrb_value
class_raylib_audiostream_set_buffer( mrb_state *mrb, mrb_value self ) {
	mrb_value param0;
	mrb_get_args( mrb, "!d", &param0 );
	class_raylib_audiostream_get_ptr( mrb, self )->buffer = class_raylib_raudiobuffer_get_ptr( mrb, param0 );
	return self;
}
	
static mrb_value
class_raylib_audiostream_get_processor( mrb_state *mrb, mrb_value self ) {
	return class_raylib_raudioprocessor_2_mrbvalue( mrb, class_raylib_audiostream_get_ptr( mrb, self )->processor, 0 );
}
	
static mrb_value
class_raylib_audiostream_set_processor( mrb_state *mrb, mrb_value self ) {
	mrb_value param0;
	mrb_get_args( mrb, "!d", &param0 );
	class_raylib_audiostream_get_ptr( mrb, self )->processor = class_raylib_raudioprocessor_get_ptr( mrb, param0 );
	return self;
}
	
static mrb_value
class_raylib_audiostream_get_sampleRate( mrb_state *mrb, mrb_value self ) {
	return mrb_fixnum_value( class_raylib_audiostream_get_ptr( mrb, self )->sampleRate );
}
	
static mrb_value
class_raylib_audiostream_set_sampleRate( mrb_state *mrb, mrb_value self ) {
	mrb_int param0;
	mrb_get_args( mrb, "i", &param0 );
	class_raylib_audiostream_get_ptr( mrb, self )->sampleRate = param0;
	return self;
}
	
static mrb_value
class_raylib_audiostream_get_sampleSize( mrb_state *mrb, mrb_value self ) {
	return mrb_fixnum_value( class_raylib_audiostream_get_ptr( mrb, self )->sampleSize );
}
	
static mrb_value
class_raylib_audiostream_set_sampleSize( mrb_state *mrb, mrb_value self ) {
	mrb_int param0;
	mrb_get_args( mrb, "i", &param0 );
	class_raylib_audiostream_get_ptr( mrb, self )->sampleSize = param0;
	return self;
}
	
static mrb_value
class_raylib_audiostream_get_channels( mrb_state *mrb, mrb_value self ) {
	return mrb_fixnum_value( class_raylib_audiostream_get_ptr( mrb, self )->channels );
}
	
static mrb_value
class_raylib_audiostream_set_channels( mrb_state *mrb, mrb_value self ) {
	mrb_int param0;
	mrb_get_args( mrb, "i", &param0 );
	class_raylib_audiostream_get_ptr( mrb, self )->channels = param0;
	return self;
}
	
void
class_raylib_audiostream_init( mrb_state *mrb, struct RClass *mod_RayLib ) {
	class_AudioStream = mrb_define_class_under( mrb, mod_RayLib, "AudioStream", mrb->object_class );

	MRB_SET_INSTANCE_TT( class_AudioStream, MRB_TT_DATA );

	mrb_define_method( mrb, class_AudioStream, "initialize", class_raylib_audiostream_initialize, MRB_ARGS_NONE() );

	mrb_define_method( mrb, class_AudioStream, "buffer", class_raylib_audiostream_get_buffer, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_AudioStream, "buffer=", class_raylib_audiostream_set_buffer, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_AudioStream, "processor", class_raylib_audiostream_get_processor, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_AudioStream, "processor=", class_raylib_audiostream_set_processor, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_AudioStream, "sample_rate", class_raylib_audiostream_get_sampleRate, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_AudioStream, "sample_rate=", class_raylib_audiostream_set_sampleRate, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_AudioStream, "sample_size", class_raylib_audiostream_get_sampleSize, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_AudioStream, "sample_size=", class_raylib_audiostream_set_sampleSize, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_AudioStream, "channels", class_raylib_audiostream_get_channels, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_AudioStream, "channels=", class_raylib_audiostream_set_channels, MRB_ARGS_REQ( 1 ) );
}
//----------------------------------------------------------------//


//----------------------------------------------------------------//
// Raylib::Sound
static struct RClass *class_Sound;

typedef struct class_raylib_sound_data_t {
	bool is_associated;
	Sound sound;
} class_raylib_sound_data_t;
		
static void
class_raylib_sound_data_free( mrb_state *mrb, void *p ) {
	class_raylib_sound_data_t *data = ( class_raylib_sound_data_t* )p;
	if ( NULL != data ) {
		mrb_free( mrb, data );
	}
}

static struct mrb_data_type const class_raylib_sound_data_type = {
	"Sound", class_raylib_sound_data_free
};

mrb_value
class_raylib_sound_2_mrbvalue( mrb_state *mrb, Sound *sound, bool is_associated ) {
	class_raylib_sound_data_t *data = ( class_raylib_sound_data_t* )mrb_malloc( mrb, sizeof( class_raylib_sound_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	data->is_associated = is_associated;
	data->sound = *sound;
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_Sound, &class_raylib_sound_data_type, data ) );
}

mrb_value
class_raylib_sound_2_mrbvalue_direct( mrb_state *mrb, Sound const *sound ) {
	class_raylib_sound_data_t *data = ( class_raylib_sound_data_t* )mrb_malloc( mrb, sizeof( class_raylib_sound_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	if ( NULL == sound ) {
		// Do init
	} else {
		// Do Copy
		data->sound = *sound;
	}
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_Sound, &class_raylib_sound_data_type, data ) );
}

Sound*
class_raylib_sound_get_ptr( mrb_state *mrb, mrb_value sound ) {
	class_raylib_sound_data_t *data;
	if ( mrb_nil_p( sound ) ) {
		return NULL;
	}
	data = ( class_raylib_sound_data_t* )mrb_data_get_ptr( mrb, sound, &class_raylib_sound_data_type );
	return &data->sound;
}

static mrb_value
class_raylib_sound_initialize( mrb_state *mrb, mrb_value self ) {
	class_raylib_sound_data_t *data = DATA_PTR( self );

	if ( NULL == data ) {
		data = mrb_malloc( mrb, sizeof( class_raylib_sound_data_t ) );
		if ( NULL == data ) {
			mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
		}
		//data->sound = { 0 };
	} else {
		// if ( NULL != &( data->sound ) ) {
		// 
		// }
	}
	Sound sound = { 0 };
	data->sound = sound;
	// if ( NULL == &( data->sound ) ) {
	//	mrb_free( mrb, data );
	// }
	DATA_PTR( self ) = data;
	DATA_TYPE( self ) = &class_raylib_sound_data_type;
	return self;
}

static mrb_value
class_raylib_sound_get_stream( mrb_state *mrb, mrb_value self ) {
	return class_raylib_audiostream_2_mrbvalue( mrb, &class_raylib_sound_get_ptr( mrb, self )->stream, 0 );
}
	
static mrb_value
class_raylib_sound_set_stream( mrb_state *mrb, mrb_value self ) {
	mrb_value param0;
	mrb_get_args( mrb, "o", &param0 );
	class_raylib_sound_get_ptr( mrb, self )->stream = *class_raylib_audiostream_get_ptr( mrb, param0 );
	return self;
}
	
static mrb_value
class_raylib_sound_get_frameCount( mrb_state *mrb, mrb_value self ) {
	return mrb_fixnum_value( class_raylib_sound_get_ptr( mrb, self )->frameCount );
}
	
static mrb_value
class_raylib_sound_set_frameCount( mrb_state *mrb, mrb_value self ) {
	mrb_int param0;
	mrb_get_args( mrb, "i", &param0 );
	class_raylib_sound_get_ptr( mrb, self )->frameCount = param0;
	return self;
}
	
void
class_raylib_sound_init( mrb_state *mrb, struct RClass *mod_RayLib ) {
	class_Sound = mrb_define_class_under( mrb, mod_RayLib, "Sound", mrb->object_class );

	MRB_SET_INSTANCE_TT( class_Sound, MRB_TT_DATA );

	mrb_define_method( mrb, class_Sound, "initialize", class_raylib_sound_initialize, MRB_ARGS_NONE() );

	mrb_define_method( mrb, class_Sound, "stream", class_raylib_sound_get_stream, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Sound, "stream=", class_raylib_sound_set_stream, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Sound, "frame_count", class_raylib_sound_get_frameCount, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Sound, "frame_count=", class_raylib_sound_set_frameCount, MRB_ARGS_REQ( 1 ) );
}
//----------------------------------------------------------------//


//----------------------------------------------------------------//
// Raylib::Music
static struct RClass *class_Music;

typedef struct class_raylib_music_data_t {
	bool is_associated;
	Music music;
} class_raylib_music_data_t;
		
static void
class_raylib_music_data_free( mrb_state *mrb, void *p ) {
	class_raylib_music_data_t *data = ( class_raylib_music_data_t* )p;
	if ( NULL != data ) {
		mrb_free( mrb, data );
	}
}

static struct mrb_data_type const class_raylib_music_data_type = {
	"Music", class_raylib_music_data_free
};

mrb_value
class_raylib_music_2_mrbvalue( mrb_state *mrb, Music *music, bool is_associated ) {
	class_raylib_music_data_t *data = ( class_raylib_music_data_t* )mrb_malloc( mrb, sizeof( class_raylib_music_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	data->is_associated = is_associated;
	data->music = *music;
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_Music, &class_raylib_music_data_type, data ) );
}

mrb_value
class_raylib_music_2_mrbvalue_direct( mrb_state *mrb, Music const *music ) {
	class_raylib_music_data_t *data = ( class_raylib_music_data_t* )mrb_malloc( mrb, sizeof( class_raylib_music_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	if ( NULL == music ) {
		// Do init
	} else {
		// Do Copy
		data->music = *music;
	}
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_Music, &class_raylib_music_data_type, data ) );
}

Music*
class_raylib_music_get_ptr( mrb_state *mrb, mrb_value music ) {
	class_raylib_music_data_t *data;
	if ( mrb_nil_p( music ) ) {
		return NULL;
	}
	data = ( class_raylib_music_data_t* )mrb_data_get_ptr( mrb, music, &class_raylib_music_data_type );
	return &data->music;
}

static mrb_value
class_raylib_music_initialize( mrb_state *mrb, mrb_value self ) {
	class_raylib_music_data_t *data = DATA_PTR( self );

	if ( NULL == data ) {
		data = mrb_malloc( mrb, sizeof( class_raylib_music_data_t ) );
		if ( NULL == data ) {
			mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
		}
		//data->music = { 0 };
	} else {
		// if ( NULL != &( data->music ) ) {
		// 
		// }
	}
	Music music = { 0 };
	data->music = music;
	// if ( NULL == &( data->music ) ) {
	//	mrb_free( mrb, data );
	// }
	DATA_PTR( self ) = data;
	DATA_TYPE( self ) = &class_raylib_music_data_type;
	return self;
}

static mrb_value
class_raylib_music_get_stream( mrb_state *mrb, mrb_value self ) {
	return class_raylib_audiostream_2_mrbvalue( mrb, &class_raylib_music_get_ptr( mrb, self )->stream, 0 );
}
	
static mrb_value
class_raylib_music_set_stream( mrb_state *mrb, mrb_value self ) {
	mrb_value param0;
	mrb_get_args( mrb, "o", &param0 );
	class_raylib_music_get_ptr( mrb, self )->stream = *class_raylib_audiostream_get_ptr( mrb, param0 );
	return self;
}
	
static mrb_value
class_raylib_music_get_frameCount( mrb_state *mrb, mrb_value self ) {
	return mrb_fixnum_value( class_raylib_music_get_ptr( mrb, self )->frameCount );
}
	
static mrb_value
class_raylib_music_set_frameCount( mrb_state *mrb, mrb_value self ) {
	mrb_int param0;
	mrb_get_args( mrb, "i", &param0 );
	class_raylib_music_get_ptr( mrb, self )->frameCount = param0;
	return self;
}
	
static mrb_value
class_raylib_music_get_looping( mrb_state *mrb, mrb_value self ) {
	return mrb_bool_value( class_raylib_music_get_ptr( mrb, self )->looping );
}
	
static mrb_value
class_raylib_music_set_looping( mrb_state *mrb, mrb_value self ) {
	mrb_bool param0;
	mrb_get_args( mrb, "b", &param0 );
	class_raylib_music_get_ptr( mrb, self )->looping = param0;
	return self;
}
	
static mrb_value
class_raylib_music_get_ctxType( mrb_state *mrb, mrb_value self ) {
	return mrb_fixnum_value( class_raylib_music_get_ptr( mrb, self )->ctxType );
}
	
static mrb_value
class_raylib_music_set_ctxType( mrb_state *mrb, mrb_value self ) {
	mrb_int param0;
	mrb_get_args( mrb, "i", &param0 );
	class_raylib_music_get_ptr( mrb, self )->ctxType = param0;
	return self;
}
	
static mrb_value
class_raylib_music_get_ctxData( mrb_state *mrb, mrb_value self ) {
	return mrb_cptr_value( mrb, class_raylib_music_get_ptr( mrb, self )->ctxData );
}
	
static mrb_value
class_raylib_music_set_ctxData( mrb_state *mrb, mrb_value self ) {
	mrb_value param0;
	mrb_get_args( mrb, "d", &param0 );
	class_raylib_music_get_ptr( mrb, self )->ctxData = mrb_cptr( param0 );
	return self;
}
	
void
class_raylib_music_init( mrb_state *mrb, struct RClass *mod_RayLib ) {
	class_Music = mrb_define_class_under( mrb, mod_RayLib, "Music", mrb->object_class );

	MRB_SET_INSTANCE_TT( class_Music, MRB_TT_DATA );

	mrb_define_method( mrb, class_Music, "initialize", class_raylib_music_initialize, MRB_ARGS_NONE() );

	mrb_define_method( mrb, class_Music, "stream", class_raylib_music_get_stream, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Music, "stream=", class_raylib_music_set_stream, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Music, "frame_count", class_raylib_music_get_frameCount, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Music, "frame_count=", class_raylib_music_set_frameCount, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Music, "looping", class_raylib_music_get_looping, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Music, "looping=", class_raylib_music_set_looping, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Music, "ctx_type", class_raylib_music_get_ctxType, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Music, "ctx_type=", class_raylib_music_set_ctxType, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_Music, "ctx_data", class_raylib_music_get_ctxData, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_Music, "ctx_data=", class_raylib_music_set_ctxData, MRB_ARGS_REQ( 1 ) );
}
//----------------------------------------------------------------//


//----------------------------------------------------------------//
// Raylib::VrDeviceInfo
static struct RClass *class_VrDeviceInfo;

typedef struct class_raylib_vrdeviceinfo_data_t {
	bool is_associated;
	VrDeviceInfo vrdeviceinfo;
} class_raylib_vrdeviceinfo_data_t;
		
static void
class_raylib_vrdeviceinfo_data_free( mrb_state *mrb, void *p ) {
	class_raylib_vrdeviceinfo_data_t *data = ( class_raylib_vrdeviceinfo_data_t* )p;
	if ( NULL != data ) {
		mrb_free( mrb, data );
	}
}

static struct mrb_data_type const class_raylib_vrdeviceinfo_data_type = {
	"VrDeviceInfo", class_raylib_vrdeviceinfo_data_free
};

mrb_value
class_raylib_vrdeviceinfo_2_mrbvalue( mrb_state *mrb, VrDeviceInfo *vrdeviceinfo, bool is_associated ) {
	class_raylib_vrdeviceinfo_data_t *data = ( class_raylib_vrdeviceinfo_data_t* )mrb_malloc( mrb, sizeof( class_raylib_vrdeviceinfo_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	data->is_associated = is_associated;
	data->vrdeviceinfo = *vrdeviceinfo;
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_VrDeviceInfo, &class_raylib_vrdeviceinfo_data_type, data ) );
}

mrb_value
class_raylib_vrdeviceinfo_2_mrbvalue_direct( mrb_state *mrb, VrDeviceInfo const *vrdeviceinfo ) {
	class_raylib_vrdeviceinfo_data_t *data = ( class_raylib_vrdeviceinfo_data_t* )mrb_malloc( mrb, sizeof( class_raylib_vrdeviceinfo_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	if ( NULL == vrdeviceinfo ) {
		// Do init
	} else {
		// Do Copy
		data->vrdeviceinfo = *vrdeviceinfo;
	}
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_VrDeviceInfo, &class_raylib_vrdeviceinfo_data_type, data ) );
}

VrDeviceInfo*
class_raylib_vrdeviceinfo_get_ptr( mrb_state *mrb, mrb_value vrdeviceinfo ) {
	class_raylib_vrdeviceinfo_data_t *data;
	if ( mrb_nil_p( vrdeviceinfo ) ) {
		return NULL;
	}
	data = ( class_raylib_vrdeviceinfo_data_t* )mrb_data_get_ptr( mrb, vrdeviceinfo, &class_raylib_vrdeviceinfo_data_type );
	return &data->vrdeviceinfo;
}

static mrb_value
class_raylib_vrdeviceinfo_initialize( mrb_state *mrb, mrb_value self ) {
	class_raylib_vrdeviceinfo_data_t *data = DATA_PTR( self );

	if ( NULL == data ) {
		data = mrb_malloc( mrb, sizeof( class_raylib_vrdeviceinfo_data_t ) );
		if ( NULL == data ) {
			mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
		}
		//data->vrdeviceinfo = { 0 };
	} else {
		// if ( NULL != &( data->vrdeviceinfo ) ) {
		// 
		// }
	}
	VrDeviceInfo vrdeviceinfo = { 0 };
	data->vrdeviceinfo = vrdeviceinfo;
	// if ( NULL == &( data->vrdeviceinfo ) ) {
	//	mrb_free( mrb, data );
	// }
	DATA_PTR( self ) = data;
	DATA_TYPE( self ) = &class_raylib_vrdeviceinfo_data_type;
	return self;
}

static mrb_value
class_raylib_vrdeviceinfo_get_hResolution( mrb_state *mrb, mrb_value self ) {
	return mrb_fixnum_value( class_raylib_vrdeviceinfo_get_ptr( mrb, self )->hResolution );
}
	
static mrb_value
class_raylib_vrdeviceinfo_set_hResolution( mrb_state *mrb, mrb_value self ) {
	mrb_int param0;
	mrb_get_args( mrb, "i", &param0 );
	class_raylib_vrdeviceinfo_get_ptr( mrb, self )->hResolution = param0;
	return self;
}
	
static mrb_value
class_raylib_vrdeviceinfo_get_vResolution( mrb_state *mrb, mrb_value self ) {
	return mrb_fixnum_value( class_raylib_vrdeviceinfo_get_ptr( mrb, self )->vResolution );
}
	
static mrb_value
class_raylib_vrdeviceinfo_set_vResolution( mrb_state *mrb, mrb_value self ) {
	mrb_int param0;
	mrb_get_args( mrb, "i", &param0 );
	class_raylib_vrdeviceinfo_get_ptr( mrb, self )->vResolution = param0;
	return self;
}
	
static mrb_value
class_raylib_vrdeviceinfo_get_hScreenSize( mrb_state *mrb, mrb_value self ) {
	return mrb_float_value( mrb, class_raylib_vrdeviceinfo_get_ptr( mrb, self )->hScreenSize );
}
	
static mrb_value
class_raylib_vrdeviceinfo_set_hScreenSize( mrb_state *mrb, mrb_value self ) {
	mrb_float param0;
	mrb_get_args( mrb, "f", &param0 );
	class_raylib_vrdeviceinfo_get_ptr( mrb, self )->hScreenSize = param0;
	return self;
}
	
static mrb_value
class_raylib_vrdeviceinfo_get_vScreenSize( mrb_state *mrb, mrb_value self ) {
	return mrb_float_value( mrb, class_raylib_vrdeviceinfo_get_ptr( mrb, self )->vScreenSize );
}
	
static mrb_value
class_raylib_vrdeviceinfo_set_vScreenSize( mrb_state *mrb, mrb_value self ) {
	mrb_float param0;
	mrb_get_args( mrb, "f", &param0 );
	class_raylib_vrdeviceinfo_get_ptr( mrb, self )->vScreenSize = param0;
	return self;
}
	
static mrb_value
class_raylib_vrdeviceinfo_get_vScreenCenter( mrb_state *mrb, mrb_value self ) {
	return mrb_float_value( mrb, class_raylib_vrdeviceinfo_get_ptr( mrb, self )->vScreenCenter );
}
	
static mrb_value
class_raylib_vrdeviceinfo_set_vScreenCenter( mrb_state *mrb, mrb_value self ) {
	mrb_float param0;
	mrb_get_args( mrb, "f", &param0 );
	class_raylib_vrdeviceinfo_get_ptr( mrb, self )->vScreenCenter = param0;
	return self;
}
	
static mrb_value
class_raylib_vrdeviceinfo_get_eyeToScreenDistance( mrb_state *mrb, mrb_value self ) {
	return mrb_float_value( mrb, class_raylib_vrdeviceinfo_get_ptr( mrb, self )->eyeToScreenDistance );
}
	
static mrb_value
class_raylib_vrdeviceinfo_set_eyeToScreenDistance( mrb_state *mrb, mrb_value self ) {
	mrb_float param0;
	mrb_get_args( mrb, "f", &param0 );
	class_raylib_vrdeviceinfo_get_ptr( mrb, self )->eyeToScreenDistance = param0;
	return self;
}
	
static mrb_value
class_raylib_vrdeviceinfo_get_lensSeparationDistance( mrb_state *mrb, mrb_value self ) {
	return mrb_float_value( mrb, class_raylib_vrdeviceinfo_get_ptr( mrb, self )->lensSeparationDistance );
}
	
static mrb_value
class_raylib_vrdeviceinfo_set_lensSeparationDistance( mrb_state *mrb, mrb_value self ) {
	mrb_float param0;
	mrb_get_args( mrb, "f", &param0 );
	class_raylib_vrdeviceinfo_get_ptr( mrb, self )->lensSeparationDistance = param0;
	return self;
}
	
static mrb_value
class_raylib_vrdeviceinfo_get_interpupillaryDistance( mrb_state *mrb, mrb_value self ) {
	return mrb_float_value( mrb, class_raylib_vrdeviceinfo_get_ptr( mrb, self )->interpupillaryDistance );
}
	
static mrb_value
class_raylib_vrdeviceinfo_set_interpupillaryDistance( mrb_state *mrb, mrb_value self ) {
	mrb_float param0;
	mrb_get_args( mrb, "f", &param0 );
	class_raylib_vrdeviceinfo_get_ptr( mrb, self )->interpupillaryDistance = param0;
	return self;
}
	
static mrb_value
class_raylib_vrdeviceinfo_get_lensDistortionValues( mrb_state *mrb, mrb_value self ) {
	mrb_value arr = mrb_ary_new( mrb );
mrb_ary_push( mrb, arr, mrb_float_value( mrb, class_raylib_vrdeviceinfo_get_ptr( mrb, self )->lensDistortionValues[ 0 ] ) );
mrb_ary_push( mrb, arr, mrb_float_value( mrb, class_raylib_vrdeviceinfo_get_ptr( mrb, self )->lensDistortionValues[ 1 ] ) );
mrb_ary_push( mrb, arr, mrb_float_value( mrb, class_raylib_vrdeviceinfo_get_ptr( mrb, self )->lensDistortionValues[ 2 ] ) );
mrb_ary_push( mrb, arr, mrb_float_value( mrb, class_raylib_vrdeviceinfo_get_ptr( mrb, self )->lensDistortionValues[ 3 ] ) );
return arr;
}
	
static mrb_value
class_raylib_vrdeviceinfo_set_lensDistortionValues( mrb_state *mrb, mrb_value self ) {
	// TODO: set lensDistortionValues
	return self;
}
	
static mrb_value
class_raylib_vrdeviceinfo_get_chromaAbCorrection( mrb_state *mrb, mrb_value self ) {
	mrb_value arr = mrb_ary_new( mrb );
mrb_ary_push( mrb, arr, mrb_float_value( mrb, class_raylib_vrdeviceinfo_get_ptr( mrb, self )->chromaAbCorrection[ 0 ] ) );
mrb_ary_push( mrb, arr, mrb_float_value( mrb, class_raylib_vrdeviceinfo_get_ptr( mrb, self )->chromaAbCorrection[ 1 ] ) );
mrb_ary_push( mrb, arr, mrb_float_value( mrb, class_raylib_vrdeviceinfo_get_ptr( mrb, self )->chromaAbCorrection[ 2 ] ) );
mrb_ary_push( mrb, arr, mrb_float_value( mrb, class_raylib_vrdeviceinfo_get_ptr( mrb, self )->chromaAbCorrection[ 3 ] ) );
return arr;
}
	
static mrb_value
class_raylib_vrdeviceinfo_set_chromaAbCorrection( mrb_state *mrb, mrb_value self ) {
	// TODO: set chromaAbCorrection
	return self;
}
	
void
class_raylib_vrdeviceinfo_init( mrb_state *mrb, struct RClass *mod_RayLib ) {
	class_VrDeviceInfo = mrb_define_class_under( mrb, mod_RayLib, "VrDeviceInfo", mrb->object_class );

	MRB_SET_INSTANCE_TT( class_VrDeviceInfo, MRB_TT_DATA );

	mrb_define_method( mrb, class_VrDeviceInfo, "initialize", class_raylib_vrdeviceinfo_initialize, MRB_ARGS_NONE() );

	mrb_define_method( mrb, class_VrDeviceInfo, "h_resolution", class_raylib_vrdeviceinfo_get_hResolution, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_VrDeviceInfo, "h_resolution=", class_raylib_vrdeviceinfo_set_hResolution, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_VrDeviceInfo, "v_resolution", class_raylib_vrdeviceinfo_get_vResolution, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_VrDeviceInfo, "v_resolution=", class_raylib_vrdeviceinfo_set_vResolution, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_VrDeviceInfo, "h_screen_size", class_raylib_vrdeviceinfo_get_hScreenSize, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_VrDeviceInfo, "h_screen_size=", class_raylib_vrdeviceinfo_set_hScreenSize, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_VrDeviceInfo, "v_screen_size", class_raylib_vrdeviceinfo_get_vScreenSize, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_VrDeviceInfo, "v_screen_size=", class_raylib_vrdeviceinfo_set_vScreenSize, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_VrDeviceInfo, "v_screen_center", class_raylib_vrdeviceinfo_get_vScreenCenter, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_VrDeviceInfo, "v_screen_center=", class_raylib_vrdeviceinfo_set_vScreenCenter, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_VrDeviceInfo, "eye_to_screen_distance", class_raylib_vrdeviceinfo_get_eyeToScreenDistance, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_VrDeviceInfo, "eye_to_screen_distance=", class_raylib_vrdeviceinfo_set_eyeToScreenDistance, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_VrDeviceInfo, "lens_separation_distance", class_raylib_vrdeviceinfo_get_lensSeparationDistance, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_VrDeviceInfo, "lens_separation_distance=", class_raylib_vrdeviceinfo_set_lensSeparationDistance, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_VrDeviceInfo, "interpupillary_distance", class_raylib_vrdeviceinfo_get_interpupillaryDistance, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_VrDeviceInfo, "interpupillary_distance=", class_raylib_vrdeviceinfo_set_interpupillaryDistance, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_VrDeviceInfo, "lens_distortion_values", class_raylib_vrdeviceinfo_get_lensDistortionValues, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_VrDeviceInfo, "lens_distortion_values=", class_raylib_vrdeviceinfo_set_lensDistortionValues, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_VrDeviceInfo, "chroma_ab_correction", class_raylib_vrdeviceinfo_get_chromaAbCorrection, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_VrDeviceInfo, "chroma_ab_correction=", class_raylib_vrdeviceinfo_set_chromaAbCorrection, MRB_ARGS_REQ( 1 ) );
}
//----------------------------------------------------------------//


//----------------------------------------------------------------//
// Raylib::VrStereoConfig
static struct RClass *class_VrStereoConfig;

typedef struct class_raylib_vrstereoconfig_data_t {
	bool is_associated;
	VrStereoConfig vrstereoconfig;
} class_raylib_vrstereoconfig_data_t;
		
static void
class_raylib_vrstereoconfig_data_free( mrb_state *mrb, void *p ) {
	class_raylib_vrstereoconfig_data_t *data = ( class_raylib_vrstereoconfig_data_t* )p;
	if ( NULL != data ) {
		mrb_free( mrb, data );
	}
}

static struct mrb_data_type const class_raylib_vrstereoconfig_data_type = {
	"VrStereoConfig", class_raylib_vrstereoconfig_data_free
};

mrb_value
class_raylib_vrstereoconfig_2_mrbvalue( mrb_state *mrb, VrStereoConfig *vrstereoconfig, bool is_associated ) {
	class_raylib_vrstereoconfig_data_t *data = ( class_raylib_vrstereoconfig_data_t* )mrb_malloc( mrb, sizeof( class_raylib_vrstereoconfig_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	data->is_associated = is_associated;
	data->vrstereoconfig = *vrstereoconfig;
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_VrStereoConfig, &class_raylib_vrstereoconfig_data_type, data ) );
}

mrb_value
class_raylib_vrstereoconfig_2_mrbvalue_direct( mrb_state *mrb, VrStereoConfig const *vrstereoconfig ) {
	class_raylib_vrstereoconfig_data_t *data = ( class_raylib_vrstereoconfig_data_t* )mrb_malloc( mrb, sizeof( class_raylib_vrstereoconfig_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	if ( NULL == vrstereoconfig ) {
		// Do init
	} else {
		// Do Copy
		data->vrstereoconfig = *vrstereoconfig;
	}
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_VrStereoConfig, &class_raylib_vrstereoconfig_data_type, data ) );
}

VrStereoConfig*
class_raylib_vrstereoconfig_get_ptr( mrb_state *mrb, mrb_value vrstereoconfig ) {
	class_raylib_vrstereoconfig_data_t *data;
	if ( mrb_nil_p( vrstereoconfig ) ) {
		return NULL;
	}
	data = ( class_raylib_vrstereoconfig_data_t* )mrb_data_get_ptr( mrb, vrstereoconfig, &class_raylib_vrstereoconfig_data_type );
	return &data->vrstereoconfig;
}

static mrb_value
class_raylib_vrstereoconfig_initialize( mrb_state *mrb, mrb_value self ) {
	class_raylib_vrstereoconfig_data_t *data = DATA_PTR( self );

	if ( NULL == data ) {
		data = mrb_malloc( mrb, sizeof( class_raylib_vrstereoconfig_data_t ) );
		if ( NULL == data ) {
			mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
		}
		//data->vrstereoconfig = { 0 };
	} else {
		// if ( NULL != &( data->vrstereoconfig ) ) {
		// 
		// }
	}
	VrStereoConfig vrstereoconfig = { 0 };
	data->vrstereoconfig = vrstereoconfig;
	// if ( NULL == &( data->vrstereoconfig ) ) {
	//	mrb_free( mrb, data );
	// }
	DATA_PTR( self ) = data;
	DATA_TYPE( self ) = &class_raylib_vrstereoconfig_data_type;
	return self;
}

static mrb_value
class_raylib_vrstereoconfig_get_projection( mrb_state *mrb, mrb_value self ) {
	mrb_value arr = mrb_ary_new( mrb );
mrb_ary_push( mrb, arr, class_raylib_matrix_2_mrbvalue( mrb, &class_raylib_vrstereoconfig_get_ptr( mrb, self )->projection[ 0 ], 0 ) );
mrb_ary_push( mrb, arr, class_raylib_matrix_2_mrbvalue( mrb, &class_raylib_vrstereoconfig_get_ptr( mrb, self )->projection[ 1 ], 0 ) );
return arr;
}
	
static mrb_value
class_raylib_vrstereoconfig_set_projection( mrb_state *mrb, mrb_value self ) {
	// TODO: set projection
	return self;
}
	
static mrb_value
class_raylib_vrstereoconfig_get_viewOffset( mrb_state *mrb, mrb_value self ) {
	mrb_value arr = mrb_ary_new( mrb );
mrb_ary_push( mrb, arr, class_raylib_matrix_2_mrbvalue( mrb, &class_raylib_vrstereoconfig_get_ptr( mrb, self )->viewOffset[ 0 ], 0 ) );
mrb_ary_push( mrb, arr, class_raylib_matrix_2_mrbvalue( mrb, &class_raylib_vrstereoconfig_get_ptr( mrb, self )->viewOffset[ 1 ], 0 ) );
return arr;
}
	
static mrb_value
class_raylib_vrstereoconfig_set_viewOffset( mrb_state *mrb, mrb_value self ) {
	// TODO: set viewOffset
	return self;
}
	
static mrb_value
class_raylib_vrstereoconfig_get_leftLensCenter( mrb_state *mrb, mrb_value self ) {
	mrb_value arr = mrb_ary_new( mrb );
mrb_ary_push( mrb, arr, mrb_float_value( mrb, class_raylib_vrstereoconfig_get_ptr( mrb, self )->leftLensCenter[ 0 ] ) );
mrb_ary_push( mrb, arr, mrb_float_value( mrb, class_raylib_vrstereoconfig_get_ptr( mrb, self )->leftLensCenter[ 1 ] ) );
return arr;
}
	
static mrb_value
class_raylib_vrstereoconfig_set_leftLensCenter( mrb_state *mrb, mrb_value self ) {
	// TODO: set leftLensCenter
	return self;
}
	
static mrb_value
class_raylib_vrstereoconfig_get_rightLensCenter( mrb_state *mrb, mrb_value self ) {
	mrb_value arr = mrb_ary_new( mrb );
mrb_ary_push( mrb, arr, mrb_float_value( mrb, class_raylib_vrstereoconfig_get_ptr( mrb, self )->rightLensCenter[ 0 ] ) );
mrb_ary_push( mrb, arr, mrb_float_value( mrb, class_raylib_vrstereoconfig_get_ptr( mrb, self )->rightLensCenter[ 1 ] ) );
return arr;
}
	
static mrb_value
class_raylib_vrstereoconfig_set_rightLensCenter( mrb_state *mrb, mrb_value self ) {
	// TODO: set rightLensCenter
	return self;
}
	
static mrb_value
class_raylib_vrstereoconfig_get_leftScreenCenter( mrb_state *mrb, mrb_value self ) {
	mrb_value arr = mrb_ary_new( mrb );
mrb_ary_push( mrb, arr, mrb_float_value( mrb, class_raylib_vrstereoconfig_get_ptr( mrb, self )->leftScreenCenter[ 0 ] ) );
mrb_ary_push( mrb, arr, mrb_float_value( mrb, class_raylib_vrstereoconfig_get_ptr( mrb, self )->leftScreenCenter[ 1 ] ) );
return arr;
}
	
static mrb_value
class_raylib_vrstereoconfig_set_leftScreenCenter( mrb_state *mrb, mrb_value self ) {
	// TODO: set leftScreenCenter
	return self;
}
	
static mrb_value
class_raylib_vrstereoconfig_get_rightScreenCenter( mrb_state *mrb, mrb_value self ) {
	mrb_value arr = mrb_ary_new( mrb );
mrb_ary_push( mrb, arr, mrb_float_value( mrb, class_raylib_vrstereoconfig_get_ptr( mrb, self )->rightScreenCenter[ 0 ] ) );
mrb_ary_push( mrb, arr, mrb_float_value( mrb, class_raylib_vrstereoconfig_get_ptr( mrb, self )->rightScreenCenter[ 1 ] ) );
return arr;
}
	
static mrb_value
class_raylib_vrstereoconfig_set_rightScreenCenter( mrb_state *mrb, mrb_value self ) {
	// TODO: set rightScreenCenter
	return self;
}
	
static mrb_value
class_raylib_vrstereoconfig_get_scale( mrb_state *mrb, mrb_value self ) {
	mrb_value arr = mrb_ary_new( mrb );
mrb_ary_push( mrb, arr, mrb_float_value( mrb, class_raylib_vrstereoconfig_get_ptr( mrb, self )->scale[ 0 ] ) );
mrb_ary_push( mrb, arr, mrb_float_value( mrb, class_raylib_vrstereoconfig_get_ptr( mrb, self )->scale[ 1 ] ) );
return arr;
}
	
static mrb_value
class_raylib_vrstereoconfig_set_scale( mrb_state *mrb, mrb_value self ) {
	// TODO: set scale
	return self;
}
	
static mrb_value
class_raylib_vrstereoconfig_get_scaleIn( mrb_state *mrb, mrb_value self ) {
	mrb_value arr = mrb_ary_new( mrb );
mrb_ary_push( mrb, arr, mrb_float_value( mrb, class_raylib_vrstereoconfig_get_ptr( mrb, self )->scaleIn[ 0 ] ) );
mrb_ary_push( mrb, arr, mrb_float_value( mrb, class_raylib_vrstereoconfig_get_ptr( mrb, self )->scaleIn[ 1 ] ) );
return arr;
}
	
static mrb_value
class_raylib_vrstereoconfig_set_scaleIn( mrb_state *mrb, mrb_value self ) {
	// TODO: set scaleIn
	return self;
}
	
void
class_raylib_vrstereoconfig_init( mrb_state *mrb, struct RClass *mod_RayLib ) {
	class_VrStereoConfig = mrb_define_class_under( mrb, mod_RayLib, "VrStereoConfig", mrb->object_class );

	MRB_SET_INSTANCE_TT( class_VrStereoConfig, MRB_TT_DATA );

	mrb_define_method( mrb, class_VrStereoConfig, "initialize", class_raylib_vrstereoconfig_initialize, MRB_ARGS_NONE() );

	mrb_define_method( mrb, class_VrStereoConfig, "projection", class_raylib_vrstereoconfig_get_projection, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_VrStereoConfig, "projection=", class_raylib_vrstereoconfig_set_projection, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_VrStereoConfig, "view_offset", class_raylib_vrstereoconfig_get_viewOffset, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_VrStereoConfig, "view_offset=", class_raylib_vrstereoconfig_set_viewOffset, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_VrStereoConfig, "left_lens_center", class_raylib_vrstereoconfig_get_leftLensCenter, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_VrStereoConfig, "left_lens_center=", class_raylib_vrstereoconfig_set_leftLensCenter, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_VrStereoConfig, "right_lens_center", class_raylib_vrstereoconfig_get_rightLensCenter, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_VrStereoConfig, "right_lens_center=", class_raylib_vrstereoconfig_set_rightLensCenter, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_VrStereoConfig, "left_screen_center", class_raylib_vrstereoconfig_get_leftScreenCenter, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_VrStereoConfig, "left_screen_center=", class_raylib_vrstereoconfig_set_leftScreenCenter, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_VrStereoConfig, "right_screen_center", class_raylib_vrstereoconfig_get_rightScreenCenter, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_VrStereoConfig, "right_screen_center=", class_raylib_vrstereoconfig_set_rightScreenCenter, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_VrStereoConfig, "scale", class_raylib_vrstereoconfig_get_scale, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_VrStereoConfig, "scale=", class_raylib_vrstereoconfig_set_scale, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_VrStereoConfig, "scale_in", class_raylib_vrstereoconfig_get_scaleIn, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_VrStereoConfig, "scale_in=", class_raylib_vrstereoconfig_set_scaleIn, MRB_ARGS_REQ( 1 ) );
}
//----------------------------------------------------------------//


//----------------------------------------------------------------//
// Raylib::FilePathList
static struct RClass *class_FilePathList;

typedef struct class_raylib_filepathlist_data_t {
	bool is_associated;
	FilePathList filepathlist;
} class_raylib_filepathlist_data_t;
		
static void
class_raylib_filepathlist_data_free( mrb_state *mrb, void *p ) {
	class_raylib_filepathlist_data_t *data = ( class_raylib_filepathlist_data_t* )p;
	if ( NULL != data ) {
		mrb_free( mrb, data );
	}
}

static struct mrb_data_type const class_raylib_filepathlist_data_type = {
	"FilePathList", class_raylib_filepathlist_data_free
};

mrb_value
class_raylib_filepathlist_2_mrbvalue( mrb_state *mrb, FilePathList *filepathlist, bool is_associated ) {
	class_raylib_filepathlist_data_t *data = ( class_raylib_filepathlist_data_t* )mrb_malloc( mrb, sizeof( class_raylib_filepathlist_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	data->is_associated = is_associated;
	data->filepathlist = *filepathlist;
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_FilePathList, &class_raylib_filepathlist_data_type, data ) );
}

mrb_value
class_raylib_filepathlist_2_mrbvalue_direct( mrb_state *mrb, FilePathList const *filepathlist ) {
	class_raylib_filepathlist_data_t *data = ( class_raylib_filepathlist_data_t* )mrb_malloc( mrb, sizeof( class_raylib_filepathlist_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	if ( NULL == filepathlist ) {
		// Do init
	} else {
		// Do Copy
		data->filepathlist = *filepathlist;
	}
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_FilePathList, &class_raylib_filepathlist_data_type, data ) );
}

FilePathList*
class_raylib_filepathlist_get_ptr( mrb_state *mrb, mrb_value filepathlist ) {
	class_raylib_filepathlist_data_t *data;
	if ( mrb_nil_p( filepathlist ) ) {
		return NULL;
	}
	data = ( class_raylib_filepathlist_data_t* )mrb_data_get_ptr( mrb, filepathlist, &class_raylib_filepathlist_data_type );
	return &data->filepathlist;
}

static mrb_value
class_raylib_filepathlist_initialize( mrb_state *mrb, mrb_value self ) {
	class_raylib_filepathlist_data_t *data = DATA_PTR( self );

	if ( NULL == data ) {
		data = mrb_malloc( mrb, sizeof( class_raylib_filepathlist_data_t ) );
		if ( NULL == data ) {
			mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
		}
		//data->filepathlist = { 0 };
	} else {
		// if ( NULL != &( data->filepathlist ) ) {
		// 
		// }
	}
	FilePathList filepathlist = { 0 };
	data->filepathlist = filepathlist;
	// if ( NULL == &( data->filepathlist ) ) {
	//	mrb_free( mrb, data );
	// }
	DATA_PTR( self ) = data;
	DATA_TYPE( self ) = &class_raylib_filepathlist_data_type;
	return self;
}

static mrb_value
class_raylib_filepathlist_get_capacity( mrb_state *mrb, mrb_value self ) {
	return mrb_fixnum_value( class_raylib_filepathlist_get_ptr( mrb, self )->capacity );
}
	
static mrb_value
class_raylib_filepathlist_set_capacity( mrb_state *mrb, mrb_value self ) {
	mrb_int param0;
	mrb_get_args( mrb, "i", &param0 );
	class_raylib_filepathlist_get_ptr( mrb, self )->capacity = param0;
	return self;
}
	
static mrb_value
class_raylib_filepathlist_get_count( mrb_state *mrb, mrb_value self ) {
	return mrb_fixnum_value( class_raylib_filepathlist_get_ptr( mrb, self )->count );
}
	
static mrb_value
class_raylib_filepathlist_set_count( mrb_state *mrb, mrb_value self ) {
	mrb_int param0;
	mrb_get_args( mrb, "i", &param0 );
	class_raylib_filepathlist_get_ptr( mrb, self )->count = param0;
	return self;
}
	
static mrb_value
class_raylib_filepathlist_get_paths( mrb_state *mrb, mrb_value self ) {
	return mrb_cptr_value( mrb, ( void* )( class_raylib_filepathlist_get_ptr( mrb, self )->paths ) );
}
	
static mrb_value
class_raylib_filepathlist_set_paths( mrb_state *mrb, mrb_value self ) {
	mrb_value param0;
	mrb_get_args( mrb, "!d", &param0 );
	class_raylib_filepathlist_get_ptr( mrb, self )->paths = mrb_cptr( param0 );
	return self;
}
	
void
class_raylib_filepathlist_init( mrb_state *mrb, struct RClass *mod_RayLib ) {
	class_FilePathList = mrb_define_class_under( mrb, mod_RayLib, "FilePathList", mrb->object_class );

	MRB_SET_INSTANCE_TT( class_FilePathList, MRB_TT_DATA );

	mrb_define_method( mrb, class_FilePathList, "initialize", class_raylib_filepathlist_initialize, MRB_ARGS_NONE() );

	mrb_define_method( mrb, class_FilePathList, "capacity", class_raylib_filepathlist_get_capacity, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_FilePathList, "capacity=", class_raylib_filepathlist_set_capacity, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_FilePathList, "count", class_raylib_filepathlist_get_count, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_FilePathList, "count=", class_raylib_filepathlist_set_count, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_FilePathList, "paths", class_raylib_filepathlist_get_paths, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_FilePathList, "paths=", class_raylib_filepathlist_set_paths, MRB_ARGS_REQ( 1 ) );
}
//----------------------------------------------------------------//


//----------------------------------------------------------------//
// Raylib::AutomationEvent
static struct RClass *class_AutomationEvent;

typedef struct class_raylib_automationevent_data_t {
	bool is_associated;
	AutomationEvent automationevent;
} class_raylib_automationevent_data_t;
		
static void
class_raylib_automationevent_data_free( mrb_state *mrb, void *p ) {
	class_raylib_automationevent_data_t *data = ( class_raylib_automationevent_data_t* )p;
	if ( NULL != data ) {
		mrb_free( mrb, data );
	}
}

static struct mrb_data_type const class_raylib_automationevent_data_type = {
	"AutomationEvent", class_raylib_automationevent_data_free
};

mrb_value
class_raylib_automationevent_2_mrbvalue( mrb_state *mrb, AutomationEvent *automationevent, bool is_associated ) {
	class_raylib_automationevent_data_t *data = ( class_raylib_automationevent_data_t* )mrb_malloc( mrb, sizeof( class_raylib_automationevent_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	data->is_associated = is_associated;
	data->automationevent = *automationevent;
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_AutomationEvent, &class_raylib_automationevent_data_type, data ) );
}

mrb_value
class_raylib_automationevent_2_mrbvalue_direct( mrb_state *mrb, AutomationEvent const *automationevent ) {
	class_raylib_automationevent_data_t *data = ( class_raylib_automationevent_data_t* )mrb_malloc( mrb, sizeof( class_raylib_automationevent_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	if ( NULL == automationevent ) {
		// Do init
	} else {
		// Do Copy
		data->automationevent = *automationevent;
	}
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_AutomationEvent, &class_raylib_automationevent_data_type, data ) );
}

AutomationEvent*
class_raylib_automationevent_get_ptr( mrb_state *mrb, mrb_value automationevent ) {
	class_raylib_automationevent_data_t *data;
	if ( mrb_nil_p( automationevent ) ) {
		return NULL;
	}
	data = ( class_raylib_automationevent_data_t* )mrb_data_get_ptr( mrb, automationevent, &class_raylib_automationevent_data_type );
	return &data->automationevent;
}

static mrb_value
class_raylib_automationevent_initialize( mrb_state *mrb, mrb_value self ) {
	class_raylib_automationevent_data_t *data = DATA_PTR( self );

	if ( NULL == data ) {
		data = mrb_malloc( mrb, sizeof( class_raylib_automationevent_data_t ) );
		if ( NULL == data ) {
			mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
		}
		//data->automationevent = { 0 };
	} else {
		// if ( NULL != &( data->automationevent ) ) {
		// 
		// }
	}
	AutomationEvent automationevent = { 0 };
	data->automationevent = automationevent;
	// if ( NULL == &( data->automationevent ) ) {
	//	mrb_free( mrb, data );
	// }
	DATA_PTR( self ) = data;
	DATA_TYPE( self ) = &class_raylib_automationevent_data_type;
	return self;
}

static mrb_value
class_raylib_automationevent_get_frame( mrb_state *mrb, mrb_value self ) {
	return mrb_fixnum_value( class_raylib_automationevent_get_ptr( mrb, self )->frame );
}
	
static mrb_value
class_raylib_automationevent_set_frame( mrb_state *mrb, mrb_value self ) {
	mrb_int param0;
	mrb_get_args( mrb, "i", &param0 );
	class_raylib_automationevent_get_ptr( mrb, self )->frame = param0;
	return self;
}
	
static mrb_value
class_raylib_automationevent_get_type( mrb_state *mrb, mrb_value self ) {
	return mrb_fixnum_value( class_raylib_automationevent_get_ptr( mrb, self )->type );
}
	
static mrb_value
class_raylib_automationevent_set_type( mrb_state *mrb, mrb_value self ) {
	mrb_int param0;
	mrb_get_args( mrb, "i", &param0 );
	class_raylib_automationevent_get_ptr( mrb, self )->type = param0;
	return self;
}
	
static mrb_value
class_raylib_automationevent_get_params( mrb_state *mrb, mrb_value self ) {
	mrb_value arr = mrb_ary_new( mrb );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_automationevent_get_ptr( mrb, self )->params[ 0 ] ) );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_automationevent_get_ptr( mrb, self )->params[ 1 ] ) );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_automationevent_get_ptr( mrb, self )->params[ 2 ] ) );
mrb_ary_push( mrb, arr, mrb_fixnum_value( class_raylib_automationevent_get_ptr( mrb, self )->params[ 3 ] ) );
return arr;
}
	
static mrb_value
class_raylib_automationevent_set_params( mrb_state *mrb, mrb_value self ) {
	// TODO: set params
	return self;
}
	
void
class_raylib_automationevent_init( mrb_state *mrb, struct RClass *mod_RayLib ) {
	class_AutomationEvent = mrb_define_class_under( mrb, mod_RayLib, "AutomationEvent", mrb->object_class );

	MRB_SET_INSTANCE_TT( class_AutomationEvent, MRB_TT_DATA );

	mrb_define_method( mrb, class_AutomationEvent, "initialize", class_raylib_automationevent_initialize, MRB_ARGS_NONE() );

	mrb_define_method( mrb, class_AutomationEvent, "frame", class_raylib_automationevent_get_frame, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_AutomationEvent, "frame=", class_raylib_automationevent_set_frame, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_AutomationEvent, "type", class_raylib_automationevent_get_type, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_AutomationEvent, "type=", class_raylib_automationevent_set_type, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_AutomationEvent, "params", class_raylib_automationevent_get_params, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_AutomationEvent, "params=", class_raylib_automationevent_set_params, MRB_ARGS_REQ( 1 ) );
}
//----------------------------------------------------------------//


//----------------------------------------------------------------//
// Raylib::AutomationEventList
static struct RClass *class_AutomationEventList;

typedef struct class_raylib_automationeventlist_data_t {
	bool is_associated;
	AutomationEventList automationeventlist;
} class_raylib_automationeventlist_data_t;
		
static void
class_raylib_automationeventlist_data_free( mrb_state *mrb, void *p ) {
	class_raylib_automationeventlist_data_t *data = ( class_raylib_automationeventlist_data_t* )p;
	if ( NULL != data ) {
		mrb_free( mrb, data );
	}
}

static struct mrb_data_type const class_raylib_automationeventlist_data_type = {
	"AutomationEventList", class_raylib_automationeventlist_data_free
};

mrb_value
class_raylib_automationeventlist_2_mrbvalue( mrb_state *mrb, AutomationEventList *automationeventlist, bool is_associated ) {
	class_raylib_automationeventlist_data_t *data = ( class_raylib_automationeventlist_data_t* )mrb_malloc( mrb, sizeof( class_raylib_automationeventlist_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	data->is_associated = is_associated;
	data->automationeventlist = *automationeventlist;
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_AutomationEventList, &class_raylib_automationeventlist_data_type, data ) );
}

mrb_value
class_raylib_automationeventlist_2_mrbvalue_direct( mrb_state *mrb, AutomationEventList const *automationeventlist ) {
	class_raylib_automationeventlist_data_t *data = ( class_raylib_automationeventlist_data_t* )mrb_malloc( mrb, sizeof( class_raylib_automationeventlist_data_t ) );
	if ( NULL == data ) {
		mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
	}
	if ( NULL == automationeventlist ) {
		// Do init
	} else {
		// Do Copy
		data->automationeventlist = *automationeventlist;
	}
	return mrb_obj_value( Data_Wrap_Struct( mrb, class_AutomationEventList, &class_raylib_automationeventlist_data_type, data ) );
}

AutomationEventList*
class_raylib_automationeventlist_get_ptr( mrb_state *mrb, mrb_value automationeventlist ) {
	class_raylib_automationeventlist_data_t *data;
	if ( mrb_nil_p( automationeventlist ) ) {
		return NULL;
	}
	data = ( class_raylib_automationeventlist_data_t* )mrb_data_get_ptr( mrb, automationeventlist, &class_raylib_automationeventlist_data_type );
	return &data->automationeventlist;
}

static mrb_value
class_raylib_automationeventlist_initialize( mrb_state *mrb, mrb_value self ) {
	class_raylib_automationeventlist_data_t *data = DATA_PTR( self );

	if ( NULL == data ) {
		data = mrb_malloc( mrb, sizeof( class_raylib_automationeventlist_data_t ) );
		if ( NULL == data ) {
			mrb_raise( mrb, E_RUNTIME_ERROR, "insufficient memory." );
		}
		//data->automationeventlist = { 0 };
	} else {
		// if ( NULL != &( data->automationeventlist ) ) {
		// 
		// }
	}
	AutomationEventList automationeventlist = { 0 };
	data->automationeventlist = automationeventlist;
	// if ( NULL == &( data->automationeventlist ) ) {
	//	mrb_free( mrb, data );
	// }
	DATA_PTR( self ) = data;
	DATA_TYPE( self ) = &class_raylib_automationeventlist_data_type;
	return self;
}

static mrb_value
class_raylib_automationeventlist_get_capacity( mrb_state *mrb, mrb_value self ) {
	return mrb_fixnum_value( class_raylib_automationeventlist_get_ptr( mrb, self )->capacity );
}
	
static mrb_value
class_raylib_automationeventlist_set_capacity( mrb_state *mrb, mrb_value self ) {
	mrb_int param0;
	mrb_get_args( mrb, "i", &param0 );
	class_raylib_automationeventlist_get_ptr( mrb, self )->capacity = param0;
	return self;
}
	
static mrb_value
class_raylib_automationeventlist_get_count( mrb_state *mrb, mrb_value self ) {
	return mrb_fixnum_value( class_raylib_automationeventlist_get_ptr( mrb, self )->count );
}
	
static mrb_value
class_raylib_automationeventlist_set_count( mrb_state *mrb, mrb_value self ) {
	mrb_int param0;
	mrb_get_args( mrb, "i", &param0 );
	class_raylib_automationeventlist_get_ptr( mrb, self )->count = param0;
	return self;
}
	
static mrb_value
class_raylib_automationeventlist_get_events( mrb_state *mrb, mrb_value self ) {
	return class_raylib_automationevent_2_mrbvalue( mrb, class_raylib_automationeventlist_get_ptr( mrb, self )->events, 0 );
}
	
static mrb_value
class_raylib_automationeventlist_set_events( mrb_state *mrb, mrb_value self ) {
	mrb_value param0;
	mrb_get_args( mrb, "!d", &param0 );
	class_raylib_automationeventlist_get_ptr( mrb, self )->events = class_raylib_automationevent_get_ptr( mrb, param0 );
	return self;
}
	
void
class_raylib_automationeventlist_init( mrb_state *mrb, struct RClass *mod_RayLib ) {
	class_AutomationEventList = mrb_define_class_under( mrb, mod_RayLib, "AutomationEventList", mrb->object_class );

	MRB_SET_INSTANCE_TT( class_AutomationEventList, MRB_TT_DATA );

	mrb_define_method( mrb, class_AutomationEventList, "initialize", class_raylib_automationeventlist_initialize, MRB_ARGS_NONE() );

	mrb_define_method( mrb, class_AutomationEventList, "capacity", class_raylib_automationeventlist_get_capacity, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_AutomationEventList, "capacity=", class_raylib_automationeventlist_set_capacity, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_AutomationEventList, "count", class_raylib_automationeventlist_get_count, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_AutomationEventList, "count=", class_raylib_automationeventlist_set_count, MRB_ARGS_REQ( 1 ) );
	mrb_define_method( mrb, class_AutomationEventList, "events", class_raylib_automationeventlist_get_events, MRB_ARGS_NONE() );
	mrb_define_method( mrb, class_AutomationEventList, "events=", class_raylib_automationeventlist_set_events, MRB_ARGS_REQ( 1 ) );
}
//----------------------------------------------------------------//


static mrb_value
mod_raylib_init_window( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int
	mrb_int param1; // int
	mrb_value param2; // const char*

	mrb_get_args( mrb, "iiS", &param0, &param1, &param2 );

	InitWindow( param0, param1, RSTRING_PTR( param2 ) );

	return self;
}

static mrb_value
mod_raylib_close_window( mrb_state *mrb, mrb_value self ) {
	CloseWindow();

	return self;
}

static mrb_value
mod_raylib_window_should_close( mrb_state *mrb, mrb_value self ) {
	bool ret = WindowShouldClose();

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_is_window_ready( mrb_state *mrb, mrb_value self ) {
	bool ret = IsWindowReady();

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_is_window_fullscreen( mrb_state *mrb, mrb_value self ) {
	bool ret = IsWindowFullscreen();

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_is_window_hidden( mrb_state *mrb, mrb_value self ) {
	bool ret = IsWindowHidden();

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_is_window_minimized( mrb_state *mrb, mrb_value self ) {
	bool ret = IsWindowMinimized();

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_is_window_maximized( mrb_state *mrb, mrb_value self ) {
	bool ret = IsWindowMaximized();

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_is_window_focused( mrb_state *mrb, mrb_value self ) {
	bool ret = IsWindowFocused();

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_is_window_resized( mrb_state *mrb, mrb_value self ) {
	bool ret = IsWindowResized();

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_is_window_state( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // unsigned int

	mrb_get_args( mrb, "i", &param0 );

	bool ret = IsWindowState( param0 );

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_set_window_state( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // unsigned int

	mrb_get_args( mrb, "i", &param0 );

	SetWindowState( param0 );

	return self;
}

static mrb_value
mod_raylib_clear_window_state( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // unsigned int

	mrb_get_args( mrb, "i", &param0 );

	ClearWindowState( param0 );

	return self;
}

static mrb_value
mod_raylib_toggle_fullscreen( mrb_state *mrb, mrb_value self ) {
	ToggleFullscreen();

	return self;
}

static mrb_value
mod_raylib_toggle_borderless_windowed( mrb_state *mrb, mrb_value self ) {
	ToggleBorderlessWindowed();

	return self;
}

static mrb_value
mod_raylib_maximize_window( mrb_state *mrb, mrb_value self ) {
	MaximizeWindow();

	return self;
}

static mrb_value
mod_raylib_minimize_window( mrb_state *mrb, mrb_value self ) {
	MinimizeWindow();

	return self;
}

static mrb_value
mod_raylib_restore_window( mrb_state *mrb, mrb_value self ) {
	RestoreWindow();

	return self;
}

static mrb_value
mod_raylib_set_window_icon( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Image

	mrb_get_args( mrb, "o", &param0 );

	SetWindowIcon( *class_raylib_image_get_ptr( mrb, param0 ) );

	return self;
}

static mrb_value
mod_raylib_set_window_icons( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Image*
	mrb_int param1; // int

	mrb_get_args( mrb, "!di", &param0, &param1 );

	SetWindowIcons( class_raylib_image_get_ptr( mrb, param0 ), param1 );

	return self;
}

static mrb_value
mod_raylib_set_window_title( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const char*

	mrb_get_args( mrb, "S", &param0 );

	SetWindowTitle( RSTRING_PTR( param0 ) );

	return self;
}

static mrb_value
mod_raylib_set_window_position( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int
	mrb_int param1; // int

	mrb_get_args( mrb, "ii", &param0, &param1 );

	SetWindowPosition( param0, param1 );

	return self;
}

static mrb_value
mod_raylib_set_window_monitor( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int

	mrb_get_args( mrb, "i", &param0 );

	SetWindowMonitor( param0 );

	return self;
}

static mrb_value
mod_raylib_set_window_min_size( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int
	mrb_int param1; // int

	mrb_get_args( mrb, "ii", &param0, &param1 );

	SetWindowMinSize( param0, param1 );

	return self;
}

static mrb_value
mod_raylib_set_window_max_size( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int
	mrb_int param1; // int

	mrb_get_args( mrb, "ii", &param0, &param1 );

	SetWindowMaxSize( param0, param1 );

	return self;
}

static mrb_value
mod_raylib_set_window_size( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int
	mrb_int param1; // int

	mrb_get_args( mrb, "ii", &param0, &param1 );

	SetWindowSize( param0, param1 );

	return self;
}

static mrb_value
mod_raylib_set_window_opacity( mrb_state *mrb, mrb_value self ) {
	mrb_float param0; // float

	mrb_get_args( mrb, "f", &param0 );

	SetWindowOpacity( param0 );

	return self;
}

static mrb_value
mod_raylib_set_window_focused( mrb_state *mrb, mrb_value self ) {
	SetWindowFocused();

	return self;
}

static mrb_value
mod_raylib_get_window_handle( mrb_state *mrb, mrb_value self ) {
	void* ret = GetWindowHandle();

	return mrb_cptr_value( mrb, ret );
}

static mrb_value
mod_raylib_get_screen_width( mrb_state *mrb, mrb_value self ) {
	int ret = GetScreenWidth();

	return mrb_fixnum_value( ret );
}

static mrb_value
mod_raylib_get_screen_height( mrb_state *mrb, mrb_value self ) {
	int ret = GetScreenHeight();

	return mrb_fixnum_value( ret );
}

static mrb_value
mod_raylib_get_render_width( mrb_state *mrb, mrb_value self ) {
	int ret = GetRenderWidth();

	return mrb_fixnum_value( ret );
}

static mrb_value
mod_raylib_get_render_height( mrb_state *mrb, mrb_value self ) {
	int ret = GetRenderHeight();

	return mrb_fixnum_value( ret );
}

static mrb_value
mod_raylib_get_monitor_count( mrb_state *mrb, mrb_value self ) {
	int ret = GetMonitorCount();

	return mrb_fixnum_value( ret );
}

static mrb_value
mod_raylib_get_current_monitor( mrb_state *mrb, mrb_value self ) {
	int ret = GetCurrentMonitor();

	return mrb_fixnum_value( ret );
}

static mrb_value
mod_raylib_get_monitor_position( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int

	mrb_get_args( mrb, "i", &param0 );

	Vector2 ret = GetMonitorPosition( param0 );

	return class_raylib_vector2_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_get_monitor_width( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int

	mrb_get_args( mrb, "i", &param0 );

	int ret = GetMonitorWidth( param0 );

	return mrb_fixnum_value( ret );
}

static mrb_value
mod_raylib_get_monitor_height( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int

	mrb_get_args( mrb, "i", &param0 );

	int ret = GetMonitorHeight( param0 );

	return mrb_fixnum_value( ret );
}

static mrb_value
mod_raylib_get_monitor_physical_width( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int

	mrb_get_args( mrb, "i", &param0 );

	int ret = GetMonitorPhysicalWidth( param0 );

	return mrb_fixnum_value( ret );
}

static mrb_value
mod_raylib_get_monitor_physical_height( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int

	mrb_get_args( mrb, "i", &param0 );

	int ret = GetMonitorPhysicalHeight( param0 );

	return mrb_fixnum_value( ret );
}

static mrb_value
mod_raylib_get_monitor_refresh_rate( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int

	mrb_get_args( mrb, "i", &param0 );

	int ret = GetMonitorRefreshRate( param0 );

	return mrb_fixnum_value( ret );
}

static mrb_value
mod_raylib_get_window_position( mrb_state *mrb, mrb_value self ) {
	Vector2 ret = GetWindowPosition();

	return class_raylib_vector2_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_get_window_scale_dpi( mrb_state *mrb, mrb_value self ) {
	Vector2 ret = GetWindowScaleDPI();

	return class_raylib_vector2_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_get_monitor_name( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int

	mrb_get_args( mrb, "i", &param0 );

	const char* ret = GetMonitorName( param0 );

	return mrb_str_new_cstr( mrb, ret );
}

static mrb_value
mod_raylib_set_clipboard_text( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const char*

	mrb_get_args( mrb, "S", &param0 );

	SetClipboardText( RSTRING_PTR( param0 ) );

	return self;
}

static mrb_value
mod_raylib_get_clipboard_text( mrb_state *mrb, mrb_value self ) {
	const char* ret = GetClipboardText();

	return mrb_str_new_cstr( mrb, ret );
}

static mrb_value
mod_raylib_enable_event_waiting( mrb_state *mrb, mrb_value self ) {
	EnableEventWaiting();

	return self;
}

static mrb_value
mod_raylib_disable_event_waiting( mrb_state *mrb, mrb_value self ) {
	DisableEventWaiting();

	return self;
}

static mrb_value
mod_raylib_show_cursor( mrb_state *mrb, mrb_value self ) {
	ShowCursor();

	return self;
}

static mrb_value
mod_raylib_hide_cursor( mrb_state *mrb, mrb_value self ) {
	HideCursor();

	return self;
}

static mrb_value
mod_raylib_is_cursor_hidden( mrb_state *mrb, mrb_value self ) {
	bool ret = IsCursorHidden();

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_enable_cursor( mrb_state *mrb, mrb_value self ) {
	EnableCursor();

	return self;
}

static mrb_value
mod_raylib_disable_cursor( mrb_state *mrb, mrb_value self ) {
	DisableCursor();

	return self;
}

static mrb_value
mod_raylib_is_cursor_on_screen( mrb_state *mrb, mrb_value self ) {
	bool ret = IsCursorOnScreen();

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_clear_background( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Color

	mrb_get_args( mrb, "o", &param0 );

	ClearBackground( *class_raylib_color_get_ptr( mrb, param0 ) );

	return self;
}

static mrb_value
mod_raylib_begin_drawing( mrb_state *mrb, mrb_value self ) {
	BeginDrawing();

	return self;
}

static mrb_value
mod_raylib_end_drawing( mrb_state *mrb, mrb_value self ) {
	EndDrawing();

	return self;
}

static mrb_value
mod_raylib_begin_mode2_d( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Camera2D

	mrb_get_args( mrb, "o", &param0 );

	BeginMode2D( *class_raylib_camera2d_get_ptr( mrb, param0 ) );

	return self;
}

static mrb_value
mod_raylib_end_mode2_d( mrb_state *mrb, mrb_value self ) {
	EndMode2D();

	return self;
}

static mrb_value
mod_raylib_begin_mode3_d( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Camera3D

	mrb_get_args( mrb, "o", &param0 );

	BeginMode3D( *class_raylib_camera3d_get_ptr( mrb, param0 ) );

	return self;
}

static mrb_value
mod_raylib_end_mode3_d( mrb_state *mrb, mrb_value self ) {
	EndMode3D();

	return self;
}

static mrb_value
mod_raylib_begin_texture_mode( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // RenderTexture2D

	mrb_get_args( mrb, "d", &param0 );

	BeginTextureMode( *class_raylib_rendertexture_get_ptr( mrb, param0 ) );

	return self;
}

static mrb_value
mod_raylib_end_texture_mode( mrb_state *mrb, mrb_value self ) {
	EndTextureMode();

	return self;
}

static mrb_value
mod_raylib_begin_shader_mode( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Shader

	mrb_get_args( mrb, "o", &param0 );

	BeginShaderMode( *class_raylib_shader_get_ptr( mrb, param0 ) );

	return self;
}

static mrb_value
mod_raylib_end_shader_mode( mrb_state *mrb, mrb_value self ) {
	EndShaderMode();

	return self;
}

static mrb_value
mod_raylib_begin_blend_mode( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int

	mrb_get_args( mrb, "i", &param0 );

	BeginBlendMode( param0 );

	return self;
}

static mrb_value
mod_raylib_end_blend_mode( mrb_state *mrb, mrb_value self ) {
	EndBlendMode();

	return self;
}

static mrb_value
mod_raylib_begin_scissor_mode( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int
	mrb_int param1; // int
	mrb_int param2; // int
	mrb_int param3; // int

	mrb_get_args( mrb, "iiii", &param0, &param1, &param2, &param3 );

	BeginScissorMode( param0, param1, param2, param3 );

	return self;
}

static mrb_value
mod_raylib_end_scissor_mode( mrb_state *mrb, mrb_value self ) {
	EndScissorMode();

	return self;
}

static mrb_value
mod_raylib_begin_vr_stereo_mode( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // VrStereoConfig

	mrb_get_args( mrb, "o", &param0 );

	BeginVrStereoMode( *class_raylib_vrstereoconfig_get_ptr( mrb, param0 ) );

	return self;
}

static mrb_value
mod_raylib_end_vr_stereo_mode( mrb_state *mrb, mrb_value self ) {
	EndVrStereoMode();

	return self;
}

static mrb_value
mod_raylib_load_vr_stereo_config( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // VrDeviceInfo

	mrb_get_args( mrb, "o", &param0 );

	VrStereoConfig ret = LoadVrStereoConfig( *class_raylib_vrdeviceinfo_get_ptr( mrb, param0 ) );

	return class_raylib_vrstereoconfig_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_unload_vr_stereo_config( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // VrStereoConfig

	mrb_get_args( mrb, "o", &param0 );

	UnloadVrStereoConfig( *class_raylib_vrstereoconfig_get_ptr( mrb, param0 ) );

	return self;
}

static mrb_value
mod_raylib_load_shader( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const char*
	mrb_value param1; // const char*

	mrb_get_args( mrb, "SS", &param0, &param1 );

	Shader ret = LoadShader( RSTRING_PTR( param0 ), RSTRING_PTR( param1 ) );

	return class_raylib_shader_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_load_shader_from_memory( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const char*
	mrb_value param1; // const char*

	mrb_get_args( mrb, "SS", &param0, &param1 );

	Shader ret = LoadShaderFromMemory( RSTRING_PTR( param0 ), RSTRING_PTR( param1 ) );

	return class_raylib_shader_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_is_shader_ready( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Shader

	mrb_get_args( mrb, "o", &param0 );

	bool ret = IsShaderReady( *class_raylib_shader_get_ptr( mrb, param0 ) );

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_get_shader_location( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Shader
	mrb_value param1; // const char*

	mrb_get_args( mrb, "oS", &param0, &param1 );

	int ret = GetShaderLocation( *class_raylib_shader_get_ptr( mrb, param0 ), RSTRING_PTR( param1 ) );

	return mrb_fixnum_value( ret );
}

static mrb_value
mod_raylib_get_shader_location_attrib( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Shader
	mrb_value param1; // const char*

	mrb_get_args( mrb, "oS", &param0, &param1 );

	int ret = GetShaderLocationAttrib( *class_raylib_shader_get_ptr( mrb, param0 ), RSTRING_PTR( param1 ) );

	return mrb_fixnum_value( ret );
}

static mrb_value
mod_raylib_set_shader_value( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Shader
	mrb_int param1; // int
	mrb_value param2; // const void*
	mrb_int param3; // int

	mrb_get_args( mrb, "oi!di", &param0, &param1, &param2, &param3 );

	SetShaderValue( *class_raylib_shader_get_ptr( mrb, param0 ), param1, mrb_cptr( param2 ), param3 );

	return self;
}

static mrb_value
mod_raylib_set_shader_value_v( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Shader
	mrb_int param1; // int
	mrb_value param2; // const void*
	mrb_int param3; // int
	mrb_int param4; // int

	mrb_get_args( mrb, "oi!dii", &param0, &param1, &param2, &param3, &param4 );

	SetShaderValueV( *class_raylib_shader_get_ptr( mrb, param0 ), param1, mrb_cptr( param2 ), param3, param4 );

	return self;
}

static mrb_value
mod_raylib_set_shader_value_matrix( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Shader
	mrb_int param1; // int
	mrb_value param2; // Matrix

	mrb_get_args( mrb, "oio", &param0, &param1, &param2 );

	SetShaderValueMatrix( *class_raylib_shader_get_ptr( mrb, param0 ), param1, *class_raylib_matrix_get_ptr( mrb, param2 ) );

	return self;
}

static mrb_value
mod_raylib_set_shader_value_texture( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Shader
	mrb_int param1; // int
	mrb_value param2; // Texture2D

	mrb_get_args( mrb, "oid", &param0, &param1, &param2 );

	SetShaderValueTexture( *class_raylib_shader_get_ptr( mrb, param0 ), param1, *class_raylib_texture_get_ptr( mrb, param2 ) );

	return self;
}

static mrb_value
mod_raylib_unload_shader( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Shader

	mrb_get_args( mrb, "o", &param0 );

	UnloadShader( *class_raylib_shader_get_ptr( mrb, param0 ) );

	return self;
}

static mrb_value
mod_raylib_get_mouse_ray( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector2
	mrb_value param1; // Camera

	mrb_get_args( mrb, "od", &param0, &param1 );

	Ray ret = GetMouseRay( *class_raylib_vector2_get_ptr( mrb, param0 ), *class_raylib_camera3d_get_ptr( mrb, param1 ) );

	return class_raylib_ray_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_get_camera_matrix( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Camera

	mrb_get_args( mrb, "d", &param0 );

	Matrix ret = GetCameraMatrix( *class_raylib_camera3d_get_ptr( mrb, param0 ) );

	return class_raylib_matrix_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_get_camera_matrix2_d( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Camera2D

	mrb_get_args( mrb, "o", &param0 );

	Matrix ret = GetCameraMatrix2D( *class_raylib_camera2d_get_ptr( mrb, param0 ) );

	return class_raylib_matrix_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_get_world_to_screen( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector3
	mrb_value param1; // Camera

	mrb_get_args( mrb, "od", &param0, &param1 );

	Vector2 ret = GetWorldToScreen( *class_raylib_vector3_get_ptr( mrb, param0 ), *class_raylib_camera3d_get_ptr( mrb, param1 ) );

	return class_raylib_vector2_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_get_screen_to_world2_d( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector2
	mrb_value param1; // Camera2D

	mrb_get_args( mrb, "oo", &param0, &param1 );

	Vector2 ret = GetScreenToWorld2D( *class_raylib_vector2_get_ptr( mrb, param0 ), *class_raylib_camera2d_get_ptr( mrb, param1 ) );

	return class_raylib_vector2_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_get_world_to_screen_ex( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector3
	mrb_value param1; // Camera
	mrb_int param2; // int
	mrb_int param3; // int

	mrb_get_args( mrb, "odii", &param0, &param1, &param2, &param3 );

	Vector2 ret = GetWorldToScreenEx( *class_raylib_vector3_get_ptr( mrb, param0 ), *class_raylib_camera3d_get_ptr( mrb, param1 ), param2, param3 );

	return class_raylib_vector2_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_get_world_to_screen2_d( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector2
	mrb_value param1; // Camera2D

	mrb_get_args( mrb, "oo", &param0, &param1 );

	Vector2 ret = GetWorldToScreen2D( *class_raylib_vector2_get_ptr( mrb, param0 ), *class_raylib_camera2d_get_ptr( mrb, param1 ) );

	return class_raylib_vector2_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_set_target_fps( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int

	mrb_get_args( mrb, "i", &param0 );

	SetTargetFPS( param0 );

	return self;
}

static mrb_value
mod_raylib_get_frame_time( mrb_state *mrb, mrb_value self ) {
	float ret = GetFrameTime();

	return mrb_float_value( mrb, ret );
}

static mrb_value
mod_raylib_get_time( mrb_state *mrb, mrb_value self ) {
	double ret = GetTime();

	return mrb_float_value( mrb, ret );
}

static mrb_value
mod_raylib_get_fps( mrb_state *mrb, mrb_value self ) {
	int ret = GetFPS();

	return mrb_fixnum_value( ret );
}

static mrb_value
mod_raylib_swap_screen_buffer( mrb_state *mrb, mrb_value self ) {
	SwapScreenBuffer();

	return self;
}

static mrb_value
mod_raylib_poll_input_events( mrb_state *mrb, mrb_value self ) {
	PollInputEvents();

	return self;
}

static mrb_value
mod_raylib_wait_time( mrb_state *mrb, mrb_value self ) {
	mrb_float param0; // double

	mrb_get_args( mrb, "f", &param0 );

	WaitTime( param0 );

	return self;
}

static mrb_value
mod_raylib_set_random_seed( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // unsigned int

	mrb_get_args( mrb, "i", &param0 );

	SetRandomSeed( param0 );

	return self;
}

static mrb_value
mod_raylib_get_random_value( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int
	mrb_int param1; // int

	mrb_get_args( mrb, "ii", &param0, &param1 );

	int ret = GetRandomValue( param0, param1 );

	return mrb_fixnum_value( ret );
}

static mrb_value
mod_raylib_load_random_sequence( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // unsigned int
	mrb_int param1; // int
	mrb_int param2; // int

	mrb_get_args( mrb, "iii", &param0, &param1, &param2 );

	int* ret = LoadRandomSequence( param0, param1, param2 );

	return mrb_cptr_value( mrb, ( void* )( ret ) );
}

static mrb_value
mod_raylib_unload_random_sequence( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // int*

	mrb_get_args( mrb, "*", &param0 );

	UnloadRandomSequence( mrb_cptr( param0 ) );

	return self;
}

static mrb_value
mod_raylib_take_screenshot( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const char*

	mrb_get_args( mrb, "S", &param0 );

	TakeScreenshot( RSTRING_PTR( param0 ) );

	return self;
}

static mrb_value
mod_raylib_set_config_flags( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // unsigned int

	mrb_get_args( mrb, "i", &param0 );

	SetConfigFlags( param0 );

	return self;
}

static mrb_value
mod_raylib_open_url( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const char*

	mrb_get_args( mrb, "S", &param0 );

	OpenURL( RSTRING_PTR( param0 ) );

	return self;
}

static mrb_value
mod_raylib_trace_log( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int
	mrb_value param1; // const char*

	mrb_get_args( mrb, "iS", &param0, &param1 );

	TraceLog( param0, RSTRING_PTR( param1 ) );

	return self;
}

static mrb_value
mod_raylib_set_trace_log_level( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int

	mrb_get_args( mrb, "i", &param0 );

	SetTraceLogLevel( param0 );

	return self;
}

static mrb_value
mod_raylib_mem_alloc( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // unsigned int

	mrb_get_args( mrb, "i", &param0 );

	void* ret = MemAlloc( param0 );

	return mrb_cptr_value( mrb, ret );
}

static mrb_value
mod_raylib_mem_realloc( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // void*
	mrb_int param1; // unsigned int

	mrb_get_args( mrb, "di", &param0, &param1 );

	void* ret = MemRealloc( mrb_cptr( param0 ), param1 );

	return mrb_cptr_value( mrb, ret );
}

static mrb_value
mod_raylib_mem_free( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // void*

	mrb_get_args( mrb, "d", &param0 );

	MemFree( mrb_cptr( param0 ) );

	return self;
}

static mrb_value
mod_raylib_set_trace_log_callback( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // TraceLogCallback

	mrb_get_args( mrb, "*", &param0 );

	SetTraceLogCallback( NULL );

	return self;
}

static mrb_value
mod_raylib_set_load_file_data_callback( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // LoadFileDataCallback

	mrb_get_args( mrb, "*", &param0 );

	SetLoadFileDataCallback( NULL );

	return self;
}

static mrb_value
mod_raylib_set_save_file_data_callback( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // SaveFileDataCallback

	mrb_get_args( mrb, "*", &param0 );

	SetSaveFileDataCallback( NULL );

	return self;
}

static mrb_value
mod_raylib_set_load_file_text_callback( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // LoadFileTextCallback

	mrb_get_args( mrb, "*", &param0 );

	SetLoadFileTextCallback( NULL );

	return self;
}

static mrb_value
mod_raylib_set_save_file_text_callback( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // SaveFileTextCallback

	mrb_get_args( mrb, "*", &param0 );

	SetSaveFileTextCallback( NULL );

	return self;
}

static mrb_value
mod_raylib_load_file_data( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const char*
	mrb_value param1; // int*

	mrb_get_args( mrb, "S*", &param0, &param1 );

	unsigned char* ret = LoadFileData( RSTRING_PTR( param0 ), mrb_cptr( param1 ) );

	return mrb_cptr_value( mrb, ( void* )( ret ) );
}

static mrb_value
mod_raylib_unload_file_data( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // unsigned char*

	mrb_get_args( mrb, "*", &param0 );

	UnloadFileData( mrb_cptr( param0 ) );

	return self;
}

static mrb_value
mod_raylib_save_file_data( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const char*
	mrb_value param1; // void*
	mrb_int param2; // int

	mrb_get_args( mrb, "Sdi", &param0, &param1, &param2 );

	bool ret = SaveFileData( RSTRING_PTR( param0 ), mrb_cptr( param1 ), param2 );

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_export_data_as_code( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const unsigned char*
	mrb_int param1; // int
	mrb_value param2; // const char*

	mrb_get_args( mrb, "!diS", &param0, &param1, &param2 );

	bool ret = ExportDataAsCode( NULL, param1, RSTRING_PTR( param2 ) );

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_load_file_text( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const char*

	mrb_get_args( mrb, "S", &param0 );

	char* ret = LoadFileText( RSTRING_PTR( param0 ) );

	return mrb_cptr_value( mrb, ( void* )( ret ) );
}

static mrb_value
mod_raylib_unload_file_text( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // char*

	mrb_get_args( mrb, "*", &param0 );

	UnloadFileText( mrb_cptr( param0 ) );

	return self;
}

static mrb_value
mod_raylib_save_file_text( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const char*
	mrb_value param1; // char*

	mrb_get_args( mrb, "S*", &param0, &param1 );

	bool ret = SaveFileText( RSTRING_PTR( param0 ), mrb_cptr( param1 ) );

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_file_exists( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const char*

	mrb_get_args( mrb, "S", &param0 );

	bool ret = FileExists( RSTRING_PTR( param0 ) );

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_directory_exists( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const char*

	mrb_get_args( mrb, "S", &param0 );

	bool ret = DirectoryExists( RSTRING_PTR( param0 ) );

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_is_file_extension( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const char*
	mrb_value param1; // const char*

	mrb_get_args( mrb, "SS", &param0, &param1 );

	bool ret = IsFileExtension( RSTRING_PTR( param0 ), RSTRING_PTR( param1 ) );

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_get_file_length( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const char*

	mrb_get_args( mrb, "S", &param0 );

	int ret = GetFileLength( RSTRING_PTR( param0 ) );

	return mrb_fixnum_value( ret );
}

static mrb_value
mod_raylib_get_file_extension( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const char*

	mrb_get_args( mrb, "S", &param0 );

	const char* ret = GetFileExtension( RSTRING_PTR( param0 ) );

	return mrb_str_new_cstr( mrb, ret );
}

static mrb_value
mod_raylib_get_file_name( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const char*

	mrb_get_args( mrb, "S", &param0 );

	const char* ret = GetFileName( RSTRING_PTR( param0 ) );

	return mrb_str_new_cstr( mrb, ret );
}

static mrb_value
mod_raylib_get_file_name_without_ext( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const char*

	mrb_get_args( mrb, "S", &param0 );

	const char* ret = GetFileNameWithoutExt( RSTRING_PTR( param0 ) );

	return mrb_str_new_cstr( mrb, ret );
}

static mrb_value
mod_raylib_get_directory_path( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const char*

	mrb_get_args( mrb, "S", &param0 );

	const char* ret = GetDirectoryPath( RSTRING_PTR( param0 ) );

	return mrb_str_new_cstr( mrb, ret );
}

static mrb_value
mod_raylib_get_prev_directory_path( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const char*

	mrb_get_args( mrb, "S", &param0 );

	const char* ret = GetPrevDirectoryPath( RSTRING_PTR( param0 ) );

	return mrb_str_new_cstr( mrb, ret );
}

static mrb_value
mod_raylib_get_working_directory( mrb_state *mrb, mrb_value self ) {
	const char* ret = GetWorkingDirectory();

	return mrb_str_new_cstr( mrb, ret );
}

static mrb_value
mod_raylib_get_application_directory( mrb_state *mrb, mrb_value self ) {
	const char* ret = GetApplicationDirectory();

	return mrb_str_new_cstr( mrb, ret );
}

static mrb_value
mod_raylib_change_directory( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const char*

	mrb_get_args( mrb, "S", &param0 );

	bool ret = ChangeDirectory( RSTRING_PTR( param0 ) );

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_is_path_file( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const char*

	mrb_get_args( mrb, "S", &param0 );

	bool ret = IsPathFile( RSTRING_PTR( param0 ) );

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_load_directory_files( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const char*

	mrb_get_args( mrb, "S", &param0 );

	FilePathList ret = LoadDirectoryFiles( RSTRING_PTR( param0 ) );

	return class_raylib_filepathlist_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_load_directory_files_ex( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const char*
	mrb_value param1; // const char*
	mrb_bool param2; // bool

	mrb_get_args( mrb, "SSb", &param0, &param1, &param2 );

	FilePathList ret = LoadDirectoryFilesEx( RSTRING_PTR( param0 ), RSTRING_PTR( param1 ), param2 );

	return class_raylib_filepathlist_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_unload_directory_files( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // FilePathList

	mrb_get_args( mrb, "o", &param0 );

	UnloadDirectoryFiles( *class_raylib_filepathlist_get_ptr( mrb, param0 ) );

	return self;
}

static mrb_value
mod_raylib_is_file_dropped( mrb_state *mrb, mrb_value self ) {
	bool ret = IsFileDropped();

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_load_dropped_files( mrb_state *mrb, mrb_value self ) {
	FilePathList ret = LoadDroppedFiles();

	return class_raylib_filepathlist_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_unload_dropped_files( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // FilePathList

	mrb_get_args( mrb, "o", &param0 );

	UnloadDroppedFiles( *class_raylib_filepathlist_get_ptr( mrb, param0 ) );

	return self;
}

static mrb_value
mod_raylib_get_file_mod_time( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const char*

	mrb_get_args( mrb, "S", &param0 );

	int ret = GetFileModTime( RSTRING_PTR( param0 ) );

	return mrb_fixnum_value( ret );
}

static mrb_value
mod_raylib_compress_data( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const unsigned char*
	mrb_int param1; // int
	mrb_value param2; // int*

	mrb_get_args( mrb, "!di*", &param0, &param1, &param2 );

	unsigned char* ret = CompressData( NULL, param1, mrb_cptr( param2 ) );

	return mrb_cptr_value( mrb, ( void* )( ret ) );
}

static mrb_value
mod_raylib_decompress_data( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const unsigned char*
	mrb_int param1; // int
	mrb_value param2; // int*

	mrb_get_args( mrb, "!di*", &param0, &param1, &param2 );

	unsigned char* ret = DecompressData( NULL, param1, mrb_cptr( param2 ) );

	return mrb_cptr_value( mrb, ( void* )( ret ) );
}

static mrb_value
mod_raylib_encode_data_base64( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const unsigned char*
	mrb_int param1; // int
	mrb_value param2; // int*

	mrb_get_args( mrb, "!di*", &param0, &param1, &param2 );

	char* ret = EncodeDataBase64( NULL, param1, mrb_cptr( param2 ) );

	return mrb_cptr_value( mrb, ( void* )( ret ) );
}

static mrb_value
mod_raylib_decode_data_base64( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const unsigned char*
	mrb_value param1; // int*

	mrb_get_args( mrb, "!d*", &param0, &param1 );

	unsigned char* ret = DecodeDataBase64( NULL, mrb_cptr( param1 ) );

	return mrb_cptr_value( mrb, ( void* )( ret ) );
}

static mrb_value
mod_raylib_load_automation_event_list( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const char*

	mrb_get_args( mrb, "S", &param0 );

	AutomationEventList ret = LoadAutomationEventList( RSTRING_PTR( param0 ) );

	return class_raylib_automationeventlist_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_unload_automation_event_list( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // AutomationEventList*

	mrb_get_args( mrb, "!d", &param0 );

	UnloadAutomationEventList( class_raylib_automationeventlist_get_ptr( mrb, param0 ) );

	return self;
}

static mrb_value
mod_raylib_export_automation_event_list( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // AutomationEventList
	mrb_value param1; // const char*

	mrb_get_args( mrb, "oS", &param0, &param1 );

	bool ret = ExportAutomationEventList( *class_raylib_automationeventlist_get_ptr( mrb, param0 ), RSTRING_PTR( param1 ) );

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_set_automation_event_list( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // AutomationEventList*

	mrb_get_args( mrb, "!d", &param0 );

	SetAutomationEventList( class_raylib_automationeventlist_get_ptr( mrb, param0 ) );

	return self;
}

static mrb_value
mod_raylib_set_automation_event_base_frame( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int

	mrb_get_args( mrb, "i", &param0 );

	SetAutomationEventBaseFrame( param0 );

	return self;
}

static mrb_value
mod_raylib_start_automation_event_recording( mrb_state *mrb, mrb_value self ) {
	StartAutomationEventRecording();

	return self;
}

static mrb_value
mod_raylib_stop_automation_event_recording( mrb_state *mrb, mrb_value self ) {
	StopAutomationEventRecording();

	return self;
}

static mrb_value
mod_raylib_play_automation_event( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // AutomationEvent

	mrb_get_args( mrb, "o", &param0 );

	PlayAutomationEvent( *class_raylib_automationevent_get_ptr( mrb, param0 ) );

	return self;
}

static mrb_value
mod_raylib_is_key_pressed( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int

	mrb_get_args( mrb, "i", &param0 );

	bool ret = IsKeyPressed( param0 );

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_is_key_pressed_repeat( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int

	mrb_get_args( mrb, "i", &param0 );

	bool ret = IsKeyPressedRepeat( param0 );

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_is_key_down( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int

	mrb_get_args( mrb, "i", &param0 );

	bool ret = IsKeyDown( param0 );

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_is_key_released( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int

	mrb_get_args( mrb, "i", &param0 );

	bool ret = IsKeyReleased( param0 );

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_is_key_up( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int

	mrb_get_args( mrb, "i", &param0 );

	bool ret = IsKeyUp( param0 );

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_get_key_pressed( mrb_state *mrb, mrb_value self ) {
	int ret = GetKeyPressed();

	return mrb_fixnum_value( ret );
}

static mrb_value
mod_raylib_get_char_pressed( mrb_state *mrb, mrb_value self ) {
	int ret = GetCharPressed();

	return mrb_fixnum_value( ret );
}

static mrb_value
mod_raylib_set_exit_key( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int

	mrb_get_args( mrb, "i", &param0 );

	SetExitKey( param0 );

	return self;
}

static mrb_value
mod_raylib_is_gamepad_available( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int

	mrb_get_args( mrb, "i", &param0 );

	bool ret = IsGamepadAvailable( param0 );

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_get_gamepad_name( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int

	mrb_get_args( mrb, "i", &param0 );

	const char* ret = GetGamepadName( param0 );

	return mrb_str_new_cstr( mrb, ret );
}

static mrb_value
mod_raylib_is_gamepad_button_pressed( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int
	mrb_int param1; // int

	mrb_get_args( mrb, "ii", &param0, &param1 );

	bool ret = IsGamepadButtonPressed( param0, param1 );

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_is_gamepad_button_down( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int
	mrb_int param1; // int

	mrb_get_args( mrb, "ii", &param0, &param1 );

	bool ret = IsGamepadButtonDown( param0, param1 );

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_is_gamepad_button_released( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int
	mrb_int param1; // int

	mrb_get_args( mrb, "ii", &param0, &param1 );

	bool ret = IsGamepadButtonReleased( param0, param1 );

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_is_gamepad_button_up( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int
	mrb_int param1; // int

	mrb_get_args( mrb, "ii", &param0, &param1 );

	bool ret = IsGamepadButtonUp( param0, param1 );

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_get_gamepad_button_pressed( mrb_state *mrb, mrb_value self ) {
	int ret = GetGamepadButtonPressed();

	return mrb_fixnum_value( ret );
}

static mrb_value
mod_raylib_get_gamepad_axis_count( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int

	mrb_get_args( mrb, "i", &param0 );

	int ret = GetGamepadAxisCount( param0 );

	return mrb_fixnum_value( ret );
}

static mrb_value
mod_raylib_get_gamepad_axis_movement( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int
	mrb_int param1; // int

	mrb_get_args( mrb, "ii", &param0, &param1 );

	float ret = GetGamepadAxisMovement( param0, param1 );

	return mrb_float_value( mrb, ret );
}

static mrb_value
mod_raylib_set_gamepad_mappings( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const char*

	mrb_get_args( mrb, "S", &param0 );

	int ret = SetGamepadMappings( RSTRING_PTR( param0 ) );

	return mrb_fixnum_value( ret );
}

static mrb_value
mod_raylib_is_mouse_button_pressed( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int

	mrb_get_args( mrb, "i", &param0 );

	bool ret = IsMouseButtonPressed( param0 );

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_is_mouse_button_down( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int

	mrb_get_args( mrb, "i", &param0 );

	bool ret = IsMouseButtonDown( param0 );

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_is_mouse_button_released( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int

	mrb_get_args( mrb, "i", &param0 );

	bool ret = IsMouseButtonReleased( param0 );

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_is_mouse_button_up( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int

	mrb_get_args( mrb, "i", &param0 );

	bool ret = IsMouseButtonUp( param0 );

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_get_mouse_x( mrb_state *mrb, mrb_value self ) {
	int ret = GetMouseX();

	return mrb_fixnum_value( ret );
}

static mrb_value
mod_raylib_get_mouse_y( mrb_state *mrb, mrb_value self ) {
	int ret = GetMouseY();

	return mrb_fixnum_value( ret );
}

static mrb_value
mod_raylib_get_mouse_position( mrb_state *mrb, mrb_value self ) {
	Vector2 ret = GetMousePosition();

	return class_raylib_vector2_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_get_mouse_delta( mrb_state *mrb, mrb_value self ) {
	Vector2 ret = GetMouseDelta();

	return class_raylib_vector2_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_set_mouse_position( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int
	mrb_int param1; // int

	mrb_get_args( mrb, "ii", &param0, &param1 );

	SetMousePosition( param0, param1 );

	return self;
}

static mrb_value
mod_raylib_set_mouse_offset( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int
	mrb_int param1; // int

	mrb_get_args( mrb, "ii", &param0, &param1 );

	SetMouseOffset( param0, param1 );

	return self;
}

static mrb_value
mod_raylib_set_mouse_scale( mrb_state *mrb, mrb_value self ) {
	mrb_float param0; // float
	mrb_float param1; // float

	mrb_get_args( mrb, "ff", &param0, &param1 );

	SetMouseScale( param0, param1 );

	return self;
}

static mrb_value
mod_raylib_get_mouse_wheel_move( mrb_state *mrb, mrb_value self ) {
	float ret = GetMouseWheelMove();

	return mrb_float_value( mrb, ret );
}

static mrb_value
mod_raylib_get_mouse_wheel_move_v( mrb_state *mrb, mrb_value self ) {
	Vector2 ret = GetMouseWheelMoveV();

	return class_raylib_vector2_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_set_mouse_cursor( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int

	mrb_get_args( mrb, "i", &param0 );

	SetMouseCursor( param0 );

	return self;
}

static mrb_value
mod_raylib_get_touch_x( mrb_state *mrb, mrb_value self ) {
	int ret = GetTouchX();

	return mrb_fixnum_value( ret );
}

static mrb_value
mod_raylib_get_touch_y( mrb_state *mrb, mrb_value self ) {
	int ret = GetTouchY();

	return mrb_fixnum_value( ret );
}

static mrb_value
mod_raylib_get_touch_position( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int

	mrb_get_args( mrb, "i", &param0 );

	Vector2 ret = GetTouchPosition( param0 );

	return class_raylib_vector2_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_get_touch_point_id( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int

	mrb_get_args( mrb, "i", &param0 );

	int ret = GetTouchPointId( param0 );

	return mrb_fixnum_value( ret );
}

static mrb_value
mod_raylib_get_touch_point_count( mrb_state *mrb, mrb_value self ) {
	int ret = GetTouchPointCount();

	return mrb_fixnum_value( ret );
}

static mrb_value
mod_raylib_set_gestures_enabled( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // unsigned int

	mrb_get_args( mrb, "i", &param0 );

	SetGesturesEnabled( param0 );

	return self;
}

static mrb_value
mod_raylib_is_gesture_detected( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // unsigned int

	mrb_get_args( mrb, "i", &param0 );

	bool ret = IsGestureDetected( param0 );

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_get_gesture_detected( mrb_state *mrb, mrb_value self ) {
	int ret = GetGestureDetected();

	return mrb_fixnum_value( ret );
}

static mrb_value
mod_raylib_get_gesture_hold_duration( mrb_state *mrb, mrb_value self ) {
	float ret = GetGestureHoldDuration();

	return mrb_float_value( mrb, ret );
}

static mrb_value
mod_raylib_get_gesture_drag_vector( mrb_state *mrb, mrb_value self ) {
	Vector2 ret = GetGestureDragVector();

	return class_raylib_vector2_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_get_gesture_drag_angle( mrb_state *mrb, mrb_value self ) {
	float ret = GetGestureDragAngle();

	return mrb_float_value( mrb, ret );
}

static mrb_value
mod_raylib_get_gesture_pinch_vector( mrb_state *mrb, mrb_value self ) {
	Vector2 ret = GetGesturePinchVector();

	return class_raylib_vector2_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_get_gesture_pinch_angle( mrb_state *mrb, mrb_value self ) {
	float ret = GetGesturePinchAngle();

	return mrb_float_value( mrb, ret );
}

static mrb_value
mod_raylib_update_camera( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Camera*
	mrb_int param1; // int

	mrb_get_args( mrb, "!di", &param0, &param1 );

	UpdateCamera( class_raylib_camera3d_get_ptr( mrb, param0 ), param1 );

	return self;
}

static mrb_value
mod_raylib_update_camera_pro( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Camera*
	mrb_value param1; // Vector3
	mrb_value param2; // Vector3
	mrb_float param3; // float

	mrb_get_args( mrb, "!doof", &param0, &param1, &param2, &param3 );

	UpdateCameraPro( class_raylib_camera3d_get_ptr( mrb, param0 ), *class_raylib_vector3_get_ptr( mrb, param1 ), *class_raylib_vector3_get_ptr( mrb, param2 ), param3 );

	return self;
}

static mrb_value
mod_raylib_set_shapes_texture( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Texture2D
	mrb_value param1; // Rectangle

	mrb_get_args( mrb, "do", &param0, &param1 );

	SetShapesTexture( *class_raylib_texture_get_ptr( mrb, param0 ), *class_raylib_rectangle_get_ptr( mrb, param1 ) );

	return self;
}

static mrb_value
mod_raylib_draw_pixel( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int
	mrb_int param1; // int
	mrb_value param2; // Color

	mrb_get_args( mrb, "iio", &param0, &param1, &param2 );

	DrawPixel( param0, param1, *class_raylib_color_get_ptr( mrb, param2 ) );

	return self;
}

static mrb_value
mod_raylib_draw_pixel_v( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector2
	mrb_value param1; // Color

	mrb_get_args( mrb, "oo", &param0, &param1 );

	DrawPixelV( *class_raylib_vector2_get_ptr( mrb, param0 ), *class_raylib_color_get_ptr( mrb, param1 ) );

	return self;
}

static mrb_value
mod_raylib_draw_line( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int
	mrb_int param1; // int
	mrb_int param2; // int
	mrb_int param3; // int
	mrb_value param4; // Color

	mrb_get_args( mrb, "iiiio", &param0, &param1, &param2, &param3, &param4 );

	DrawLine( param0, param1, param2, param3, *class_raylib_color_get_ptr( mrb, param4 ) );

	return self;
}

static mrb_value
mod_raylib_draw_line_v( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector2
	mrb_value param1; // Vector2
	mrb_value param2; // Color

	mrb_get_args( mrb, "ooo", &param0, &param1, &param2 );

	DrawLineV( *class_raylib_vector2_get_ptr( mrb, param0 ), *class_raylib_vector2_get_ptr( mrb, param1 ), *class_raylib_color_get_ptr( mrb, param2 ) );

	return self;
}

static mrb_value
mod_raylib_draw_line_ex( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector2
	mrb_value param1; // Vector2
	mrb_float param2; // float
	mrb_value param3; // Color

	mrb_get_args( mrb, "oofo", &param0, &param1, &param2, &param3 );

	DrawLineEx( *class_raylib_vector2_get_ptr( mrb, param0 ), *class_raylib_vector2_get_ptr( mrb, param1 ), param2, *class_raylib_color_get_ptr( mrb, param3 ) );

	return self;
}

static mrb_value
mod_raylib_draw_line_strip( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector2*
	mrb_int param1; // int
	mrb_value param2; // Color

	mrb_get_args( mrb, "!dio", &param0, &param1, &param2 );

	DrawLineStrip( class_raylib_vector2_get_ptr( mrb, param0 ), param1, *class_raylib_color_get_ptr( mrb, param2 ) );

	return self;
}

static mrb_value
mod_raylib_draw_line_bezier( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector2
	mrb_value param1; // Vector2
	mrb_float param2; // float
	mrb_value param3; // Color

	mrb_get_args( mrb, "oofo", &param0, &param1, &param2, &param3 );

	DrawLineBezier( *class_raylib_vector2_get_ptr( mrb, param0 ), *class_raylib_vector2_get_ptr( mrb, param1 ), param2, *class_raylib_color_get_ptr( mrb, param3 ) );

	return self;
}

static mrb_value
mod_raylib_draw_circle( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int
	mrb_int param1; // int
	mrb_float param2; // float
	mrb_value param3; // Color

	mrb_get_args( mrb, "iifo", &param0, &param1, &param2, &param3 );

	DrawCircle( param0, param1, param2, *class_raylib_color_get_ptr( mrb, param3 ) );

	return self;
}

static mrb_value
mod_raylib_draw_circle_sector( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector2
	mrb_float param1; // float
	mrb_float param2; // float
	mrb_float param3; // float
	mrb_int param4; // int
	mrb_value param5; // Color

	mrb_get_args( mrb, "offfio", &param0, &param1, &param2, &param3, &param4, &param5 );

	DrawCircleSector( *class_raylib_vector2_get_ptr( mrb, param0 ), param1, param2, param3, param4, *class_raylib_color_get_ptr( mrb, param5 ) );

	return self;
}

static mrb_value
mod_raylib_draw_circle_sector_lines( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector2
	mrb_float param1; // float
	mrb_float param2; // float
	mrb_float param3; // float
	mrb_int param4; // int
	mrb_value param5; // Color

	mrb_get_args( mrb, "offfio", &param0, &param1, &param2, &param3, &param4, &param5 );

	DrawCircleSectorLines( *class_raylib_vector2_get_ptr( mrb, param0 ), param1, param2, param3, param4, *class_raylib_color_get_ptr( mrb, param5 ) );

	return self;
}

static mrb_value
mod_raylib_draw_circle_gradient( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int
	mrb_int param1; // int
	mrb_float param2; // float
	mrb_value param3; // Color
	mrb_value param4; // Color

	mrb_get_args( mrb, "iifoo", &param0, &param1, &param2, &param3, &param4 );

	DrawCircleGradient( param0, param1, param2, *class_raylib_color_get_ptr( mrb, param3 ), *class_raylib_color_get_ptr( mrb, param4 ) );

	return self;
}

static mrb_value
mod_raylib_draw_circle_v( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector2
	mrb_float param1; // float
	mrb_value param2; // Color

	mrb_get_args( mrb, "ofo", &param0, &param1, &param2 );

	DrawCircleV( *class_raylib_vector2_get_ptr( mrb, param0 ), param1, *class_raylib_color_get_ptr( mrb, param2 ) );

	return self;
}

static mrb_value
mod_raylib_draw_circle_lines( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int
	mrb_int param1; // int
	mrb_float param2; // float
	mrb_value param3; // Color

	mrb_get_args( mrb, "iifo", &param0, &param1, &param2, &param3 );

	DrawCircleLines( param0, param1, param2, *class_raylib_color_get_ptr( mrb, param3 ) );

	return self;
}

static mrb_value
mod_raylib_draw_circle_lines_v( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector2
	mrb_float param1; // float
	mrb_value param2; // Color

	mrb_get_args( mrb, "ofo", &param0, &param1, &param2 );

	DrawCircleLinesV( *class_raylib_vector2_get_ptr( mrb, param0 ), param1, *class_raylib_color_get_ptr( mrb, param2 ) );

	return self;
}

static mrb_value
mod_raylib_draw_ellipse( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int
	mrb_int param1; // int
	mrb_float param2; // float
	mrb_float param3; // float
	mrb_value param4; // Color

	mrb_get_args( mrb, "iiffo", &param0, &param1, &param2, &param3, &param4 );

	DrawEllipse( param0, param1, param2, param3, *class_raylib_color_get_ptr( mrb, param4 ) );

	return self;
}

static mrb_value
mod_raylib_draw_ellipse_lines( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int
	mrb_int param1; // int
	mrb_float param2; // float
	mrb_float param3; // float
	mrb_value param4; // Color

	mrb_get_args( mrb, "iiffo", &param0, &param1, &param2, &param3, &param4 );

	DrawEllipseLines( param0, param1, param2, param3, *class_raylib_color_get_ptr( mrb, param4 ) );

	return self;
}

static mrb_value
mod_raylib_draw_ring( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector2
	mrb_float param1; // float
	mrb_float param2; // float
	mrb_float param3; // float
	mrb_float param4; // float
	mrb_int param5; // int
	mrb_value param6; // Color

	mrb_get_args( mrb, "offffio", &param0, &param1, &param2, &param3, &param4, &param5, &param6 );

	DrawRing( *class_raylib_vector2_get_ptr( mrb, param0 ), param1, param2, param3, param4, param5, *class_raylib_color_get_ptr( mrb, param6 ) );

	return self;
}

static mrb_value
mod_raylib_draw_ring_lines( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector2
	mrb_float param1; // float
	mrb_float param2; // float
	mrb_float param3; // float
	mrb_float param4; // float
	mrb_int param5; // int
	mrb_value param6; // Color

	mrb_get_args( mrb, "offffio", &param0, &param1, &param2, &param3, &param4, &param5, &param6 );

	DrawRingLines( *class_raylib_vector2_get_ptr( mrb, param0 ), param1, param2, param3, param4, param5, *class_raylib_color_get_ptr( mrb, param6 ) );

	return self;
}

static mrb_value
mod_raylib_draw_rectangle( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int
	mrb_int param1; // int
	mrb_int param2; // int
	mrb_int param3; // int
	mrb_value param4; // Color

	mrb_get_args( mrb, "iiiio", &param0, &param1, &param2, &param3, &param4 );

	DrawRectangle( param0, param1, param2, param3, *class_raylib_color_get_ptr( mrb, param4 ) );

	return self;
}

static mrb_value
mod_raylib_draw_rectangle_v( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector2
	mrb_value param1; // Vector2
	mrb_value param2; // Color

	mrb_get_args( mrb, "ooo", &param0, &param1, &param2 );

	DrawRectangleV( *class_raylib_vector2_get_ptr( mrb, param0 ), *class_raylib_vector2_get_ptr( mrb, param1 ), *class_raylib_color_get_ptr( mrb, param2 ) );

	return self;
}

static mrb_value
mod_raylib_draw_rectangle_rec( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Rectangle
	mrb_value param1; // Color

	mrb_get_args( mrb, "oo", &param0, &param1 );

	DrawRectangleRec( *class_raylib_rectangle_get_ptr( mrb, param0 ), *class_raylib_color_get_ptr( mrb, param1 ) );

	return self;
}

static mrb_value
mod_raylib_draw_rectangle_pro( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Rectangle
	mrb_value param1; // Vector2
	mrb_float param2; // float
	mrb_value param3; // Color

	mrb_get_args( mrb, "oofo", &param0, &param1, &param2, &param3 );

	DrawRectanglePro( *class_raylib_rectangle_get_ptr( mrb, param0 ), *class_raylib_vector2_get_ptr( mrb, param1 ), param2, *class_raylib_color_get_ptr( mrb, param3 ) );

	return self;
}

static mrb_value
mod_raylib_draw_rectangle_gradient_v( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int
	mrb_int param1; // int
	mrb_int param2; // int
	mrb_int param3; // int
	mrb_value param4; // Color
	mrb_value param5; // Color

	mrb_get_args( mrb, "iiiioo", &param0, &param1, &param2, &param3, &param4, &param5 );

	DrawRectangleGradientV( param0, param1, param2, param3, *class_raylib_color_get_ptr( mrb, param4 ), *class_raylib_color_get_ptr( mrb, param5 ) );

	return self;
}

static mrb_value
mod_raylib_draw_rectangle_gradient_h( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int
	mrb_int param1; // int
	mrb_int param2; // int
	mrb_int param3; // int
	mrb_value param4; // Color
	mrb_value param5; // Color

	mrb_get_args( mrb, "iiiioo", &param0, &param1, &param2, &param3, &param4, &param5 );

	DrawRectangleGradientH( param0, param1, param2, param3, *class_raylib_color_get_ptr( mrb, param4 ), *class_raylib_color_get_ptr( mrb, param5 ) );

	return self;
}

static mrb_value
mod_raylib_draw_rectangle_gradient_ex( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Rectangle
	mrb_value param1; // Color
	mrb_value param2; // Color
	mrb_value param3; // Color
	mrb_value param4; // Color

	mrb_get_args( mrb, "ooooo", &param0, &param1, &param2, &param3, &param4 );

	DrawRectangleGradientEx( *class_raylib_rectangle_get_ptr( mrb, param0 ), *class_raylib_color_get_ptr( mrb, param1 ), *class_raylib_color_get_ptr( mrb, param2 ), *class_raylib_color_get_ptr( mrb, param3 ), *class_raylib_color_get_ptr( mrb, param4 ) );

	return self;
}

static mrb_value
mod_raylib_draw_rectangle_lines( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int
	mrb_int param1; // int
	mrb_int param2; // int
	mrb_int param3; // int
	mrb_value param4; // Color

	mrb_get_args( mrb, "iiiio", &param0, &param1, &param2, &param3, &param4 );

	DrawRectangleLines( param0, param1, param2, param3, *class_raylib_color_get_ptr( mrb, param4 ) );

	return self;
}

static mrb_value
mod_raylib_draw_rectangle_lines_ex( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Rectangle
	mrb_float param1; // float
	mrb_value param2; // Color

	mrb_get_args( mrb, "ofo", &param0, &param1, &param2 );

	DrawRectangleLinesEx( *class_raylib_rectangle_get_ptr( mrb, param0 ), param1, *class_raylib_color_get_ptr( mrb, param2 ) );

	return self;
}

static mrb_value
mod_raylib_draw_rectangle_rounded( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Rectangle
	mrb_float param1; // float
	mrb_int param2; // int
	mrb_value param3; // Color

	mrb_get_args( mrb, "ofio", &param0, &param1, &param2, &param3 );

	DrawRectangleRounded( *class_raylib_rectangle_get_ptr( mrb, param0 ), param1, param2, *class_raylib_color_get_ptr( mrb, param3 ) );

	return self;
}

static mrb_value
mod_raylib_draw_rectangle_rounded_lines( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Rectangle
	mrb_float param1; // float
	mrb_int param2; // int
	mrb_float param3; // float
	mrb_value param4; // Color

	mrb_get_args( mrb, "ofifo", &param0, &param1, &param2, &param3, &param4 );

	DrawRectangleRoundedLines( *class_raylib_rectangle_get_ptr( mrb, param0 ), param1, param2, param3, *class_raylib_color_get_ptr( mrb, param4 ) );

	return self;
}

static mrb_value
mod_raylib_draw_triangle( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector2
	mrb_value param1; // Vector2
	mrb_value param2; // Vector2
	mrb_value param3; // Color

	mrb_get_args( mrb, "oooo", &param0, &param1, &param2, &param3 );

	DrawTriangle( *class_raylib_vector2_get_ptr( mrb, param0 ), *class_raylib_vector2_get_ptr( mrb, param1 ), *class_raylib_vector2_get_ptr( mrb, param2 ), *class_raylib_color_get_ptr( mrb, param3 ) );

	return self;
}

static mrb_value
mod_raylib_draw_triangle_lines( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector2
	mrb_value param1; // Vector2
	mrb_value param2; // Vector2
	mrb_value param3; // Color

	mrb_get_args( mrb, "oooo", &param0, &param1, &param2, &param3 );

	DrawTriangleLines( *class_raylib_vector2_get_ptr( mrb, param0 ), *class_raylib_vector2_get_ptr( mrb, param1 ), *class_raylib_vector2_get_ptr( mrb, param2 ), *class_raylib_color_get_ptr( mrb, param3 ) );

	return self;
}

static mrb_value
mod_raylib_draw_triangle_fan( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector2*
	mrb_int param1; // int
	mrb_value param2; // Color

	mrb_get_args( mrb, "!dio", &param0, &param1, &param2 );

	DrawTriangleFan( class_raylib_vector2_get_ptr( mrb, param0 ), param1, *class_raylib_color_get_ptr( mrb, param2 ) );

	return self;
}

static mrb_value
mod_raylib_draw_triangle_strip( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector2*
	mrb_int param1; // int
	mrb_value param2; // Color

	mrb_get_args( mrb, "!dio", &param0, &param1, &param2 );

	DrawTriangleStrip( class_raylib_vector2_get_ptr( mrb, param0 ), param1, *class_raylib_color_get_ptr( mrb, param2 ) );

	return self;
}

static mrb_value
mod_raylib_draw_poly( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector2
	mrb_int param1; // int
	mrb_float param2; // float
	mrb_float param3; // float
	mrb_value param4; // Color

	mrb_get_args( mrb, "oiffo", &param0, &param1, &param2, &param3, &param4 );

	DrawPoly( *class_raylib_vector2_get_ptr( mrb, param0 ), param1, param2, param3, *class_raylib_color_get_ptr( mrb, param4 ) );

	return self;
}

static mrb_value
mod_raylib_draw_poly_lines( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector2
	mrb_int param1; // int
	mrb_float param2; // float
	mrb_float param3; // float
	mrb_value param4; // Color

	mrb_get_args( mrb, "oiffo", &param0, &param1, &param2, &param3, &param4 );

	DrawPolyLines( *class_raylib_vector2_get_ptr( mrb, param0 ), param1, param2, param3, *class_raylib_color_get_ptr( mrb, param4 ) );

	return self;
}

static mrb_value
mod_raylib_draw_poly_lines_ex( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector2
	mrb_int param1; // int
	mrb_float param2; // float
	mrb_float param3; // float
	mrb_float param4; // float
	mrb_value param5; // Color

	mrb_get_args( mrb, "oifffo", &param0, &param1, &param2, &param3, &param4, &param5 );

	DrawPolyLinesEx( *class_raylib_vector2_get_ptr( mrb, param0 ), param1, param2, param3, param4, *class_raylib_color_get_ptr( mrb, param5 ) );

	return self;
}

static mrb_value
mod_raylib_draw_spline_linear( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector2*
	mrb_int param1; // int
	mrb_float param2; // float
	mrb_value param3; // Color

	mrb_get_args( mrb, "!difo", &param0, &param1, &param2, &param3 );

	DrawSplineLinear( class_raylib_vector2_get_ptr( mrb, param0 ), param1, param2, *class_raylib_color_get_ptr( mrb, param3 ) );

	return self;
}

static mrb_value
mod_raylib_draw_spline_basis( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector2*
	mrb_int param1; // int
	mrb_float param2; // float
	mrb_value param3; // Color

	mrb_get_args( mrb, "!difo", &param0, &param1, &param2, &param3 );

	DrawSplineBasis( class_raylib_vector2_get_ptr( mrb, param0 ), param1, param2, *class_raylib_color_get_ptr( mrb, param3 ) );

	return self;
}

static mrb_value
mod_raylib_draw_spline_catmull_rom( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector2*
	mrb_int param1; // int
	mrb_float param2; // float
	mrb_value param3; // Color

	mrb_get_args( mrb, "!difo", &param0, &param1, &param2, &param3 );

	DrawSplineCatmullRom( class_raylib_vector2_get_ptr( mrb, param0 ), param1, param2, *class_raylib_color_get_ptr( mrb, param3 ) );

	return self;
}

static mrb_value
mod_raylib_draw_spline_bezier_quadratic( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector2*
	mrb_int param1; // int
	mrb_float param2; // float
	mrb_value param3; // Color

	mrb_get_args( mrb, "!difo", &param0, &param1, &param2, &param3 );

	DrawSplineBezierQuadratic( class_raylib_vector2_get_ptr( mrb, param0 ), param1, param2, *class_raylib_color_get_ptr( mrb, param3 ) );

	return self;
}

static mrb_value
mod_raylib_draw_spline_bezier_cubic( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector2*
	mrb_int param1; // int
	mrb_float param2; // float
	mrb_value param3; // Color

	mrb_get_args( mrb, "!difo", &param0, &param1, &param2, &param3 );

	DrawSplineBezierCubic( class_raylib_vector2_get_ptr( mrb, param0 ), param1, param2, *class_raylib_color_get_ptr( mrb, param3 ) );

	return self;
}

static mrb_value
mod_raylib_draw_spline_segment_linear( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector2
	mrb_value param1; // Vector2
	mrb_float param2; // float
	mrb_value param3; // Color

	mrb_get_args( mrb, "oofo", &param0, &param1, &param2, &param3 );

	DrawSplineSegmentLinear( *class_raylib_vector2_get_ptr( mrb, param0 ), *class_raylib_vector2_get_ptr( mrb, param1 ), param2, *class_raylib_color_get_ptr( mrb, param3 ) );

	return self;
}

static mrb_value
mod_raylib_draw_spline_segment_basis( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector2
	mrb_value param1; // Vector2
	mrb_value param2; // Vector2
	mrb_value param3; // Vector2
	mrb_float param4; // float
	mrb_value param5; // Color

	mrb_get_args( mrb, "oooofo", &param0, &param1, &param2, &param3, &param4, &param5 );

	DrawSplineSegmentBasis( *class_raylib_vector2_get_ptr( mrb, param0 ), *class_raylib_vector2_get_ptr( mrb, param1 ), *class_raylib_vector2_get_ptr( mrb, param2 ), *class_raylib_vector2_get_ptr( mrb, param3 ), param4, *class_raylib_color_get_ptr( mrb, param5 ) );

	return self;
}

static mrb_value
mod_raylib_draw_spline_segment_catmull_rom( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector2
	mrb_value param1; // Vector2
	mrb_value param2; // Vector2
	mrb_value param3; // Vector2
	mrb_float param4; // float
	mrb_value param5; // Color

	mrb_get_args( mrb, "oooofo", &param0, &param1, &param2, &param3, &param4, &param5 );

	DrawSplineSegmentCatmullRom( *class_raylib_vector2_get_ptr( mrb, param0 ), *class_raylib_vector2_get_ptr( mrb, param1 ), *class_raylib_vector2_get_ptr( mrb, param2 ), *class_raylib_vector2_get_ptr( mrb, param3 ), param4, *class_raylib_color_get_ptr( mrb, param5 ) );

	return self;
}

static mrb_value
mod_raylib_draw_spline_segment_bezier_quadratic( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector2
	mrb_value param1; // Vector2
	mrb_value param2; // Vector2
	mrb_float param3; // float
	mrb_value param4; // Color

	mrb_get_args( mrb, "ooofo", &param0, &param1, &param2, &param3, &param4 );

	DrawSplineSegmentBezierQuadratic( *class_raylib_vector2_get_ptr( mrb, param0 ), *class_raylib_vector2_get_ptr( mrb, param1 ), *class_raylib_vector2_get_ptr( mrb, param2 ), param3, *class_raylib_color_get_ptr( mrb, param4 ) );

	return self;
}

static mrb_value
mod_raylib_draw_spline_segment_bezier_cubic( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector2
	mrb_value param1; // Vector2
	mrb_value param2; // Vector2
	mrb_value param3; // Vector2
	mrb_float param4; // float
	mrb_value param5; // Color

	mrb_get_args( mrb, "oooofo", &param0, &param1, &param2, &param3, &param4, &param5 );

	DrawSplineSegmentBezierCubic( *class_raylib_vector2_get_ptr( mrb, param0 ), *class_raylib_vector2_get_ptr( mrb, param1 ), *class_raylib_vector2_get_ptr( mrb, param2 ), *class_raylib_vector2_get_ptr( mrb, param3 ), param4, *class_raylib_color_get_ptr( mrb, param5 ) );

	return self;
}

static mrb_value
mod_raylib_get_spline_point_linear( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector2
	mrb_value param1; // Vector2
	mrb_float param2; // float

	mrb_get_args( mrb, "oof", &param0, &param1, &param2 );

	Vector2 ret = GetSplinePointLinear( *class_raylib_vector2_get_ptr( mrb, param0 ), *class_raylib_vector2_get_ptr( mrb, param1 ), param2 );

	return class_raylib_vector2_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_get_spline_point_basis( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector2
	mrb_value param1; // Vector2
	mrb_value param2; // Vector2
	mrb_value param3; // Vector2
	mrb_float param4; // float

	mrb_get_args( mrb, "oooof", &param0, &param1, &param2, &param3, &param4 );

	Vector2 ret = GetSplinePointBasis( *class_raylib_vector2_get_ptr( mrb, param0 ), *class_raylib_vector2_get_ptr( mrb, param1 ), *class_raylib_vector2_get_ptr( mrb, param2 ), *class_raylib_vector2_get_ptr( mrb, param3 ), param4 );

	return class_raylib_vector2_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_get_spline_point_catmull_rom( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector2
	mrb_value param1; // Vector2
	mrb_value param2; // Vector2
	mrb_value param3; // Vector2
	mrb_float param4; // float

	mrb_get_args( mrb, "oooof", &param0, &param1, &param2, &param3, &param4 );

	Vector2 ret = GetSplinePointCatmullRom( *class_raylib_vector2_get_ptr( mrb, param0 ), *class_raylib_vector2_get_ptr( mrb, param1 ), *class_raylib_vector2_get_ptr( mrb, param2 ), *class_raylib_vector2_get_ptr( mrb, param3 ), param4 );

	return class_raylib_vector2_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_get_spline_point_bezier_quad( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector2
	mrb_value param1; // Vector2
	mrb_value param2; // Vector2
	mrb_float param3; // float

	mrb_get_args( mrb, "ooof", &param0, &param1, &param2, &param3 );

	Vector2 ret = GetSplinePointBezierQuad( *class_raylib_vector2_get_ptr( mrb, param0 ), *class_raylib_vector2_get_ptr( mrb, param1 ), *class_raylib_vector2_get_ptr( mrb, param2 ), param3 );

	return class_raylib_vector2_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_get_spline_point_bezier_cubic( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector2
	mrb_value param1; // Vector2
	mrb_value param2; // Vector2
	mrb_value param3; // Vector2
	mrb_float param4; // float

	mrb_get_args( mrb, "oooof", &param0, &param1, &param2, &param3, &param4 );

	Vector2 ret = GetSplinePointBezierCubic( *class_raylib_vector2_get_ptr( mrb, param0 ), *class_raylib_vector2_get_ptr( mrb, param1 ), *class_raylib_vector2_get_ptr( mrb, param2 ), *class_raylib_vector2_get_ptr( mrb, param3 ), param4 );

	return class_raylib_vector2_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_check_collision_recs( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Rectangle
	mrb_value param1; // Rectangle

	mrb_get_args( mrb, "oo", &param0, &param1 );

	bool ret = CheckCollisionRecs( *class_raylib_rectangle_get_ptr( mrb, param0 ), *class_raylib_rectangle_get_ptr( mrb, param1 ) );

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_check_collision_circles( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector2
	mrb_float param1; // float
	mrb_value param2; // Vector2
	mrb_float param3; // float

	mrb_get_args( mrb, "ofof", &param0, &param1, &param2, &param3 );

	bool ret = CheckCollisionCircles( *class_raylib_vector2_get_ptr( mrb, param0 ), param1, *class_raylib_vector2_get_ptr( mrb, param2 ), param3 );

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_check_collision_circle_rec( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector2
	mrb_float param1; // float
	mrb_value param2; // Rectangle

	mrb_get_args( mrb, "ofo", &param0, &param1, &param2 );

	bool ret = CheckCollisionCircleRec( *class_raylib_vector2_get_ptr( mrb, param0 ), param1, *class_raylib_rectangle_get_ptr( mrb, param2 ) );

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_check_collision_point_rec( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector2
	mrb_value param1; // Rectangle

	mrb_get_args( mrb, "oo", &param0, &param1 );

	bool ret = CheckCollisionPointRec( *class_raylib_vector2_get_ptr( mrb, param0 ), *class_raylib_rectangle_get_ptr( mrb, param1 ) );

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_check_collision_point_circle( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector2
	mrb_value param1; // Vector2
	mrb_float param2; // float

	mrb_get_args( mrb, "oof", &param0, &param1, &param2 );

	bool ret = CheckCollisionPointCircle( *class_raylib_vector2_get_ptr( mrb, param0 ), *class_raylib_vector2_get_ptr( mrb, param1 ), param2 );

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_check_collision_point_triangle( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector2
	mrb_value param1; // Vector2
	mrb_value param2; // Vector2
	mrb_value param3; // Vector2

	mrb_get_args( mrb, "oooo", &param0, &param1, &param2, &param3 );

	bool ret = CheckCollisionPointTriangle( *class_raylib_vector2_get_ptr( mrb, param0 ), *class_raylib_vector2_get_ptr( mrb, param1 ), *class_raylib_vector2_get_ptr( mrb, param2 ), *class_raylib_vector2_get_ptr( mrb, param3 ) );

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_check_collision_point_poly( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector2
	mrb_value param1; // Vector2*
	mrb_int param2; // int

	mrb_get_args( mrb, "o!di", &param0, &param1, &param2 );

	bool ret = CheckCollisionPointPoly( *class_raylib_vector2_get_ptr( mrb, param0 ), class_raylib_vector2_get_ptr( mrb, param1 ), param2 );

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_check_collision_lines( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector2
	mrb_value param1; // Vector2
	mrb_value param2; // Vector2
	mrb_value param3; // Vector2
	mrb_value param4; // Vector2*

	mrb_get_args( mrb, "oooo!d", &param0, &param1, &param2, &param3, &param4 );

	bool ret = CheckCollisionLines( *class_raylib_vector2_get_ptr( mrb, param0 ), *class_raylib_vector2_get_ptr( mrb, param1 ), *class_raylib_vector2_get_ptr( mrb, param2 ), *class_raylib_vector2_get_ptr( mrb, param3 ), class_raylib_vector2_get_ptr( mrb, param4 ) );

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_check_collision_point_line( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector2
	mrb_value param1; // Vector2
	mrb_value param2; // Vector2
	mrb_int param3; // int

	mrb_get_args( mrb, "oooi", &param0, &param1, &param2, &param3 );

	bool ret = CheckCollisionPointLine( *class_raylib_vector2_get_ptr( mrb, param0 ), *class_raylib_vector2_get_ptr( mrb, param1 ), *class_raylib_vector2_get_ptr( mrb, param2 ), param3 );

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_get_collision_rec( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Rectangle
	mrb_value param1; // Rectangle

	mrb_get_args( mrb, "oo", &param0, &param1 );

	Rectangle ret = GetCollisionRec( *class_raylib_rectangle_get_ptr( mrb, param0 ), *class_raylib_rectangle_get_ptr( mrb, param1 ) );

	return class_raylib_rectangle_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_load_image( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const char*

	mrb_get_args( mrb, "S", &param0 );

	Image ret = LoadImage( RSTRING_PTR( param0 ) );

	return class_raylib_image_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_load_image_raw( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const char*
	mrb_int param1; // int
	mrb_int param2; // int
	mrb_int param3; // int
	mrb_int param4; // int

	mrb_get_args( mrb, "Siiii", &param0, &param1, &param2, &param3, &param4 );

	Image ret = LoadImageRaw( RSTRING_PTR( param0 ), param1, param2, param3, param4 );

	return class_raylib_image_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_load_image_svg( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const char*
	mrb_int param1; // int
	mrb_int param2; // int

	mrb_get_args( mrb, "Sii", &param0, &param1, &param2 );

	Image ret = LoadImageSvg( RSTRING_PTR( param0 ), param1, param2 );

	return class_raylib_image_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_load_image_anim( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const char*
	mrb_value param1; // int*

	mrb_get_args( mrb, "S*", &param0, &param1 );

	Image ret = LoadImageAnim( RSTRING_PTR( param0 ), mrb_cptr( param1 ) );

	return class_raylib_image_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_load_image_from_memory( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const char*
	mrb_value param1; // const unsigned char*
	mrb_int param2; // int

	mrb_get_args( mrb, "S!di", &param0, &param1, &param2 );

	Image ret = LoadImageFromMemory( RSTRING_PTR( param0 ), NULL, param2 );

	return class_raylib_image_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_load_image_from_texture( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Texture2D

	mrb_get_args( mrb, "d", &param0 );

	Image ret = LoadImageFromTexture( *class_raylib_texture_get_ptr( mrb, param0 ) );

	return class_raylib_image_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_load_image_from_screen( mrb_state *mrb, mrb_value self ) {
	Image ret = LoadImageFromScreen();

	return class_raylib_image_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_is_image_ready( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Image

	mrb_get_args( mrb, "o", &param0 );

	bool ret = IsImageReady( *class_raylib_image_get_ptr( mrb, param0 ) );

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_unload_image( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Image

	mrb_get_args( mrb, "o", &param0 );

	UnloadImage( *class_raylib_image_get_ptr( mrb, param0 ) );

	return self;
}

static mrb_value
mod_raylib_export_image( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Image
	mrb_value param1; // const char*

	mrb_get_args( mrb, "oS", &param0, &param1 );

	bool ret = ExportImage( *class_raylib_image_get_ptr( mrb, param0 ), RSTRING_PTR( param1 ) );

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_export_image_to_memory( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Image
	mrb_value param1; // const char*
	mrb_value param2; // int*

	mrb_get_args( mrb, "oS*", &param0, &param1, &param2 );

	unsigned char* ret = ExportImageToMemory( *class_raylib_image_get_ptr( mrb, param0 ), RSTRING_PTR( param1 ), mrb_cptr( param2 ) );

	return mrb_cptr_value( mrb, ( void* )( ret ) );
}

static mrb_value
mod_raylib_export_image_as_code( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Image
	mrb_value param1; // const char*

	mrb_get_args( mrb, "oS", &param0, &param1 );

	bool ret = ExportImageAsCode( *class_raylib_image_get_ptr( mrb, param0 ), RSTRING_PTR( param1 ) );

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_gen_image_color( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int
	mrb_int param1; // int
	mrb_value param2; // Color

	mrb_get_args( mrb, "iio", &param0, &param1, &param2 );

	Image ret = GenImageColor( param0, param1, *class_raylib_color_get_ptr( mrb, param2 ) );

	return class_raylib_image_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_gen_image_gradient_linear( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int
	mrb_int param1; // int
	mrb_int param2; // int
	mrb_value param3; // Color
	mrb_value param4; // Color

	mrb_get_args( mrb, "iiioo", &param0, &param1, &param2, &param3, &param4 );

	Image ret = GenImageGradientLinear( param0, param1, param2, *class_raylib_color_get_ptr( mrb, param3 ), *class_raylib_color_get_ptr( mrb, param4 ) );

	return class_raylib_image_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_gen_image_gradient_radial( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int
	mrb_int param1; // int
	mrb_float param2; // float
	mrb_value param3; // Color
	mrb_value param4; // Color

	mrb_get_args( mrb, "iifoo", &param0, &param1, &param2, &param3, &param4 );

	Image ret = GenImageGradientRadial( param0, param1, param2, *class_raylib_color_get_ptr( mrb, param3 ), *class_raylib_color_get_ptr( mrb, param4 ) );

	return class_raylib_image_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_gen_image_gradient_square( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int
	mrb_int param1; // int
	mrb_float param2; // float
	mrb_value param3; // Color
	mrb_value param4; // Color

	mrb_get_args( mrb, "iifoo", &param0, &param1, &param2, &param3, &param4 );

	Image ret = GenImageGradientSquare( param0, param1, param2, *class_raylib_color_get_ptr( mrb, param3 ), *class_raylib_color_get_ptr( mrb, param4 ) );

	return class_raylib_image_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_gen_image_checked( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int
	mrb_int param1; // int
	mrb_int param2; // int
	mrb_int param3; // int
	mrb_value param4; // Color
	mrb_value param5; // Color

	mrb_get_args( mrb, "iiiioo", &param0, &param1, &param2, &param3, &param4, &param5 );

	Image ret = GenImageChecked( param0, param1, param2, param3, *class_raylib_color_get_ptr( mrb, param4 ), *class_raylib_color_get_ptr( mrb, param5 ) );

	return class_raylib_image_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_gen_image_white_noise( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int
	mrb_int param1; // int
	mrb_float param2; // float

	mrb_get_args( mrb, "iif", &param0, &param1, &param2 );

	Image ret = GenImageWhiteNoise( param0, param1, param2 );

	return class_raylib_image_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_gen_image_perlin_noise( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int
	mrb_int param1; // int
	mrb_int param2; // int
	mrb_int param3; // int
	mrb_float param4; // float

	mrb_get_args( mrb, "iiiif", &param0, &param1, &param2, &param3, &param4 );

	Image ret = GenImagePerlinNoise( param0, param1, param2, param3, param4 );

	return class_raylib_image_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_gen_image_cellular( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int
	mrb_int param1; // int
	mrb_int param2; // int

	mrb_get_args( mrb, "iii", &param0, &param1, &param2 );

	Image ret = GenImageCellular( param0, param1, param2 );

	return class_raylib_image_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_gen_image_text( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int
	mrb_int param1; // int
	mrb_value param2; // const char*

	mrb_get_args( mrb, "iiS", &param0, &param1, &param2 );

	Image ret = GenImageText( param0, param1, RSTRING_PTR( param2 ) );

	return class_raylib_image_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_image_copy( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Image

	mrb_get_args( mrb, "o", &param0 );

	Image ret = ImageCopy( *class_raylib_image_get_ptr( mrb, param0 ) );

	return class_raylib_image_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_image_from_image( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Image
	mrb_value param1; // Rectangle

	mrb_get_args( mrb, "oo", &param0, &param1 );

	Image ret = ImageFromImage( *class_raylib_image_get_ptr( mrb, param0 ), *class_raylib_rectangle_get_ptr( mrb, param1 ) );

	return class_raylib_image_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_image_text( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const char*
	mrb_int param1; // int
	mrb_value param2; // Color

	mrb_get_args( mrb, "Sio", &param0, &param1, &param2 );

	Image ret = ImageText( RSTRING_PTR( param0 ), param1, *class_raylib_color_get_ptr( mrb, param2 ) );

	return class_raylib_image_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_image_text_ex( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Font
	mrb_value param1; // const char*
	mrb_float param2; // float
	mrb_float param3; // float
	mrb_value param4; // Color

	mrb_get_args( mrb, "oSffo", &param0, &param1, &param2, &param3, &param4 );

	Image ret = ImageTextEx( *class_raylib_font_get_ptr( mrb, param0 ), RSTRING_PTR( param1 ), param2, param3, *class_raylib_color_get_ptr( mrb, param4 ) );

	return class_raylib_image_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_image_format( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Image*
	mrb_int param1; // int

	mrb_get_args( mrb, "!di", &param0, &param1 );

	ImageFormat( class_raylib_image_get_ptr( mrb, param0 ), param1 );

	return self;
}

static mrb_value
mod_raylib_image_to_pot( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Image*
	mrb_value param1; // Color

	mrb_get_args( mrb, "!do", &param0, &param1 );

	ImageToPOT( class_raylib_image_get_ptr( mrb, param0 ), *class_raylib_color_get_ptr( mrb, param1 ) );

	return self;
}

static mrb_value
mod_raylib_image_crop( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Image*
	mrb_value param1; // Rectangle

	mrb_get_args( mrb, "!do", &param0, &param1 );

	ImageCrop( class_raylib_image_get_ptr( mrb, param0 ), *class_raylib_rectangle_get_ptr( mrb, param1 ) );

	return self;
}

static mrb_value
mod_raylib_image_alpha_crop( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Image*
	mrb_float param1; // float

	mrb_get_args( mrb, "!df", &param0, &param1 );

	ImageAlphaCrop( class_raylib_image_get_ptr( mrb, param0 ), param1 );

	return self;
}

static mrb_value
mod_raylib_image_alpha_clear( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Image*
	mrb_value param1; // Color
	mrb_float param2; // float

	mrb_get_args( mrb, "!dof", &param0, &param1, &param2 );

	ImageAlphaClear( class_raylib_image_get_ptr( mrb, param0 ), *class_raylib_color_get_ptr( mrb, param1 ), param2 );

	return self;
}

static mrb_value
mod_raylib_image_alpha_mask( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Image*
	mrb_value param1; // Image

	mrb_get_args( mrb, "!do", &param0, &param1 );

	ImageAlphaMask( class_raylib_image_get_ptr( mrb, param0 ), *class_raylib_image_get_ptr( mrb, param1 ) );

	return self;
}

static mrb_value
mod_raylib_image_alpha_premultiply( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Image*

	mrb_get_args( mrb, "!d", &param0 );

	ImageAlphaPremultiply( class_raylib_image_get_ptr( mrb, param0 ) );

	return self;
}

static mrb_value
mod_raylib_image_blur_gaussian( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Image*
	mrb_int param1; // int

	mrb_get_args( mrb, "!di", &param0, &param1 );

	ImageBlurGaussian( class_raylib_image_get_ptr( mrb, param0 ), param1 );

	return self;
}

static mrb_value
mod_raylib_image_resize( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Image*
	mrb_int param1; // int
	mrb_int param2; // int

	mrb_get_args( mrb, "!dii", &param0, &param1, &param2 );

	ImageResize( class_raylib_image_get_ptr( mrb, param0 ), param1, param2 );

	return self;
}

static mrb_value
mod_raylib_image_resize_nn( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Image*
	mrb_int param1; // int
	mrb_int param2; // int

	mrb_get_args( mrb, "!dii", &param0, &param1, &param2 );

	ImageResizeNN( class_raylib_image_get_ptr( mrb, param0 ), param1, param2 );

	return self;
}

static mrb_value
mod_raylib_image_resize_canvas( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Image*
	mrb_int param1; // int
	mrb_int param2; // int
	mrb_int param3; // int
	mrb_int param4; // int
	mrb_value param5; // Color

	mrb_get_args( mrb, "!diiiio", &param0, &param1, &param2, &param3, &param4, &param5 );

	ImageResizeCanvas( class_raylib_image_get_ptr( mrb, param0 ), param1, param2, param3, param4, *class_raylib_color_get_ptr( mrb, param5 ) );

	return self;
}

static mrb_value
mod_raylib_image_mipmaps( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Image*

	mrb_get_args( mrb, "!d", &param0 );

	ImageMipmaps( class_raylib_image_get_ptr( mrb, param0 ) );

	return self;
}

static mrb_value
mod_raylib_image_dither( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Image*
	mrb_int param1; // int
	mrb_int param2; // int
	mrb_int param3; // int
	mrb_int param4; // int

	mrb_get_args( mrb, "!diiii", &param0, &param1, &param2, &param3, &param4 );

	ImageDither( class_raylib_image_get_ptr( mrb, param0 ), param1, param2, param3, param4 );

	return self;
}

static mrb_value
mod_raylib_image_flip_vertical( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Image*

	mrb_get_args( mrb, "!d", &param0 );

	ImageFlipVertical( class_raylib_image_get_ptr( mrb, param0 ) );

	return self;
}

static mrb_value
mod_raylib_image_flip_horizontal( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Image*

	mrb_get_args( mrb, "!d", &param0 );

	ImageFlipHorizontal( class_raylib_image_get_ptr( mrb, param0 ) );

	return self;
}

static mrb_value
mod_raylib_image_rotate( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Image*
	mrb_int param1; // int

	mrb_get_args( mrb, "!di", &param0, &param1 );

	ImageRotate( class_raylib_image_get_ptr( mrb, param0 ), param1 );

	return self;
}

static mrb_value
mod_raylib_image_rotate_cw( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Image*

	mrb_get_args( mrb, "!d", &param0 );

	ImageRotateCW( class_raylib_image_get_ptr( mrb, param0 ) );

	return self;
}

static mrb_value
mod_raylib_image_rotate_ccw( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Image*

	mrb_get_args( mrb, "!d", &param0 );

	ImageRotateCCW( class_raylib_image_get_ptr( mrb, param0 ) );

	return self;
}

static mrb_value
mod_raylib_image_color_tint( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Image*
	mrb_value param1; // Color

	mrb_get_args( mrb, "!do", &param0, &param1 );

	ImageColorTint( class_raylib_image_get_ptr( mrb, param0 ), *class_raylib_color_get_ptr( mrb, param1 ) );

	return self;
}

static mrb_value
mod_raylib_image_color_invert( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Image*

	mrb_get_args( mrb, "!d", &param0 );

	ImageColorInvert( class_raylib_image_get_ptr( mrb, param0 ) );

	return self;
}

static mrb_value
mod_raylib_image_color_grayscale( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Image*

	mrb_get_args( mrb, "!d", &param0 );

	ImageColorGrayscale( class_raylib_image_get_ptr( mrb, param0 ) );

	return self;
}

static mrb_value
mod_raylib_image_color_contrast( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Image*
	mrb_float param1; // float

	mrb_get_args( mrb, "!df", &param0, &param1 );

	ImageColorContrast( class_raylib_image_get_ptr( mrb, param0 ), param1 );

	return self;
}

static mrb_value
mod_raylib_image_color_brightness( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Image*
	mrb_int param1; // int

	mrb_get_args( mrb, "!di", &param0, &param1 );

	ImageColorBrightness( class_raylib_image_get_ptr( mrb, param0 ), param1 );

	return self;
}

static mrb_value
mod_raylib_image_color_replace( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Image*
	mrb_value param1; // Color
	mrb_value param2; // Color

	mrb_get_args( mrb, "!doo", &param0, &param1, &param2 );

	ImageColorReplace( class_raylib_image_get_ptr( mrb, param0 ), *class_raylib_color_get_ptr( mrb, param1 ), *class_raylib_color_get_ptr( mrb, param2 ) );

	return self;
}

static mrb_value
mod_raylib_load_image_colors( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Image

	mrb_get_args( mrb, "o", &param0 );

	Color* ret = LoadImageColors( *class_raylib_image_get_ptr( mrb, param0 ) );

	return class_raylib_color_2_mrbvalue( mrb, ret, 0 );
}

static mrb_value
mod_raylib_load_image_palette( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Image
	mrb_int param1; // int
	mrb_value param2; // int*

	mrb_get_args( mrb, "oi*", &param0, &param1, &param2 );

	Color* ret = LoadImagePalette( *class_raylib_image_get_ptr( mrb, param0 ), param1, mrb_cptr( param2 ) );

	return class_raylib_color_2_mrbvalue( mrb, ret, 0 );
}

static mrb_value
mod_raylib_unload_image_colors( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Color*

	mrb_get_args( mrb, "!d", &param0 );

	UnloadImageColors( class_raylib_color_get_ptr( mrb, param0 ) );

	return self;
}

static mrb_value
mod_raylib_unload_image_palette( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Color*

	mrb_get_args( mrb, "!d", &param0 );

	UnloadImagePalette( class_raylib_color_get_ptr( mrb, param0 ) );

	return self;
}

static mrb_value
mod_raylib_get_image_alpha_border( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Image
	mrb_float param1; // float

	mrb_get_args( mrb, "of", &param0, &param1 );

	Rectangle ret = GetImageAlphaBorder( *class_raylib_image_get_ptr( mrb, param0 ), param1 );

	return class_raylib_rectangle_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_get_image_color( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Image
	mrb_int param1; // int
	mrb_int param2; // int

	mrb_get_args( mrb, "oii", &param0, &param1, &param2 );

	Color ret = GetImageColor( *class_raylib_image_get_ptr( mrb, param0 ), param1, param2 );

	return class_raylib_color_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_image_clear_background( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Image*
	mrb_value param1; // Color

	mrb_get_args( mrb, "!do", &param0, &param1 );

	ImageClearBackground( class_raylib_image_get_ptr( mrb, param0 ), *class_raylib_color_get_ptr( mrb, param1 ) );

	return self;
}

static mrb_value
mod_raylib_image_draw_pixel( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Image*
	mrb_int param1; // int
	mrb_int param2; // int
	mrb_value param3; // Color

	mrb_get_args( mrb, "!diio", &param0, &param1, &param2, &param3 );

	ImageDrawPixel( class_raylib_image_get_ptr( mrb, param0 ), param1, param2, *class_raylib_color_get_ptr( mrb, param3 ) );

	return self;
}

static mrb_value
mod_raylib_image_draw_pixel_v( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Image*
	mrb_value param1; // Vector2
	mrb_value param2; // Color

	mrb_get_args( mrb, "!doo", &param0, &param1, &param2 );

	ImageDrawPixelV( class_raylib_image_get_ptr( mrb, param0 ), *class_raylib_vector2_get_ptr( mrb, param1 ), *class_raylib_color_get_ptr( mrb, param2 ) );

	return self;
}

static mrb_value
mod_raylib_image_draw_line( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Image*
	mrb_int param1; // int
	mrb_int param2; // int
	mrb_int param3; // int
	mrb_int param4; // int
	mrb_value param5; // Color

	mrb_get_args( mrb, "!diiiio", &param0, &param1, &param2, &param3, &param4, &param5 );

	ImageDrawLine( class_raylib_image_get_ptr( mrb, param0 ), param1, param2, param3, param4, *class_raylib_color_get_ptr( mrb, param5 ) );

	return self;
}

static mrb_value
mod_raylib_image_draw_line_v( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Image*
	mrb_value param1; // Vector2
	mrb_value param2; // Vector2
	mrb_value param3; // Color

	mrb_get_args( mrb, "!dooo", &param0, &param1, &param2, &param3 );

	ImageDrawLineV( class_raylib_image_get_ptr( mrb, param0 ), *class_raylib_vector2_get_ptr( mrb, param1 ), *class_raylib_vector2_get_ptr( mrb, param2 ), *class_raylib_color_get_ptr( mrb, param3 ) );

	return self;
}

static mrb_value
mod_raylib_image_draw_circle( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Image*
	mrb_int param1; // int
	mrb_int param2; // int
	mrb_int param3; // int
	mrb_value param4; // Color

	mrb_get_args( mrb, "!diiio", &param0, &param1, &param2, &param3, &param4 );

	ImageDrawCircle( class_raylib_image_get_ptr( mrb, param0 ), param1, param2, param3, *class_raylib_color_get_ptr( mrb, param4 ) );

	return self;
}

static mrb_value
mod_raylib_image_draw_circle_v( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Image*
	mrb_value param1; // Vector2
	mrb_int param2; // int
	mrb_value param3; // Color

	mrb_get_args( mrb, "!doio", &param0, &param1, &param2, &param3 );

	ImageDrawCircleV( class_raylib_image_get_ptr( mrb, param0 ), *class_raylib_vector2_get_ptr( mrb, param1 ), param2, *class_raylib_color_get_ptr( mrb, param3 ) );

	return self;
}

static mrb_value
mod_raylib_image_draw_circle_lines( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Image*
	mrb_int param1; // int
	mrb_int param2; // int
	mrb_int param3; // int
	mrb_value param4; // Color

	mrb_get_args( mrb, "!diiio", &param0, &param1, &param2, &param3, &param4 );

	ImageDrawCircleLines( class_raylib_image_get_ptr( mrb, param0 ), param1, param2, param3, *class_raylib_color_get_ptr( mrb, param4 ) );

	return self;
}

static mrb_value
mod_raylib_image_draw_circle_lines_v( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Image*
	mrb_value param1; // Vector2
	mrb_int param2; // int
	mrb_value param3; // Color

	mrb_get_args( mrb, "!doio", &param0, &param1, &param2, &param3 );

	ImageDrawCircleLinesV( class_raylib_image_get_ptr( mrb, param0 ), *class_raylib_vector2_get_ptr( mrb, param1 ), param2, *class_raylib_color_get_ptr( mrb, param3 ) );

	return self;
}

static mrb_value
mod_raylib_image_draw_rectangle( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Image*
	mrb_int param1; // int
	mrb_int param2; // int
	mrb_int param3; // int
	mrb_int param4; // int
	mrb_value param5; // Color

	mrb_get_args( mrb, "!diiiio", &param0, &param1, &param2, &param3, &param4, &param5 );

	ImageDrawRectangle( class_raylib_image_get_ptr( mrb, param0 ), param1, param2, param3, param4, *class_raylib_color_get_ptr( mrb, param5 ) );

	return self;
}

static mrb_value
mod_raylib_image_draw_rectangle_v( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Image*
	mrb_value param1; // Vector2
	mrb_value param2; // Vector2
	mrb_value param3; // Color

	mrb_get_args( mrb, "!dooo", &param0, &param1, &param2, &param3 );

	ImageDrawRectangleV( class_raylib_image_get_ptr( mrb, param0 ), *class_raylib_vector2_get_ptr( mrb, param1 ), *class_raylib_vector2_get_ptr( mrb, param2 ), *class_raylib_color_get_ptr( mrb, param3 ) );

	return self;
}

static mrb_value
mod_raylib_image_draw_rectangle_rec( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Image*
	mrb_value param1; // Rectangle
	mrb_value param2; // Color

	mrb_get_args( mrb, "!doo", &param0, &param1, &param2 );

	ImageDrawRectangleRec( class_raylib_image_get_ptr( mrb, param0 ), *class_raylib_rectangle_get_ptr( mrb, param1 ), *class_raylib_color_get_ptr( mrb, param2 ) );

	return self;
}

static mrb_value
mod_raylib_image_draw_rectangle_lines( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Image*
	mrb_value param1; // Rectangle
	mrb_int param2; // int
	mrb_value param3; // Color

	mrb_get_args( mrb, "!doio", &param0, &param1, &param2, &param3 );

	ImageDrawRectangleLines( class_raylib_image_get_ptr( mrb, param0 ), *class_raylib_rectangle_get_ptr( mrb, param1 ), param2, *class_raylib_color_get_ptr( mrb, param3 ) );

	return self;
}

static mrb_value
mod_raylib_image_draw( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Image*
	mrb_value param1; // Image
	mrb_value param2; // Rectangle
	mrb_value param3; // Rectangle
	mrb_value param4; // Color

	mrb_get_args( mrb, "!doooo", &param0, &param1, &param2, &param3, &param4 );

	ImageDraw( class_raylib_image_get_ptr( mrb, param0 ), *class_raylib_image_get_ptr( mrb, param1 ), *class_raylib_rectangle_get_ptr( mrb, param2 ), *class_raylib_rectangle_get_ptr( mrb, param3 ), *class_raylib_color_get_ptr( mrb, param4 ) );

	return self;
}

static mrb_value
mod_raylib_image_draw_text( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Image*
	mrb_value param1; // const char*
	mrb_int param2; // int
	mrb_int param3; // int
	mrb_int param4; // int
	mrb_value param5; // Color

	mrb_get_args( mrb, "!dSiiio", &param0, &param1, &param2, &param3, &param4, &param5 );

	ImageDrawText( class_raylib_image_get_ptr( mrb, param0 ), RSTRING_PTR( param1 ), param2, param3, param4, *class_raylib_color_get_ptr( mrb, param5 ) );

	return self;
}

static mrb_value
mod_raylib_image_draw_text_ex( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Image*
	mrb_value param1; // Font
	mrb_value param2; // const char*
	mrb_value param3; // Vector2
	mrb_float param4; // float
	mrb_float param5; // float
	mrb_value param6; // Color

	mrb_get_args( mrb, "!doSoffo", &param0, &param1, &param2, &param3, &param4, &param5, &param6 );

	ImageDrawTextEx( class_raylib_image_get_ptr( mrb, param0 ), *class_raylib_font_get_ptr( mrb, param1 ), RSTRING_PTR( param2 ), *class_raylib_vector2_get_ptr( mrb, param3 ), param4, param5, *class_raylib_color_get_ptr( mrb, param6 ) );

	return self;
}

static mrb_value
mod_raylib_load_texture( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const char*

	mrb_get_args( mrb, "S", &param0 );

	Texture2D ret = LoadTexture( RSTRING_PTR( param0 ) );

	return class_raylib_texture_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_load_texture_from_image( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Image

	mrb_get_args( mrb, "o", &param0 );

	Texture2D ret = LoadTextureFromImage( *class_raylib_image_get_ptr( mrb, param0 ) );

	return class_raylib_texture_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_load_texture_cubemap( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Image
	mrb_int param1; // int

	mrb_get_args( mrb, "oi", &param0, &param1 );

	TextureCubemap ret = LoadTextureCubemap( *class_raylib_image_get_ptr( mrb, param0 ), param1 );

	return class_raylib_texture_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_load_render_texture( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int
	mrb_int param1; // int

	mrb_get_args( mrb, "ii", &param0, &param1 );

	RenderTexture2D ret = LoadRenderTexture( param0, param1 );

	return class_raylib_rendertexture_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_is_texture_ready( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Texture2D

	mrb_get_args( mrb, "d", &param0 );

	bool ret = IsTextureReady( *class_raylib_texture_get_ptr( mrb, param0 ) );

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_unload_texture( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Texture2D

	mrb_get_args( mrb, "d", &param0 );

	UnloadTexture( *class_raylib_texture_get_ptr( mrb, param0 ) );

	return self;
}

static mrb_value
mod_raylib_is_render_texture_ready( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // RenderTexture2D

	mrb_get_args( mrb, "d", &param0 );

	bool ret = IsRenderTextureReady( *class_raylib_rendertexture_get_ptr( mrb, param0 ) );

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_unload_render_texture( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // RenderTexture2D

	mrb_get_args( mrb, "d", &param0 );

	UnloadRenderTexture( *class_raylib_rendertexture_get_ptr( mrb, param0 ) );

	return self;
}

static mrb_value
mod_raylib_update_texture( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Texture2D
	mrb_value param1; // const void*

	mrb_get_args( mrb, "d!d", &param0, &param1 );

	UpdateTexture( *class_raylib_texture_get_ptr( mrb, param0 ), mrb_cptr( param1 ) );

	return self;
}

static mrb_value
mod_raylib_update_texture_rec( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Texture2D
	mrb_value param1; // Rectangle
	mrb_value param2; // const void*

	mrb_get_args( mrb, "do!d", &param0, &param1, &param2 );

	UpdateTextureRec( *class_raylib_texture_get_ptr( mrb, param0 ), *class_raylib_rectangle_get_ptr( mrb, param1 ), mrb_cptr( param2 ) );

	return self;
}

static mrb_value
mod_raylib_gen_texture_mipmaps( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Texture2D*

	mrb_get_args( mrb, "!d", &param0 );

	GenTextureMipmaps( class_raylib_texture_get_ptr( mrb, param0 ) );

	return self;
}

static mrb_value
mod_raylib_set_texture_filter( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Texture2D
	mrb_int param1; // int

	mrb_get_args( mrb, "di", &param0, &param1 );

	SetTextureFilter( *class_raylib_texture_get_ptr( mrb, param0 ), param1 );

	return self;
}

static mrb_value
mod_raylib_set_texture_wrap( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Texture2D
	mrb_int param1; // int

	mrb_get_args( mrb, "di", &param0, &param1 );

	SetTextureWrap( *class_raylib_texture_get_ptr( mrb, param0 ), param1 );

	return self;
}

static mrb_value
mod_raylib_draw_texture( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Texture2D
	mrb_int param1; // int
	mrb_int param2; // int
	mrb_value param3; // Color

	mrb_get_args( mrb, "diio", &param0, &param1, &param2, &param3 );

	DrawTexture( *class_raylib_texture_get_ptr( mrb, param0 ), param1, param2, *class_raylib_color_get_ptr( mrb, param3 ) );

	return self;
}

static mrb_value
mod_raylib_draw_texture_v( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Texture2D
	mrb_value param1; // Vector2
	mrb_value param2; // Color

	mrb_get_args( mrb, "doo", &param0, &param1, &param2 );

	DrawTextureV( *class_raylib_texture_get_ptr( mrb, param0 ), *class_raylib_vector2_get_ptr( mrb, param1 ), *class_raylib_color_get_ptr( mrb, param2 ) );

	return self;
}

static mrb_value
mod_raylib_draw_texture_ex( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Texture2D
	mrb_value param1; // Vector2
	mrb_float param2; // float
	mrb_float param3; // float
	mrb_value param4; // Color

	mrb_get_args( mrb, "doffo", &param0, &param1, &param2, &param3, &param4 );

	DrawTextureEx( *class_raylib_texture_get_ptr( mrb, param0 ), *class_raylib_vector2_get_ptr( mrb, param1 ), param2, param3, *class_raylib_color_get_ptr( mrb, param4 ) );

	return self;
}

static mrb_value
mod_raylib_draw_texture_rec( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Texture2D
	mrb_value param1; // Rectangle
	mrb_value param2; // Vector2
	mrb_value param3; // Color

	mrb_get_args( mrb, "dooo", &param0, &param1, &param2, &param3 );

	DrawTextureRec( *class_raylib_texture_get_ptr( mrb, param0 ), *class_raylib_rectangle_get_ptr( mrb, param1 ), *class_raylib_vector2_get_ptr( mrb, param2 ), *class_raylib_color_get_ptr( mrb, param3 ) );

	return self;
}

static mrb_value
mod_raylib_draw_texture_pro( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Texture2D
	mrb_value param1; // Rectangle
	mrb_value param2; // Rectangle
	mrb_value param3; // Vector2
	mrb_float param4; // float
	mrb_value param5; // Color

	mrb_get_args( mrb, "dooofo", &param0, &param1, &param2, &param3, &param4, &param5 );

	DrawTexturePro( *class_raylib_texture_get_ptr( mrb, param0 ), *class_raylib_rectangle_get_ptr( mrb, param1 ), *class_raylib_rectangle_get_ptr( mrb, param2 ), *class_raylib_vector2_get_ptr( mrb, param3 ), param4, *class_raylib_color_get_ptr( mrb, param5 ) );

	return self;
}

static mrb_value
mod_raylib_draw_texture_npatch( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Texture2D
	mrb_value param1; // NPatchInfo
	mrb_value param2; // Rectangle
	mrb_value param3; // Vector2
	mrb_float param4; // float
	mrb_value param5; // Color

	mrb_get_args( mrb, "dooofo", &param0, &param1, &param2, &param3, &param4, &param5 );

	DrawTextureNPatch( *class_raylib_texture_get_ptr( mrb, param0 ), *class_raylib_npatchinfo_get_ptr( mrb, param1 ), *class_raylib_rectangle_get_ptr( mrb, param2 ), *class_raylib_vector2_get_ptr( mrb, param3 ), param4, *class_raylib_color_get_ptr( mrb, param5 ) );

	return self;
}

static mrb_value
mod_raylib_fade( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Color
	mrb_float param1; // float

	mrb_get_args( mrb, "of", &param0, &param1 );

	Color ret = Fade( *class_raylib_color_get_ptr( mrb, param0 ), param1 );

	return class_raylib_color_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_color_to_int( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Color

	mrb_get_args( mrb, "o", &param0 );

	int ret = ColorToInt( *class_raylib_color_get_ptr( mrb, param0 ) );

	return mrb_fixnum_value( ret );
}

static mrb_value
mod_raylib_color_normalize( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Color

	mrb_get_args( mrb, "o", &param0 );

	Vector4 ret = ColorNormalize( *class_raylib_color_get_ptr( mrb, param0 ) );

	return class_raylib_vector4_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_color_from_normalized( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector4

	mrb_get_args( mrb, "o", &param0 );

	Color ret = ColorFromNormalized( *class_raylib_vector4_get_ptr( mrb, param0 ) );

	return class_raylib_color_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_color_to_hsv( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Color

	mrb_get_args( mrb, "o", &param0 );

	Vector3 ret = ColorToHSV( *class_raylib_color_get_ptr( mrb, param0 ) );

	return class_raylib_vector3_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_color_from_hsv( mrb_state *mrb, mrb_value self ) {
	mrb_float param0; // float
	mrb_float param1; // float
	mrb_float param2; // float

	mrb_get_args( mrb, "fff", &param0, &param1, &param2 );

	Color ret = ColorFromHSV( param0, param1, param2 );

	return class_raylib_color_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_color_tint( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Color
	mrb_value param1; // Color

	mrb_get_args( mrb, "oo", &param0, &param1 );

	Color ret = ColorTint( *class_raylib_color_get_ptr( mrb, param0 ), *class_raylib_color_get_ptr( mrb, param1 ) );

	return class_raylib_color_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_color_brightness( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Color
	mrb_float param1; // float

	mrb_get_args( mrb, "of", &param0, &param1 );

	Color ret = ColorBrightness( *class_raylib_color_get_ptr( mrb, param0 ), param1 );

	return class_raylib_color_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_color_contrast( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Color
	mrb_float param1; // float

	mrb_get_args( mrb, "of", &param0, &param1 );

	Color ret = ColorContrast( *class_raylib_color_get_ptr( mrb, param0 ), param1 );

	return class_raylib_color_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_color_alpha( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Color
	mrb_float param1; // float

	mrb_get_args( mrb, "of", &param0, &param1 );

	Color ret = ColorAlpha( *class_raylib_color_get_ptr( mrb, param0 ), param1 );

	return class_raylib_color_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_color_alpha_blend( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Color
	mrb_value param1; // Color
	mrb_value param2; // Color

	mrb_get_args( mrb, "ooo", &param0, &param1, &param2 );

	Color ret = ColorAlphaBlend( *class_raylib_color_get_ptr( mrb, param0 ), *class_raylib_color_get_ptr( mrb, param1 ), *class_raylib_color_get_ptr( mrb, param2 ) );

	return class_raylib_color_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_get_color( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // unsigned int

	mrb_get_args( mrb, "i", &param0 );

	Color ret = GetColor( param0 );

	return class_raylib_color_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_get_pixel_color( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // void*
	mrb_int param1; // int

	mrb_get_args( mrb, "di", &param0, &param1 );

	Color ret = GetPixelColor( mrb_cptr( param0 ), param1 );

	return class_raylib_color_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_set_pixel_color( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // void*
	mrb_value param1; // Color
	mrb_int param2; // int

	mrb_get_args( mrb, "doi", &param0, &param1, &param2 );

	SetPixelColor( mrb_cptr( param0 ), *class_raylib_color_get_ptr( mrb, param1 ), param2 );

	return self;
}

static mrb_value
mod_raylib_get_pixel_data_size( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int
	mrb_int param1; // int
	mrb_int param2; // int

	mrb_get_args( mrb, "iii", &param0, &param1, &param2 );

	int ret = GetPixelDataSize( param0, param1, param2 );

	return mrb_fixnum_value( ret );
}

static mrb_value
mod_raylib_get_font_default( mrb_state *mrb, mrb_value self ) {
	Font ret = GetFontDefault();

	return class_raylib_font_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_load_font( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const char*

	mrb_get_args( mrb, "S", &param0 );

	Font ret = LoadFont( RSTRING_PTR( param0 ) );

	return class_raylib_font_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_load_font_ex( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const char*
	mrb_int param1; // int
	mrb_value param2; // int*
	mrb_int param3; // int

	mrb_get_args( mrb, "Si*i", &param0, &param1, &param2, &param3 );

	Font ret = LoadFontEx( RSTRING_PTR( param0 ), param1, mrb_cptr( param2 ), param3 );

	return class_raylib_font_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_load_font_from_image( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Image
	mrb_value param1; // Color
	mrb_int param2; // int

	mrb_get_args( mrb, "ooi", &param0, &param1, &param2 );

	Font ret = LoadFontFromImage( *class_raylib_image_get_ptr( mrb, param0 ), *class_raylib_color_get_ptr( mrb, param1 ), param2 );

	return class_raylib_font_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_load_font_from_memory( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const char*
	mrb_value param1; // const unsigned char*
	mrb_int param2; // int
	mrb_int param3; // int
	mrb_value param4; // int*
	mrb_int param5; // int

	mrb_get_args( mrb, "S!dii*i", &param0, &param1, &param2, &param3, &param4, &param5 );

	Font ret = LoadFontFromMemory( RSTRING_PTR( param0 ), NULL, param2, param3, mrb_cptr( param4 ), param5 );

	return class_raylib_font_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_is_font_ready( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Font

	mrb_get_args( mrb, "o", &param0 );

	bool ret = IsFontReady( *class_raylib_font_get_ptr( mrb, param0 ) );

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_load_font_data( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const unsigned char*
	mrb_int param1; // int
	mrb_int param2; // int
	mrb_value param3; // int*
	mrb_int param4; // int
	mrb_int param5; // int

	mrb_get_args( mrb, "!dii*ii", &param0, &param1, &param2, &param3, &param4, &param5 );

	GlyphInfo* ret = LoadFontData( NULL, param1, param2, mrb_cptr( param3 ), param4, param5 );

	return class_raylib_glyphinfo_2_mrbvalue( mrb, ret, 0 );
}

static mrb_value
mod_raylib_gen_image_font_atlas( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const GlyphInfo*
	mrb_value param1; // Rectangle**
	mrb_int param2; // int
	mrb_int param3; // int
	mrb_int param4; // int
	mrb_int param5; // int

	mrb_get_args( mrb, "!d!diiii", &param0, &param1, &param2, &param3, &param4, &param5 );

	Image ret = GenImageFontAtlas( NULL, mrb_cptr( param1 ), param2, param3, param4, param5 );

	return class_raylib_image_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_unload_font_data( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // GlyphInfo*
	mrb_int param1; // int

	mrb_get_args( mrb, "!di", &param0, &param1 );

	UnloadFontData( class_raylib_glyphinfo_get_ptr( mrb, param0 ), param1 );

	return self;
}

static mrb_value
mod_raylib_unload_font( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Font

	mrb_get_args( mrb, "o", &param0 );

	UnloadFont( *class_raylib_font_get_ptr( mrb, param0 ) );

	return self;
}

static mrb_value
mod_raylib_export_font_as_code( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Font
	mrb_value param1; // const char*

	mrb_get_args( mrb, "oS", &param0, &param1 );

	bool ret = ExportFontAsCode( *class_raylib_font_get_ptr( mrb, param0 ), RSTRING_PTR( param1 ) );

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_draw_fps( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int
	mrb_int param1; // int

	mrb_get_args( mrb, "ii", &param0, &param1 );

	DrawFPS( param0, param1 );

	return self;
}

static mrb_value
mod_raylib_draw_text( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const char*
	mrb_int param1; // int
	mrb_int param2; // int
	mrb_int param3; // int
	mrb_value param4; // Color

	mrb_get_args( mrb, "Siiio", &param0, &param1, &param2, &param3, &param4 );

	DrawText( RSTRING_PTR( param0 ), param1, param2, param3, *class_raylib_color_get_ptr( mrb, param4 ) );

	return self;
}

static mrb_value
mod_raylib_draw_text_ex( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Font
	mrb_value param1; // const char*
	mrb_value param2; // Vector2
	mrb_float param3; // float
	mrb_float param4; // float
	mrb_value param5; // Color

	mrb_get_args( mrb, "oSoffo", &param0, &param1, &param2, &param3, &param4, &param5 );

	DrawTextEx( *class_raylib_font_get_ptr( mrb, param0 ), RSTRING_PTR( param1 ), *class_raylib_vector2_get_ptr( mrb, param2 ), param3, param4, *class_raylib_color_get_ptr( mrb, param5 ) );

	return self;
}

static mrb_value
mod_raylib_draw_text_pro( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Font
	mrb_value param1; // const char*
	mrb_value param2; // Vector2
	mrb_value param3; // Vector2
	mrb_float param4; // float
	mrb_float param5; // float
	mrb_float param6; // float
	mrb_value param7; // Color

	mrb_get_args( mrb, "oSoofffo", &param0, &param1, &param2, &param3, &param4, &param5, &param6, &param7 );

	DrawTextPro( *class_raylib_font_get_ptr( mrb, param0 ), RSTRING_PTR( param1 ), *class_raylib_vector2_get_ptr( mrb, param2 ), *class_raylib_vector2_get_ptr( mrb, param3 ), param4, param5, param6, *class_raylib_color_get_ptr( mrb, param7 ) );

	return self;
}

static mrb_value
mod_raylib_draw_text_codepoint( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Font
	mrb_int param1; // int
	mrb_value param2; // Vector2
	mrb_float param3; // float
	mrb_value param4; // Color

	mrb_get_args( mrb, "oiofo", &param0, &param1, &param2, &param3, &param4 );

	DrawTextCodepoint( *class_raylib_font_get_ptr( mrb, param0 ), param1, *class_raylib_vector2_get_ptr( mrb, param2 ), param3, *class_raylib_color_get_ptr( mrb, param4 ) );

	return self;
}

static mrb_value
mod_raylib_draw_text_codepoints( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Font
	mrb_value param1; // const int*
	mrb_int param2; // int
	mrb_value param3; // Vector2
	mrb_float param4; // float
	mrb_float param5; // float
	mrb_value param6; // Color

	mrb_get_args( mrb, "o!dioffo", &param0, &param1, &param2, &param3, &param4, &param5, &param6 );

	DrawTextCodepoints( *class_raylib_font_get_ptr( mrb, param0 ), NULL, param2, *class_raylib_vector2_get_ptr( mrb, param3 ), param4, param5, *class_raylib_color_get_ptr( mrb, param6 ) );

	return self;
}

static mrb_value
mod_raylib_set_text_line_spacing( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int

	mrb_get_args( mrb, "i", &param0 );

	SetTextLineSpacing( param0 );

	return self;
}

static mrb_value
mod_raylib_measure_text( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const char*
	mrb_int param1; // int

	mrb_get_args( mrb, "Si", &param0, &param1 );

	int ret = MeasureText( RSTRING_PTR( param0 ), param1 );

	return mrb_fixnum_value( ret );
}

static mrb_value
mod_raylib_measure_text_ex( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Font
	mrb_value param1; // const char*
	mrb_float param2; // float
	mrb_float param3; // float

	mrb_get_args( mrb, "oSff", &param0, &param1, &param2, &param3 );

	Vector2 ret = MeasureTextEx( *class_raylib_font_get_ptr( mrb, param0 ), RSTRING_PTR( param1 ), param2, param3 );

	return class_raylib_vector2_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_get_glyph_index( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Font
	mrb_int param1; // int

	mrb_get_args( mrb, "oi", &param0, &param1 );

	int ret = GetGlyphIndex( *class_raylib_font_get_ptr( mrb, param0 ), param1 );

	return mrb_fixnum_value( ret );
}

static mrb_value
mod_raylib_get_glyph_info( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Font
	mrb_int param1; // int

	mrb_get_args( mrb, "oi", &param0, &param1 );

	GlyphInfo ret = GetGlyphInfo( *class_raylib_font_get_ptr( mrb, param0 ), param1 );

	return class_raylib_glyphinfo_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_get_glyph_atlas_rec( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Font
	mrb_int param1; // int

	mrb_get_args( mrb, "oi", &param0, &param1 );

	Rectangle ret = GetGlyphAtlasRec( *class_raylib_font_get_ptr( mrb, param0 ), param1 );

	return class_raylib_rectangle_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_load_utf8( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const int*
	mrb_int param1; // int

	mrb_get_args( mrb, "!di", &param0, &param1 );

	char* ret = LoadUTF8( NULL, param1 );

	return mrb_cptr_value( mrb, ( void* )( ret ) );
}

static mrb_value
mod_raylib_unload_utf8( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // char*

	mrb_get_args( mrb, "*", &param0 );

	UnloadUTF8( mrb_cptr( param0 ) );

	return self;
}

static mrb_value
mod_raylib_load_codepoints( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const char*
	mrb_value param1; // int*

	mrb_get_args( mrb, "S*", &param0, &param1 );

	int* ret = LoadCodepoints( RSTRING_PTR( param0 ), mrb_cptr( param1 ) );

	return mrb_cptr_value( mrb, ( void* )( ret ) );
}

static mrb_value
mod_raylib_unload_codepoints( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // int*

	mrb_get_args( mrb, "*", &param0 );

	UnloadCodepoints( mrb_cptr( param0 ) );

	return self;
}

static mrb_value
mod_raylib_get_codepoint_count( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const char*

	mrb_get_args( mrb, "S", &param0 );

	int ret = GetCodepointCount( RSTRING_PTR( param0 ) );

	return mrb_fixnum_value( ret );
}

static mrb_value
mod_raylib_get_codepoint( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const char*
	mrb_value param1; // int*

	mrb_get_args( mrb, "S*", &param0, &param1 );

	int ret = GetCodepoint( RSTRING_PTR( param0 ), mrb_cptr( param1 ) );

	return mrb_fixnum_value( ret );
}

static mrb_value
mod_raylib_get_codepoint_next( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const char*
	mrb_value param1; // int*

	mrb_get_args( mrb, "S*", &param0, &param1 );

	int ret = GetCodepointNext( RSTRING_PTR( param0 ), mrb_cptr( param1 ) );

	return mrb_fixnum_value( ret );
}

static mrb_value
mod_raylib_get_codepoint_previous( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const char*
	mrb_value param1; // int*

	mrb_get_args( mrb, "S*", &param0, &param1 );

	int ret = GetCodepointPrevious( RSTRING_PTR( param0 ), mrb_cptr( param1 ) );

	return mrb_fixnum_value( ret );
}

static mrb_value
mod_raylib_codepoint_to_utf8( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int
	mrb_value param1; // int*

	mrb_get_args( mrb, "i*", &param0, &param1 );

	const char* ret = CodepointToUTF8( param0, mrb_cptr( param1 ) );

	return mrb_str_new_cstr( mrb, ret );
}

static mrb_value
mod_raylib_text_copy( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // char*
	mrb_value param1; // const char*

	mrb_get_args( mrb, "*S", &param0, &param1 );

	int ret = TextCopy( mrb_cptr( param0 ), RSTRING_PTR( param1 ) );

	return mrb_fixnum_value( ret );
}

static mrb_value
mod_raylib_text_is_equal( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const char*
	mrb_value param1; // const char*

	mrb_get_args( mrb, "SS", &param0, &param1 );

	bool ret = TextIsEqual( RSTRING_PTR( param0 ), RSTRING_PTR( param1 ) );

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_text_length( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const char*

	mrb_get_args( mrb, "S", &param0 );

	unsigned int ret = TextLength( RSTRING_PTR( param0 ) );

	return mrb_fixnum_value( ret );
}

static mrb_value
mod_raylib_text_format( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const char*

	mrb_get_args( mrb, "S", &param0 );

	const char* ret = TextFormat( RSTRING_PTR( param0 ) );

	return mrb_str_new_cstr( mrb, ret );
}

static mrb_value
mod_raylib_text_subtext( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const char*
	mrb_int param1; // int
	mrb_int param2; // int

	mrb_get_args( mrb, "Sii", &param0, &param1, &param2 );

	const char* ret = TextSubtext( RSTRING_PTR( param0 ), param1, param2 );

	return mrb_str_new_cstr( mrb, ret );
}

static mrb_value
mod_raylib_text_replace( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // char*
	mrb_value param1; // const char*
	mrb_value param2; // const char*

	mrb_get_args( mrb, "*SS", &param0, &param1, &param2 );

	char* ret = TextReplace( mrb_cptr( param0 ), RSTRING_PTR( param1 ), RSTRING_PTR( param2 ) );

	return mrb_cptr_value( mrb, ( void* )( ret ) );
}

static mrb_value
mod_raylib_text_insert( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const char*
	mrb_value param1; // const char*
	mrb_int param2; // int

	mrb_get_args( mrb, "SSi", &param0, &param1, &param2 );

	char* ret = TextInsert( RSTRING_PTR( param0 ), RSTRING_PTR( param1 ), param2 );

	return mrb_cptr_value( mrb, ( void* )( ret ) );
}

static mrb_value
mod_raylib_text_join( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const char**
	mrb_int param1; // int
	mrb_value param2; // const char*

	mrb_get_args( mrb, "!diS", &param0, &param1, &param2 );

	const char* ret = TextJoin( mrb_cptr( param0 ), param1, RSTRING_PTR( param2 ) );

	return mrb_str_new_cstr( mrb, ret );
}

static mrb_value
mod_raylib_text_split( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const char*
	mrb_int param1; // char
	mrb_value param2; // int*

	mrb_get_args( mrb, "Si*", &param0, &param1, &param2 );

	const char** ret = TextSplit( RSTRING_PTR( param0 ), param1, mrb_cptr( param2 ) );

	return mrb_cptr_value( mrb, ( void* )( ret ) );
}

static mrb_value
mod_raylib_text_append( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // char*
	mrb_value param1; // const char*
	mrb_value param2; // int*

	mrb_get_args( mrb, "*S*", &param0, &param1, &param2 );

	TextAppend( mrb_cptr( param0 ), RSTRING_PTR( param1 ), mrb_cptr( param2 ) );

	return self;
}

static mrb_value
mod_raylib_text_find_index( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const char*
	mrb_value param1; // const char*

	mrb_get_args( mrb, "SS", &param0, &param1 );

	int ret = TextFindIndex( RSTRING_PTR( param0 ), RSTRING_PTR( param1 ) );

	return mrb_fixnum_value( ret );
}

static mrb_value
mod_raylib_text_to_upper( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const char*

	mrb_get_args( mrb, "S", &param0 );

	const char* ret = TextToUpper( RSTRING_PTR( param0 ) );

	return mrb_str_new_cstr( mrb, ret );
}

static mrb_value
mod_raylib_text_to_lower( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const char*

	mrb_get_args( mrb, "S", &param0 );

	const char* ret = TextToLower( RSTRING_PTR( param0 ) );

	return mrb_str_new_cstr( mrb, ret );
}

static mrb_value
mod_raylib_text_to_pascal( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const char*

	mrb_get_args( mrb, "S", &param0 );

	const char* ret = TextToPascal( RSTRING_PTR( param0 ) );

	return mrb_str_new_cstr( mrb, ret );
}

static mrb_value
mod_raylib_text_to_integer( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const char*

	mrb_get_args( mrb, "S", &param0 );

	int ret = TextToInteger( RSTRING_PTR( param0 ) );

	return mrb_fixnum_value( ret );
}

static mrb_value
mod_raylib_draw_line3_d( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector3
	mrb_value param1; // Vector3
	mrb_value param2; // Color

	mrb_get_args( mrb, "ooo", &param0, &param1, &param2 );

	DrawLine3D( *class_raylib_vector3_get_ptr( mrb, param0 ), *class_raylib_vector3_get_ptr( mrb, param1 ), *class_raylib_color_get_ptr( mrb, param2 ) );

	return self;
}

static mrb_value
mod_raylib_draw_point3_d( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector3
	mrb_value param1; // Color

	mrb_get_args( mrb, "oo", &param0, &param1 );

	DrawPoint3D( *class_raylib_vector3_get_ptr( mrb, param0 ), *class_raylib_color_get_ptr( mrb, param1 ) );

	return self;
}

static mrb_value
mod_raylib_draw_circle3_d( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector3
	mrb_float param1; // float
	mrb_value param2; // Vector3
	mrb_float param3; // float
	mrb_value param4; // Color

	mrb_get_args( mrb, "ofofo", &param0, &param1, &param2, &param3, &param4 );

	DrawCircle3D( *class_raylib_vector3_get_ptr( mrb, param0 ), param1, *class_raylib_vector3_get_ptr( mrb, param2 ), param3, *class_raylib_color_get_ptr( mrb, param4 ) );

	return self;
}

static mrb_value
mod_raylib_draw_triangle3_d( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector3
	mrb_value param1; // Vector3
	mrb_value param2; // Vector3
	mrb_value param3; // Color

	mrb_get_args( mrb, "oooo", &param0, &param1, &param2, &param3 );

	DrawTriangle3D( *class_raylib_vector3_get_ptr( mrb, param0 ), *class_raylib_vector3_get_ptr( mrb, param1 ), *class_raylib_vector3_get_ptr( mrb, param2 ), *class_raylib_color_get_ptr( mrb, param3 ) );

	return self;
}

static mrb_value
mod_raylib_draw_triangle_strip3_d( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector3*
	mrb_int param1; // int
	mrb_value param2; // Color

	mrb_get_args( mrb, "!dio", &param0, &param1, &param2 );

	DrawTriangleStrip3D( class_raylib_vector3_get_ptr( mrb, param0 ), param1, *class_raylib_color_get_ptr( mrb, param2 ) );

	return self;
}

static mrb_value
mod_raylib_draw_cube( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector3
	mrb_float param1; // float
	mrb_float param2; // float
	mrb_float param3; // float
	mrb_value param4; // Color

	mrb_get_args( mrb, "offfo", &param0, &param1, &param2, &param3, &param4 );

	DrawCube( *class_raylib_vector3_get_ptr( mrb, param0 ), param1, param2, param3, *class_raylib_color_get_ptr( mrb, param4 ) );

	return self;
}

static mrb_value
mod_raylib_draw_cube_v( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector3
	mrb_value param1; // Vector3
	mrb_value param2; // Color

	mrb_get_args( mrb, "ooo", &param0, &param1, &param2 );

	DrawCubeV( *class_raylib_vector3_get_ptr( mrb, param0 ), *class_raylib_vector3_get_ptr( mrb, param1 ), *class_raylib_color_get_ptr( mrb, param2 ) );

	return self;
}

static mrb_value
mod_raylib_draw_cube_wires( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector3
	mrb_float param1; // float
	mrb_float param2; // float
	mrb_float param3; // float
	mrb_value param4; // Color

	mrb_get_args( mrb, "offfo", &param0, &param1, &param2, &param3, &param4 );

	DrawCubeWires( *class_raylib_vector3_get_ptr( mrb, param0 ), param1, param2, param3, *class_raylib_color_get_ptr( mrb, param4 ) );

	return self;
}

static mrb_value
mod_raylib_draw_cube_wires_v( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector3
	mrb_value param1; // Vector3
	mrb_value param2; // Color

	mrb_get_args( mrb, "ooo", &param0, &param1, &param2 );

	DrawCubeWiresV( *class_raylib_vector3_get_ptr( mrb, param0 ), *class_raylib_vector3_get_ptr( mrb, param1 ), *class_raylib_color_get_ptr( mrb, param2 ) );

	return self;
}

static mrb_value
mod_raylib_draw_sphere( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector3
	mrb_float param1; // float
	mrb_value param2; // Color

	mrb_get_args( mrb, "ofo", &param0, &param1, &param2 );

	DrawSphere( *class_raylib_vector3_get_ptr( mrb, param0 ), param1, *class_raylib_color_get_ptr( mrb, param2 ) );

	return self;
}

static mrb_value
mod_raylib_draw_sphere_ex( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector3
	mrb_float param1; // float
	mrb_int param2; // int
	mrb_int param3; // int
	mrb_value param4; // Color

	mrb_get_args( mrb, "ofiio", &param0, &param1, &param2, &param3, &param4 );

	DrawSphereEx( *class_raylib_vector3_get_ptr( mrb, param0 ), param1, param2, param3, *class_raylib_color_get_ptr( mrb, param4 ) );

	return self;
}

static mrb_value
mod_raylib_draw_sphere_wires( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector3
	mrb_float param1; // float
	mrb_int param2; // int
	mrb_int param3; // int
	mrb_value param4; // Color

	mrb_get_args( mrb, "ofiio", &param0, &param1, &param2, &param3, &param4 );

	DrawSphereWires( *class_raylib_vector3_get_ptr( mrb, param0 ), param1, param2, param3, *class_raylib_color_get_ptr( mrb, param4 ) );

	return self;
}

static mrb_value
mod_raylib_draw_cylinder( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector3
	mrb_float param1; // float
	mrb_float param2; // float
	mrb_float param3; // float
	mrb_int param4; // int
	mrb_value param5; // Color

	mrb_get_args( mrb, "offfio", &param0, &param1, &param2, &param3, &param4, &param5 );

	DrawCylinder( *class_raylib_vector3_get_ptr( mrb, param0 ), param1, param2, param3, param4, *class_raylib_color_get_ptr( mrb, param5 ) );

	return self;
}

static mrb_value
mod_raylib_draw_cylinder_ex( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector3
	mrb_value param1; // Vector3
	mrb_float param2; // float
	mrb_float param3; // float
	mrb_int param4; // int
	mrb_value param5; // Color

	mrb_get_args( mrb, "ooffio", &param0, &param1, &param2, &param3, &param4, &param5 );

	DrawCylinderEx( *class_raylib_vector3_get_ptr( mrb, param0 ), *class_raylib_vector3_get_ptr( mrb, param1 ), param2, param3, param4, *class_raylib_color_get_ptr( mrb, param5 ) );

	return self;
}

static mrb_value
mod_raylib_draw_cylinder_wires( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector3
	mrb_float param1; // float
	mrb_float param2; // float
	mrb_float param3; // float
	mrb_int param4; // int
	mrb_value param5; // Color

	mrb_get_args( mrb, "offfio", &param0, &param1, &param2, &param3, &param4, &param5 );

	DrawCylinderWires( *class_raylib_vector3_get_ptr( mrb, param0 ), param1, param2, param3, param4, *class_raylib_color_get_ptr( mrb, param5 ) );

	return self;
}

static mrb_value
mod_raylib_draw_cylinder_wires_ex( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector3
	mrb_value param1; // Vector3
	mrb_float param2; // float
	mrb_float param3; // float
	mrb_int param4; // int
	mrb_value param5; // Color

	mrb_get_args( mrb, "ooffio", &param0, &param1, &param2, &param3, &param4, &param5 );

	DrawCylinderWiresEx( *class_raylib_vector3_get_ptr( mrb, param0 ), *class_raylib_vector3_get_ptr( mrb, param1 ), param2, param3, param4, *class_raylib_color_get_ptr( mrb, param5 ) );

	return self;
}

static mrb_value
mod_raylib_draw_capsule( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector3
	mrb_value param1; // Vector3
	mrb_float param2; // float
	mrb_int param3; // int
	mrb_int param4; // int
	mrb_value param5; // Color

	mrb_get_args( mrb, "oofiio", &param0, &param1, &param2, &param3, &param4, &param5 );

	DrawCapsule( *class_raylib_vector3_get_ptr( mrb, param0 ), *class_raylib_vector3_get_ptr( mrb, param1 ), param2, param3, param4, *class_raylib_color_get_ptr( mrb, param5 ) );

	return self;
}

static mrb_value
mod_raylib_draw_capsule_wires( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector3
	mrb_value param1; // Vector3
	mrb_float param2; // float
	mrb_int param3; // int
	mrb_int param4; // int
	mrb_value param5; // Color

	mrb_get_args( mrb, "oofiio", &param0, &param1, &param2, &param3, &param4, &param5 );

	DrawCapsuleWires( *class_raylib_vector3_get_ptr( mrb, param0 ), *class_raylib_vector3_get_ptr( mrb, param1 ), param2, param3, param4, *class_raylib_color_get_ptr( mrb, param5 ) );

	return self;
}

static mrb_value
mod_raylib_draw_plane( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector3
	mrb_value param1; // Vector2
	mrb_value param2; // Color

	mrb_get_args( mrb, "ooo", &param0, &param1, &param2 );

	DrawPlane( *class_raylib_vector3_get_ptr( mrb, param0 ), *class_raylib_vector2_get_ptr( mrb, param1 ), *class_raylib_color_get_ptr( mrb, param2 ) );

	return self;
}

static mrb_value
mod_raylib_draw_ray( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Ray
	mrb_value param1; // Color

	mrb_get_args( mrb, "oo", &param0, &param1 );

	DrawRay( *class_raylib_ray_get_ptr( mrb, param0 ), *class_raylib_color_get_ptr( mrb, param1 ) );

	return self;
}

static mrb_value
mod_raylib_draw_grid( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int
	mrb_float param1; // float

	mrb_get_args( mrb, "if", &param0, &param1 );

	DrawGrid( param0, param1 );

	return self;
}

static mrb_value
mod_raylib_load_model( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const char*

	mrb_get_args( mrb, "S", &param0 );

	Model ret = LoadModel( RSTRING_PTR( param0 ) );

	return class_raylib_model_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_load_model_from_mesh( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Mesh

	mrb_get_args( mrb, "o", &param0 );

	Model ret = LoadModelFromMesh( *class_raylib_mesh_get_ptr( mrb, param0 ) );

	return class_raylib_model_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_is_model_ready( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Model

	mrb_get_args( mrb, "o", &param0 );

	bool ret = IsModelReady( *class_raylib_model_get_ptr( mrb, param0 ) );

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_unload_model( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Model

	mrb_get_args( mrb, "o", &param0 );

	UnloadModel( *class_raylib_model_get_ptr( mrb, param0 ) );

	return self;
}

static mrb_value
mod_raylib_get_model_bounding_box( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Model

	mrb_get_args( mrb, "o", &param0 );

	BoundingBox ret = GetModelBoundingBox( *class_raylib_model_get_ptr( mrb, param0 ) );

	return class_raylib_boundingbox_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_draw_model( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Model
	mrb_value param1; // Vector3
	mrb_float param2; // float
	mrb_value param3; // Color

	mrb_get_args( mrb, "oofo", &param0, &param1, &param2, &param3 );

	DrawModel( *class_raylib_model_get_ptr( mrb, param0 ), *class_raylib_vector3_get_ptr( mrb, param1 ), param2, *class_raylib_color_get_ptr( mrb, param3 ) );

	return self;
}

static mrb_value
mod_raylib_draw_model_ex( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Model
	mrb_value param1; // Vector3
	mrb_value param2; // Vector3
	mrb_float param3; // float
	mrb_value param4; // Vector3
	mrb_value param5; // Color

	mrb_get_args( mrb, "ooofoo", &param0, &param1, &param2, &param3, &param4, &param5 );

	DrawModelEx( *class_raylib_model_get_ptr( mrb, param0 ), *class_raylib_vector3_get_ptr( mrb, param1 ), *class_raylib_vector3_get_ptr( mrb, param2 ), param3, *class_raylib_vector3_get_ptr( mrb, param4 ), *class_raylib_color_get_ptr( mrb, param5 ) );

	return self;
}

static mrb_value
mod_raylib_draw_model_wires( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Model
	mrb_value param1; // Vector3
	mrb_float param2; // float
	mrb_value param3; // Color

	mrb_get_args( mrb, "oofo", &param0, &param1, &param2, &param3 );

	DrawModelWires( *class_raylib_model_get_ptr( mrb, param0 ), *class_raylib_vector3_get_ptr( mrb, param1 ), param2, *class_raylib_color_get_ptr( mrb, param3 ) );

	return self;
}

static mrb_value
mod_raylib_draw_model_wires_ex( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Model
	mrb_value param1; // Vector3
	mrb_value param2; // Vector3
	mrb_float param3; // float
	mrb_value param4; // Vector3
	mrb_value param5; // Color

	mrb_get_args( mrb, "ooofoo", &param0, &param1, &param2, &param3, &param4, &param5 );

	DrawModelWiresEx( *class_raylib_model_get_ptr( mrb, param0 ), *class_raylib_vector3_get_ptr( mrb, param1 ), *class_raylib_vector3_get_ptr( mrb, param2 ), param3, *class_raylib_vector3_get_ptr( mrb, param4 ), *class_raylib_color_get_ptr( mrb, param5 ) );

	return self;
}

static mrb_value
mod_raylib_draw_bounding_box( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // BoundingBox
	mrb_value param1; // Color

	mrb_get_args( mrb, "oo", &param0, &param1 );

	DrawBoundingBox( *class_raylib_boundingbox_get_ptr( mrb, param0 ), *class_raylib_color_get_ptr( mrb, param1 ) );

	return self;
}

static mrb_value
mod_raylib_draw_billboard( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Camera
	mrb_value param1; // Texture2D
	mrb_value param2; // Vector3
	mrb_float param3; // float
	mrb_value param4; // Color

	mrb_get_args( mrb, "ddofo", &param0, &param1, &param2, &param3, &param4 );

	DrawBillboard( *class_raylib_camera3d_get_ptr( mrb, param0 ), *class_raylib_texture_get_ptr( mrb, param1 ), *class_raylib_vector3_get_ptr( mrb, param2 ), param3, *class_raylib_color_get_ptr( mrb, param4 ) );

	return self;
}

static mrb_value
mod_raylib_draw_billboard_rec( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Camera
	mrb_value param1; // Texture2D
	mrb_value param2; // Rectangle
	mrb_value param3; // Vector3
	mrb_value param4; // Vector2
	mrb_value param5; // Color

	mrb_get_args( mrb, "ddoooo", &param0, &param1, &param2, &param3, &param4, &param5 );

	DrawBillboardRec( *class_raylib_camera3d_get_ptr( mrb, param0 ), *class_raylib_texture_get_ptr( mrb, param1 ), *class_raylib_rectangle_get_ptr( mrb, param2 ), *class_raylib_vector3_get_ptr( mrb, param3 ), *class_raylib_vector2_get_ptr( mrb, param4 ), *class_raylib_color_get_ptr( mrb, param5 ) );

	return self;
}

static mrb_value
mod_raylib_draw_billboard_pro( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Camera
	mrb_value param1; // Texture2D
	mrb_value param2; // Rectangle
	mrb_value param3; // Vector3
	mrb_value param4; // Vector3
	mrb_value param5; // Vector2
	mrb_value param6; // Vector2
	mrb_float param7; // float
	mrb_value param8; // Color

	mrb_get_args( mrb, "ddooooofo", &param0, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8 );

	DrawBillboardPro( *class_raylib_camera3d_get_ptr( mrb, param0 ), *class_raylib_texture_get_ptr( mrb, param1 ), *class_raylib_rectangle_get_ptr( mrb, param2 ), *class_raylib_vector3_get_ptr( mrb, param3 ), *class_raylib_vector3_get_ptr( mrb, param4 ), *class_raylib_vector2_get_ptr( mrb, param5 ), *class_raylib_vector2_get_ptr( mrb, param6 ), param7, *class_raylib_color_get_ptr( mrb, param8 ) );

	return self;
}

static mrb_value
mod_raylib_upload_mesh( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Mesh*
	mrb_bool param1; // bool

	mrb_get_args( mrb, "!db", &param0, &param1 );

	UploadMesh( class_raylib_mesh_get_ptr( mrb, param0 ), param1 );

	return self;
}

static mrb_value
mod_raylib_update_mesh_buffer( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Mesh
	mrb_int param1; // int
	mrb_value param2; // const void*
	mrb_int param3; // int
	mrb_int param4; // int

	mrb_get_args( mrb, "oi!dii", &param0, &param1, &param2, &param3, &param4 );

	UpdateMeshBuffer( *class_raylib_mesh_get_ptr( mrb, param0 ), param1, mrb_cptr( param2 ), param3, param4 );

	return self;
}

static mrb_value
mod_raylib_unload_mesh( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Mesh

	mrb_get_args( mrb, "o", &param0 );

	UnloadMesh( *class_raylib_mesh_get_ptr( mrb, param0 ) );

	return self;
}

static mrb_value
mod_raylib_draw_mesh( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Mesh
	mrb_value param1; // Material
	mrb_value param2; // Matrix

	mrb_get_args( mrb, "ooo", &param0, &param1, &param2 );

	DrawMesh( *class_raylib_mesh_get_ptr( mrb, param0 ), *class_raylib_material_get_ptr( mrb, param1 ), *class_raylib_matrix_get_ptr( mrb, param2 ) );

	return self;
}

static mrb_value
mod_raylib_draw_mesh_instanced( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Mesh
	mrb_value param1; // Material
	mrb_value param2; // const Matrix*
	mrb_int param3; // int

	mrb_get_args( mrb, "oo!di", &param0, &param1, &param2, &param3 );

	DrawMeshInstanced( *class_raylib_mesh_get_ptr( mrb, param0 ), *class_raylib_material_get_ptr( mrb, param1 ), NULL, param3 );

	return self;
}

static mrb_value
mod_raylib_export_mesh( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Mesh
	mrb_value param1; // const char*

	mrb_get_args( mrb, "oS", &param0, &param1 );

	bool ret = ExportMesh( *class_raylib_mesh_get_ptr( mrb, param0 ), RSTRING_PTR( param1 ) );

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_get_mesh_bounding_box( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Mesh

	mrb_get_args( mrb, "o", &param0 );

	BoundingBox ret = GetMeshBoundingBox( *class_raylib_mesh_get_ptr( mrb, param0 ) );

	return class_raylib_boundingbox_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_gen_mesh_tangents( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Mesh*

	mrb_get_args( mrb, "!d", &param0 );

	GenMeshTangents( class_raylib_mesh_get_ptr( mrb, param0 ) );

	return self;
}

static mrb_value
mod_raylib_gen_mesh_poly( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int
	mrb_float param1; // float

	mrb_get_args( mrb, "if", &param0, &param1 );

	Mesh ret = GenMeshPoly( param0, param1 );

	return class_raylib_mesh_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_gen_mesh_plane( mrb_state *mrb, mrb_value self ) {
	mrb_float param0; // float
	mrb_float param1; // float
	mrb_int param2; // int
	mrb_int param3; // int

	mrb_get_args( mrb, "ffii", &param0, &param1, &param2, &param3 );

	Mesh ret = GenMeshPlane( param0, param1, param2, param3 );

	return class_raylib_mesh_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_gen_mesh_cube( mrb_state *mrb, mrb_value self ) {
	mrb_float param0; // float
	mrb_float param1; // float
	mrb_float param2; // float

	mrb_get_args( mrb, "fff", &param0, &param1, &param2 );

	Mesh ret = GenMeshCube( param0, param1, param2 );

	return class_raylib_mesh_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_gen_mesh_sphere( mrb_state *mrb, mrb_value self ) {
	mrb_float param0; // float
	mrb_int param1; // int
	mrb_int param2; // int

	mrb_get_args( mrb, "fii", &param0, &param1, &param2 );

	Mesh ret = GenMeshSphere( param0, param1, param2 );

	return class_raylib_mesh_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_gen_mesh_hemi_sphere( mrb_state *mrb, mrb_value self ) {
	mrb_float param0; // float
	mrb_int param1; // int
	mrb_int param2; // int

	mrb_get_args( mrb, "fii", &param0, &param1, &param2 );

	Mesh ret = GenMeshHemiSphere( param0, param1, param2 );

	return class_raylib_mesh_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_gen_mesh_cylinder( mrb_state *mrb, mrb_value self ) {
	mrb_float param0; // float
	mrb_float param1; // float
	mrb_int param2; // int

	mrb_get_args( mrb, "ffi", &param0, &param1, &param2 );

	Mesh ret = GenMeshCylinder( param0, param1, param2 );

	return class_raylib_mesh_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_gen_mesh_cone( mrb_state *mrb, mrb_value self ) {
	mrb_float param0; // float
	mrb_float param1; // float
	mrb_int param2; // int

	mrb_get_args( mrb, "ffi", &param0, &param1, &param2 );

	Mesh ret = GenMeshCone( param0, param1, param2 );

	return class_raylib_mesh_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_gen_mesh_torus( mrb_state *mrb, mrb_value self ) {
	mrb_float param0; // float
	mrb_float param1; // float
	mrb_int param2; // int
	mrb_int param3; // int

	mrb_get_args( mrb, "ffii", &param0, &param1, &param2, &param3 );

	Mesh ret = GenMeshTorus( param0, param1, param2, param3 );

	return class_raylib_mesh_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_gen_mesh_knot( mrb_state *mrb, mrb_value self ) {
	mrb_float param0; // float
	mrb_float param1; // float
	mrb_int param2; // int
	mrb_int param3; // int

	mrb_get_args( mrb, "ffii", &param0, &param1, &param2, &param3 );

	Mesh ret = GenMeshKnot( param0, param1, param2, param3 );

	return class_raylib_mesh_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_gen_mesh_heightmap( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Image
	mrb_value param1; // Vector3

	mrb_get_args( mrb, "oo", &param0, &param1 );

	Mesh ret = GenMeshHeightmap( *class_raylib_image_get_ptr( mrb, param0 ), *class_raylib_vector3_get_ptr( mrb, param1 ) );

	return class_raylib_mesh_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_gen_mesh_cubicmap( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Image
	mrb_value param1; // Vector3

	mrb_get_args( mrb, "oo", &param0, &param1 );

	Mesh ret = GenMeshCubicmap( *class_raylib_image_get_ptr( mrb, param0 ), *class_raylib_vector3_get_ptr( mrb, param1 ) );

	return class_raylib_mesh_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_load_materials( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const char*
	mrb_value param1; // int*

	mrb_get_args( mrb, "S*", &param0, &param1 );

	Material* ret = LoadMaterials( RSTRING_PTR( param0 ), mrb_cptr( param1 ) );

	return class_raylib_material_2_mrbvalue( mrb, ret, 0 );
}

static mrb_value
mod_raylib_load_material_default( mrb_state *mrb, mrb_value self ) {
	Material ret = LoadMaterialDefault();

	return class_raylib_material_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_is_material_ready( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Material

	mrb_get_args( mrb, "o", &param0 );

	bool ret = IsMaterialReady( *class_raylib_material_get_ptr( mrb, param0 ) );

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_unload_material( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Material

	mrb_get_args( mrb, "o", &param0 );

	UnloadMaterial( *class_raylib_material_get_ptr( mrb, param0 ) );

	return self;
}

static mrb_value
mod_raylib_set_material_texture( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Material*
	mrb_int param1; // int
	mrb_value param2; // Texture2D

	mrb_get_args( mrb, "!did", &param0, &param1, &param2 );

	SetMaterialTexture( class_raylib_material_get_ptr( mrb, param0 ), param1, *class_raylib_texture_get_ptr( mrb, param2 ) );

	return self;
}

static mrb_value
mod_raylib_set_model_mesh_material( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Model*
	mrb_int param1; // int
	mrb_int param2; // int

	mrb_get_args( mrb, "!dii", &param0, &param1, &param2 );

	SetModelMeshMaterial( class_raylib_model_get_ptr( mrb, param0 ), param1, param2 );

	return self;
}

static mrb_value
mod_raylib_load_model_animations( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const char*
	mrb_value param1; // int*

	mrb_get_args( mrb, "S*", &param0, &param1 );

	ModelAnimation* ret = LoadModelAnimations( RSTRING_PTR( param0 ), mrb_cptr( param1 ) );

	return class_raylib_modelanimation_2_mrbvalue( mrb, ret, 0 );
}

static mrb_value
mod_raylib_update_model_animation( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Model
	mrb_value param1; // ModelAnimation
	mrb_int param2; // int

	mrb_get_args( mrb, "ooi", &param0, &param1, &param2 );

	UpdateModelAnimation( *class_raylib_model_get_ptr( mrb, param0 ), *class_raylib_modelanimation_get_ptr( mrb, param1 ), param2 );

	return self;
}

static mrb_value
mod_raylib_unload_model_animation( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // ModelAnimation

	mrb_get_args( mrb, "o", &param0 );

	UnloadModelAnimation( *class_raylib_modelanimation_get_ptr( mrb, param0 ) );

	return self;
}

static mrb_value
mod_raylib_unload_model_animations( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // ModelAnimation*
	mrb_int param1; // int

	mrb_get_args( mrb, "!di", &param0, &param1 );

	UnloadModelAnimations( class_raylib_modelanimation_get_ptr( mrb, param0 ), param1 );

	return self;
}

static mrb_value
mod_raylib_is_model_animation_valid( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Model
	mrb_value param1; // ModelAnimation

	mrb_get_args( mrb, "oo", &param0, &param1 );

	bool ret = IsModelAnimationValid( *class_raylib_model_get_ptr( mrb, param0 ), *class_raylib_modelanimation_get_ptr( mrb, param1 ) );

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_check_collision_spheres( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Vector3
	mrb_float param1; // float
	mrb_value param2; // Vector3
	mrb_float param3; // float

	mrb_get_args( mrb, "ofof", &param0, &param1, &param2, &param3 );

	bool ret = CheckCollisionSpheres( *class_raylib_vector3_get_ptr( mrb, param0 ), param1, *class_raylib_vector3_get_ptr( mrb, param2 ), param3 );

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_check_collision_boxes( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // BoundingBox
	mrb_value param1; // BoundingBox

	mrb_get_args( mrb, "oo", &param0, &param1 );

	bool ret = CheckCollisionBoxes( *class_raylib_boundingbox_get_ptr( mrb, param0 ), *class_raylib_boundingbox_get_ptr( mrb, param1 ) );

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_check_collision_box_sphere( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // BoundingBox
	mrb_value param1; // Vector3
	mrb_float param2; // float

	mrb_get_args( mrb, "oof", &param0, &param1, &param2 );

	bool ret = CheckCollisionBoxSphere( *class_raylib_boundingbox_get_ptr( mrb, param0 ), *class_raylib_vector3_get_ptr( mrb, param1 ), param2 );

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_get_ray_collision_sphere( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Ray
	mrb_value param1; // Vector3
	mrb_float param2; // float

	mrb_get_args( mrb, "oof", &param0, &param1, &param2 );

	RayCollision ret = GetRayCollisionSphere( *class_raylib_ray_get_ptr( mrb, param0 ), *class_raylib_vector3_get_ptr( mrb, param1 ), param2 );

	return class_raylib_raycollision_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_get_ray_collision_box( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Ray
	mrb_value param1; // BoundingBox

	mrb_get_args( mrb, "oo", &param0, &param1 );

	RayCollision ret = GetRayCollisionBox( *class_raylib_ray_get_ptr( mrb, param0 ), *class_raylib_boundingbox_get_ptr( mrb, param1 ) );

	return class_raylib_raycollision_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_get_ray_collision_mesh( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Ray
	mrb_value param1; // Mesh
	mrb_value param2; // Matrix

	mrb_get_args( mrb, "ooo", &param0, &param1, &param2 );

	RayCollision ret = GetRayCollisionMesh( *class_raylib_ray_get_ptr( mrb, param0 ), *class_raylib_mesh_get_ptr( mrb, param1 ), *class_raylib_matrix_get_ptr( mrb, param2 ) );

	return class_raylib_raycollision_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_get_ray_collision_triangle( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Ray
	mrb_value param1; // Vector3
	mrb_value param2; // Vector3
	mrb_value param3; // Vector3

	mrb_get_args( mrb, "oooo", &param0, &param1, &param2, &param3 );

	RayCollision ret = GetRayCollisionTriangle( *class_raylib_ray_get_ptr( mrb, param0 ), *class_raylib_vector3_get_ptr( mrb, param1 ), *class_raylib_vector3_get_ptr( mrb, param2 ), *class_raylib_vector3_get_ptr( mrb, param3 ) );

	return class_raylib_raycollision_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_get_ray_collision_quad( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Ray
	mrb_value param1; // Vector3
	mrb_value param2; // Vector3
	mrb_value param3; // Vector3
	mrb_value param4; // Vector3

	mrb_get_args( mrb, "ooooo", &param0, &param1, &param2, &param3, &param4 );

	RayCollision ret = GetRayCollisionQuad( *class_raylib_ray_get_ptr( mrb, param0 ), *class_raylib_vector3_get_ptr( mrb, param1 ), *class_raylib_vector3_get_ptr( mrb, param2 ), *class_raylib_vector3_get_ptr( mrb, param3 ), *class_raylib_vector3_get_ptr( mrb, param4 ) );

	return class_raylib_raycollision_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_init_audio_device( mrb_state *mrb, mrb_value self ) {
	InitAudioDevice();

	return self;
}

static mrb_value
mod_raylib_close_audio_device( mrb_state *mrb, mrb_value self ) {
	CloseAudioDevice();

	return self;
}

static mrb_value
mod_raylib_is_audio_device_ready( mrb_state *mrb, mrb_value self ) {
	bool ret = IsAudioDeviceReady();

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_set_master_volume( mrb_state *mrb, mrb_value self ) {
	mrb_float param0; // float

	mrb_get_args( mrb, "f", &param0 );

	SetMasterVolume( param0 );

	return self;
}

static mrb_value
mod_raylib_get_master_volume( mrb_state *mrb, mrb_value self ) {
	float ret = GetMasterVolume();

	return mrb_float_value( mrb, ret );
}

static mrb_value
mod_raylib_load_wave( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const char*

	mrb_get_args( mrb, "S", &param0 );

	Wave ret = LoadWave( RSTRING_PTR( param0 ) );

	return class_raylib_wave_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_load_wave_from_memory( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const char*
	mrb_value param1; // const unsigned char*
	mrb_int param2; // int

	mrb_get_args( mrb, "S!di", &param0, &param1, &param2 );

	Wave ret = LoadWaveFromMemory( RSTRING_PTR( param0 ), NULL, param2 );

	return class_raylib_wave_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_is_wave_ready( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Wave

	mrb_get_args( mrb, "o", &param0 );

	bool ret = IsWaveReady( *class_raylib_wave_get_ptr( mrb, param0 ) );

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_load_sound( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const char*

	mrb_get_args( mrb, "S", &param0 );

	Sound ret = LoadSound( RSTRING_PTR( param0 ) );

	return class_raylib_sound_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_load_sound_from_wave( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Wave

	mrb_get_args( mrb, "o", &param0 );

	Sound ret = LoadSoundFromWave( *class_raylib_wave_get_ptr( mrb, param0 ) );

	return class_raylib_sound_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_load_sound_alias( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Sound

	mrb_get_args( mrb, "o", &param0 );

	Sound ret = LoadSoundAlias( *class_raylib_sound_get_ptr( mrb, param0 ) );

	return class_raylib_sound_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_is_sound_ready( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Sound

	mrb_get_args( mrb, "o", &param0 );

	bool ret = IsSoundReady( *class_raylib_sound_get_ptr( mrb, param0 ) );

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_update_sound( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Sound
	mrb_value param1; // const void*
	mrb_int param2; // int

	mrb_get_args( mrb, "o!di", &param0, &param1, &param2 );

	UpdateSound( *class_raylib_sound_get_ptr( mrb, param0 ), mrb_cptr( param1 ), param2 );

	return self;
}

static mrb_value
mod_raylib_unload_wave( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Wave

	mrb_get_args( mrb, "o", &param0 );

	UnloadWave( *class_raylib_wave_get_ptr( mrb, param0 ) );

	return self;
}

static mrb_value
mod_raylib_unload_sound( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Sound

	mrb_get_args( mrb, "o", &param0 );

	UnloadSound( *class_raylib_sound_get_ptr( mrb, param0 ) );

	return self;
}

static mrb_value
mod_raylib_unload_sound_alias( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Sound

	mrb_get_args( mrb, "o", &param0 );

	UnloadSoundAlias( *class_raylib_sound_get_ptr( mrb, param0 ) );

	return self;
}

static mrb_value
mod_raylib_export_wave( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Wave
	mrb_value param1; // const char*

	mrb_get_args( mrb, "oS", &param0, &param1 );

	bool ret = ExportWave( *class_raylib_wave_get_ptr( mrb, param0 ), RSTRING_PTR( param1 ) );

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_export_wave_as_code( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Wave
	mrb_value param1; // const char*

	mrb_get_args( mrb, "oS", &param0, &param1 );

	bool ret = ExportWaveAsCode( *class_raylib_wave_get_ptr( mrb, param0 ), RSTRING_PTR( param1 ) );

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_play_sound( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Sound

	mrb_get_args( mrb, "o", &param0 );

	PlaySound( *class_raylib_sound_get_ptr( mrb, param0 ) );

	return self;
}

static mrb_value
mod_raylib_stop_sound( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Sound

	mrb_get_args( mrb, "o", &param0 );

	StopSound( *class_raylib_sound_get_ptr( mrb, param0 ) );

	return self;
}

static mrb_value
mod_raylib_pause_sound( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Sound

	mrb_get_args( mrb, "o", &param0 );

	PauseSound( *class_raylib_sound_get_ptr( mrb, param0 ) );

	return self;
}

static mrb_value
mod_raylib_resume_sound( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Sound

	mrb_get_args( mrb, "o", &param0 );

	ResumeSound( *class_raylib_sound_get_ptr( mrb, param0 ) );

	return self;
}

static mrb_value
mod_raylib_is_sound_playing( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Sound

	mrb_get_args( mrb, "o", &param0 );

	bool ret = IsSoundPlaying( *class_raylib_sound_get_ptr( mrb, param0 ) );

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_set_sound_volume( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Sound
	mrb_float param1; // float

	mrb_get_args( mrb, "of", &param0, &param1 );

	SetSoundVolume( *class_raylib_sound_get_ptr( mrb, param0 ), param1 );

	return self;
}

static mrb_value
mod_raylib_set_sound_pitch( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Sound
	mrb_float param1; // float

	mrb_get_args( mrb, "of", &param0, &param1 );

	SetSoundPitch( *class_raylib_sound_get_ptr( mrb, param0 ), param1 );

	return self;
}

static mrb_value
mod_raylib_set_sound_pan( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Sound
	mrb_float param1; // float

	mrb_get_args( mrb, "of", &param0, &param1 );

	SetSoundPan( *class_raylib_sound_get_ptr( mrb, param0 ), param1 );

	return self;
}

static mrb_value
mod_raylib_wave_copy( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Wave

	mrb_get_args( mrb, "o", &param0 );

	Wave ret = WaveCopy( *class_raylib_wave_get_ptr( mrb, param0 ) );

	return class_raylib_wave_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_wave_crop( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Wave*
	mrb_int param1; // int
	mrb_int param2; // int

	mrb_get_args( mrb, "!dii", &param0, &param1, &param2 );

	WaveCrop( class_raylib_wave_get_ptr( mrb, param0 ), param1, param2 );

	return self;
}

static mrb_value
mod_raylib_wave_format( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Wave*
	mrb_int param1; // int
	mrb_int param2; // int
	mrb_int param3; // int

	mrb_get_args( mrb, "!diii", &param0, &param1, &param2, &param3 );

	WaveFormat( class_raylib_wave_get_ptr( mrb, param0 ), param1, param2, param3 );

	return self;
}

static mrb_value
mod_raylib_load_wave_samples( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Wave

	mrb_get_args( mrb, "o", &param0 );

	float* ret = LoadWaveSamples( *class_raylib_wave_get_ptr( mrb, param0 ) );

	return mrb_cptr_value( mrb, ( void* )( ret ) );
}

static mrb_value
mod_raylib_unload_wave_samples( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // float*

	mrb_get_args( mrb, "*", &param0 );

	UnloadWaveSamples( mrb_cptr( param0 ) );

	return self;
}

static mrb_value
mod_raylib_load_music_stream( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const char*

	mrb_get_args( mrb, "S", &param0 );

	Music ret = LoadMusicStream( RSTRING_PTR( param0 ) );

	return class_raylib_music_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_load_music_stream_from_memory( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // const char*
	mrb_value param1; // const unsigned char*
	mrb_int param2; // int

	mrb_get_args( mrb, "S!di", &param0, &param1, &param2 );

	Music ret = LoadMusicStreamFromMemory( RSTRING_PTR( param0 ), NULL, param2 );

	return class_raylib_music_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_is_music_ready( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Music

	mrb_get_args( mrb, "o", &param0 );

	bool ret = IsMusicReady( *class_raylib_music_get_ptr( mrb, param0 ) );

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_unload_music_stream( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Music

	mrb_get_args( mrb, "o", &param0 );

	UnloadMusicStream( *class_raylib_music_get_ptr( mrb, param0 ) );

	return self;
}

static mrb_value
mod_raylib_play_music_stream( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Music

	mrb_get_args( mrb, "o", &param0 );

	PlayMusicStream( *class_raylib_music_get_ptr( mrb, param0 ) );

	return self;
}

static mrb_value
mod_raylib_is_music_stream_playing( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Music

	mrb_get_args( mrb, "o", &param0 );

	bool ret = IsMusicStreamPlaying( *class_raylib_music_get_ptr( mrb, param0 ) );

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_update_music_stream( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Music

	mrb_get_args( mrb, "o", &param0 );

	UpdateMusicStream( *class_raylib_music_get_ptr( mrb, param0 ) );

	return self;
}

static mrb_value
mod_raylib_stop_music_stream( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Music

	mrb_get_args( mrb, "o", &param0 );

	StopMusicStream( *class_raylib_music_get_ptr( mrb, param0 ) );

	return self;
}

static mrb_value
mod_raylib_pause_music_stream( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Music

	mrb_get_args( mrb, "o", &param0 );

	PauseMusicStream( *class_raylib_music_get_ptr( mrb, param0 ) );

	return self;
}

static mrb_value
mod_raylib_resume_music_stream( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Music

	mrb_get_args( mrb, "o", &param0 );

	ResumeMusicStream( *class_raylib_music_get_ptr( mrb, param0 ) );

	return self;
}

static mrb_value
mod_raylib_seek_music_stream( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Music
	mrb_float param1; // float

	mrb_get_args( mrb, "of", &param0, &param1 );

	SeekMusicStream( *class_raylib_music_get_ptr( mrb, param0 ), param1 );

	return self;
}

static mrb_value
mod_raylib_set_music_volume( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Music
	mrb_float param1; // float

	mrb_get_args( mrb, "of", &param0, &param1 );

	SetMusicVolume( *class_raylib_music_get_ptr( mrb, param0 ), param1 );

	return self;
}

static mrb_value
mod_raylib_set_music_pitch( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Music
	mrb_float param1; // float

	mrb_get_args( mrb, "of", &param0, &param1 );

	SetMusicPitch( *class_raylib_music_get_ptr( mrb, param0 ), param1 );

	return self;
}

static mrb_value
mod_raylib_set_music_pan( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Music
	mrb_float param1; // float

	mrb_get_args( mrb, "of", &param0, &param1 );

	SetMusicPan( *class_raylib_music_get_ptr( mrb, param0 ), param1 );

	return self;
}

static mrb_value
mod_raylib_get_music_time_length( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Music

	mrb_get_args( mrb, "o", &param0 );

	float ret = GetMusicTimeLength( *class_raylib_music_get_ptr( mrb, param0 ) );

	return mrb_float_value( mrb, ret );
}

static mrb_value
mod_raylib_get_music_time_played( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // Music

	mrb_get_args( mrb, "o", &param0 );

	float ret = GetMusicTimePlayed( *class_raylib_music_get_ptr( mrb, param0 ) );

	return mrb_float_value( mrb, ret );
}

static mrb_value
mod_raylib_load_audio_stream( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // unsigned int
	mrb_int param1; // unsigned int
	mrb_int param2; // unsigned int

	mrb_get_args( mrb, "iii", &param0, &param1, &param2 );

	AudioStream ret = LoadAudioStream( param0, param1, param2 );

	return class_raylib_audiostream_2_mrbvalue( mrb, &ret, 0 );
}

static mrb_value
mod_raylib_is_audio_stream_ready( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // AudioStream

	mrb_get_args( mrb, "o", &param0 );

	bool ret = IsAudioStreamReady( *class_raylib_audiostream_get_ptr( mrb, param0 ) );

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_unload_audio_stream( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // AudioStream

	mrb_get_args( mrb, "o", &param0 );

	UnloadAudioStream( *class_raylib_audiostream_get_ptr( mrb, param0 ) );

	return self;
}

static mrb_value
mod_raylib_update_audio_stream( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // AudioStream
	mrb_value param1; // const void*
	mrb_int param2; // int

	mrb_get_args( mrb, "o!di", &param0, &param1, &param2 );

	UpdateAudioStream( *class_raylib_audiostream_get_ptr( mrb, param0 ), mrb_cptr( param1 ), param2 );

	return self;
}

static mrb_value
mod_raylib_is_audio_stream_processed( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // AudioStream

	mrb_get_args( mrb, "o", &param0 );

	bool ret = IsAudioStreamProcessed( *class_raylib_audiostream_get_ptr( mrb, param0 ) );

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_play_audio_stream( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // AudioStream

	mrb_get_args( mrb, "o", &param0 );

	PlayAudioStream( *class_raylib_audiostream_get_ptr( mrb, param0 ) );

	return self;
}

static mrb_value
mod_raylib_pause_audio_stream( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // AudioStream

	mrb_get_args( mrb, "o", &param0 );

	PauseAudioStream( *class_raylib_audiostream_get_ptr( mrb, param0 ) );

	return self;
}

static mrb_value
mod_raylib_resume_audio_stream( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // AudioStream

	mrb_get_args( mrb, "o", &param0 );

	ResumeAudioStream( *class_raylib_audiostream_get_ptr( mrb, param0 ) );

	return self;
}

static mrb_value
mod_raylib_is_audio_stream_playing( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // AudioStream

	mrb_get_args( mrb, "o", &param0 );

	bool ret = IsAudioStreamPlaying( *class_raylib_audiostream_get_ptr( mrb, param0 ) );

	return mrb_bool_value( ret );
}

static mrb_value
mod_raylib_stop_audio_stream( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // AudioStream

	mrb_get_args( mrb, "o", &param0 );

	StopAudioStream( *class_raylib_audiostream_get_ptr( mrb, param0 ) );

	return self;
}

static mrb_value
mod_raylib_set_audio_stream_volume( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // AudioStream
	mrb_float param1; // float

	mrb_get_args( mrb, "of", &param0, &param1 );

	SetAudioStreamVolume( *class_raylib_audiostream_get_ptr( mrb, param0 ), param1 );

	return self;
}

static mrb_value
mod_raylib_set_audio_stream_pitch( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // AudioStream
	mrb_float param1; // float

	mrb_get_args( mrb, "of", &param0, &param1 );

	SetAudioStreamPitch( *class_raylib_audiostream_get_ptr( mrb, param0 ), param1 );

	return self;
}

static mrb_value
mod_raylib_set_audio_stream_pan( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // AudioStream
	mrb_float param1; // float

	mrb_get_args( mrb, "of", &param0, &param1 );

	SetAudioStreamPan( *class_raylib_audiostream_get_ptr( mrb, param0 ), param1 );

	return self;
}

static mrb_value
mod_raylib_set_audio_stream_buffer_size_default( mrb_state *mrb, mrb_value self ) {
	mrb_int param0; // int

	mrb_get_args( mrb, "i", &param0 );

	SetAudioStreamBufferSizeDefault( param0 );

	return self;
}

static mrb_value
mod_raylib_set_audio_stream_callback( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // AudioStream
	mrb_value param1; // AudioCallback

	mrb_get_args( mrb, "o*", &param0, &param1 );

	SetAudioStreamCallback( *class_raylib_audiostream_get_ptr( mrb, param0 ), NULL );

	return self;
}

static mrb_value
mod_raylib_attach_audio_stream_processor( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // AudioStream
	mrb_value param1; // AudioCallback

	mrb_get_args( mrb, "o*", &param0, &param1 );

	AttachAudioStreamProcessor( *class_raylib_audiostream_get_ptr( mrb, param0 ), NULL );

	return self;
}

static mrb_value
mod_raylib_detach_audio_stream_processor( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // AudioStream
	mrb_value param1; // AudioCallback

	mrb_get_args( mrb, "o*", &param0, &param1 );

	DetachAudioStreamProcessor( *class_raylib_audiostream_get_ptr( mrb, param0 ), NULL );

	return self;
}

static mrb_value
mod_raylib_attach_audio_mixed_processor( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // AudioCallback

	mrb_get_args( mrb, "*", &param0 );

	AttachAudioMixedProcessor( NULL );

	return self;
}

static mrb_value
mod_raylib_detach_audio_mixed_processor( mrb_state *mrb, mrb_value self ) {
	mrb_value param0; // AudioCallback

	mrb_get_args( mrb, "*", &param0 );

	DetachAudioMixedProcessor( NULL );

	return self;
}

void
mrb_raylib_module_init( mrb_state *mrb ) {

	mod_RayLib = mrb_define_module( mrb, "Raylib" );
	class_RayLibError = mrb_define_class_under( mrb, mod_RayLib, "RaylibError", mrb->eStandardError_class );

	mrb_define_const( mrb, mod_RayLib, "VERSION", mrb_fixnum_value( 500 ) );
	mrb_define_const( mrb, mod_RayLib, "VERSION_MAJOR", mrb_fixnum_value( 5 ) );
	mrb_define_const( mrb, mod_RayLib, "VERSION_MINOR", mrb_fixnum_value( 0 ) );
	mrb_define_const( mrb, mod_RayLib, "VERSION_PATCH", mrb_fixnum_value( 0 ) );

	int arena_size = mrb_gc_arena_save(mrb);

	//----------------------------------------------------------------//
	// Raylib::ConfigFlags
	//----------------------------------------------------------------//
	mrb_define_const(mrb, mod_RayLib, "FLAG_VSYNC_HINT", mrb_fixnum_value(64));
	mrb_define_const(mrb, mod_RayLib, "FLAG_FULLSCREEN_MODE", mrb_fixnum_value(2));
	mrb_define_const(mrb, mod_RayLib, "FLAG_WINDOW_RESIZABLE", mrb_fixnum_value(4));
	mrb_define_const(mrb, mod_RayLib, "FLAG_WINDOW_UNDECORATED", mrb_fixnum_value(8));
	mrb_define_const(mrb, mod_RayLib, "FLAG_WINDOW_HIDDEN", mrb_fixnum_value(128));
	mrb_define_const(mrb, mod_RayLib, "FLAG_WINDOW_MINIMIZED", mrb_fixnum_value(512));
	mrb_define_const(mrb, mod_RayLib, "FLAG_WINDOW_MAXIMIZED", mrb_fixnum_value(1024));
	mrb_define_const(mrb, mod_RayLib, "FLAG_WINDOW_UNFOCUSED", mrb_fixnum_value(2048));
	mrb_define_const(mrb, mod_RayLib, "FLAG_WINDOW_TOPMOST", mrb_fixnum_value(4096));
	mrb_define_const(mrb, mod_RayLib, "FLAG_WINDOW_ALWAYS_RUN", mrb_fixnum_value(256));
	mrb_define_const(mrb, mod_RayLib, "FLAG_WINDOW_TRANSPARENT", mrb_fixnum_value(16));
	mrb_define_const(mrb, mod_RayLib, "FLAG_WINDOW_HIGHDPI", mrb_fixnum_value(8192));
	mrb_define_const(mrb, mod_RayLib, "FLAG_WINDOW_MOUSE_PASSTHROUGH", mrb_fixnum_value(16384));
	mrb_define_const(mrb, mod_RayLib, "FLAG_BORDERLESS_WINDOWED_MODE", mrb_fixnum_value(32768));
	mrb_define_const(mrb, mod_RayLib, "FLAG_MSAA_4X_HINT", mrb_fixnum_value(32));
	mrb_define_const(mrb, mod_RayLib, "FLAG_INTERLACED_HINT", mrb_fixnum_value(65536));

	struct RClass *mod_RayLib_ConfigFlags;
	mod_RayLib_ConfigFlags = mrb_define_module_under(mrb, mod_RayLib, "ConfigFlags" );
	mrb_define_const(mrb, mod_RayLib_ConfigFlags, "FLAG_VSYNC_HINT", mrb_fixnum_value(64));
	mrb_define_const(mrb, mod_RayLib_ConfigFlags, "FLAG_FULLSCREEN_MODE", mrb_fixnum_value(2));
	mrb_define_const(mrb, mod_RayLib_ConfigFlags, "FLAG_WINDOW_RESIZABLE", mrb_fixnum_value(4));
	mrb_define_const(mrb, mod_RayLib_ConfigFlags, "FLAG_WINDOW_UNDECORATED", mrb_fixnum_value(8));
	mrb_define_const(mrb, mod_RayLib_ConfigFlags, "FLAG_WINDOW_HIDDEN", mrb_fixnum_value(128));
	mrb_define_const(mrb, mod_RayLib_ConfigFlags, "FLAG_WINDOW_MINIMIZED", mrb_fixnum_value(512));
	mrb_define_const(mrb, mod_RayLib_ConfigFlags, "FLAG_WINDOW_MAXIMIZED", mrb_fixnum_value(1024));
	mrb_define_const(mrb, mod_RayLib_ConfigFlags, "FLAG_WINDOW_UNFOCUSED", mrb_fixnum_value(2048));
	mrb_define_const(mrb, mod_RayLib_ConfigFlags, "FLAG_WINDOW_TOPMOST", mrb_fixnum_value(4096));
	mrb_define_const(mrb, mod_RayLib_ConfigFlags, "FLAG_WINDOW_ALWAYS_RUN", mrb_fixnum_value(256));
	mrb_define_const(mrb, mod_RayLib_ConfigFlags, "FLAG_WINDOW_TRANSPARENT", mrb_fixnum_value(16));
	mrb_define_const(mrb, mod_RayLib_ConfigFlags, "FLAG_WINDOW_HIGHDPI", mrb_fixnum_value(8192));
	mrb_define_const(mrb, mod_RayLib_ConfigFlags, "FLAG_WINDOW_MOUSE_PASSTHROUGH", mrb_fixnum_value(16384));
	mrb_define_const(mrb, mod_RayLib_ConfigFlags, "FLAG_BORDERLESS_WINDOWED_MODE", mrb_fixnum_value(32768));
	mrb_define_const(mrb, mod_RayLib_ConfigFlags, "FLAG_MSAA_4X_HINT", mrb_fixnum_value(32));
	mrb_define_const(mrb, mod_RayLib_ConfigFlags, "FLAG_INTERLACED_HINT", mrb_fixnum_value(65536));

	//----------------------------------------------------------------//
	// Raylib::TraceLogLevel
	//----------------------------------------------------------------//
	mrb_define_const(mrb, mod_RayLib, "LOG_ALL", mrb_fixnum_value(0));
	mrb_define_const(mrb, mod_RayLib, "LOG_TRACE", mrb_fixnum_value(1));
	mrb_define_const(mrb, mod_RayLib, "LOG_DEBUG", mrb_fixnum_value(2));
	mrb_define_const(mrb, mod_RayLib, "LOG_INFO", mrb_fixnum_value(3));
	mrb_define_const(mrb, mod_RayLib, "LOG_WARNING", mrb_fixnum_value(4));
	mrb_define_const(mrb, mod_RayLib, "LOG_ERROR", mrb_fixnum_value(5));
	mrb_define_const(mrb, mod_RayLib, "LOG_FATAL", mrb_fixnum_value(6));
	mrb_define_const(mrb, mod_RayLib, "LOG_NONE", mrb_fixnum_value(7));

	struct RClass *mod_RayLib_TraceLogLevel;
	mod_RayLib_TraceLogLevel = mrb_define_module_under(mrb, mod_RayLib, "TraceLogLevel" );
	mrb_define_const(mrb, mod_RayLib_TraceLogLevel, "LOG_ALL", mrb_fixnum_value(0));
	mrb_define_const(mrb, mod_RayLib_TraceLogLevel, "LOG_TRACE", mrb_fixnum_value(1));
	mrb_define_const(mrb, mod_RayLib_TraceLogLevel, "LOG_DEBUG", mrb_fixnum_value(2));
	mrb_define_const(mrb, mod_RayLib_TraceLogLevel, "LOG_INFO", mrb_fixnum_value(3));
	mrb_define_const(mrb, mod_RayLib_TraceLogLevel, "LOG_WARNING", mrb_fixnum_value(4));
	mrb_define_const(mrb, mod_RayLib_TraceLogLevel, "LOG_ERROR", mrb_fixnum_value(5));
	mrb_define_const(mrb, mod_RayLib_TraceLogLevel, "LOG_FATAL", mrb_fixnum_value(6));
	mrb_define_const(mrb, mod_RayLib_TraceLogLevel, "LOG_NONE", mrb_fixnum_value(7));

	//----------------------------------------------------------------//
	// Raylib::KeyboardKey
	//----------------------------------------------------------------//
	mrb_define_const(mrb, mod_RayLib, "KEY_NULL", mrb_fixnum_value(0));
	mrb_define_const(mrb, mod_RayLib, "KEY_APOSTROPHE", mrb_fixnum_value(39));
	mrb_define_const(mrb, mod_RayLib, "KEY_COMMA", mrb_fixnum_value(44));
	mrb_define_const(mrb, mod_RayLib, "KEY_MINUS", mrb_fixnum_value(45));
	mrb_define_const(mrb, mod_RayLib, "KEY_PERIOD", mrb_fixnum_value(46));
	mrb_define_const(mrb, mod_RayLib, "KEY_SLASH", mrb_fixnum_value(47));
	mrb_define_const(mrb, mod_RayLib, "KEY_ZERO", mrb_fixnum_value(48));
	mrb_define_const(mrb, mod_RayLib, "KEY_ONE", mrb_fixnum_value(49));
	mrb_define_const(mrb, mod_RayLib, "KEY_TWO", mrb_fixnum_value(50));
	mrb_define_const(mrb, mod_RayLib, "KEY_THREE", mrb_fixnum_value(51));
	mrb_define_const(mrb, mod_RayLib, "KEY_FOUR", mrb_fixnum_value(52));
	mrb_define_const(mrb, mod_RayLib, "KEY_FIVE", mrb_fixnum_value(53));
	mrb_define_const(mrb, mod_RayLib, "KEY_SIX", mrb_fixnum_value(54));
	mrb_define_const(mrb, mod_RayLib, "KEY_SEVEN", mrb_fixnum_value(55));
	mrb_define_const(mrb, mod_RayLib, "KEY_EIGHT", mrb_fixnum_value(56));
	mrb_define_const(mrb, mod_RayLib, "KEY_NINE", mrb_fixnum_value(57));
	mrb_define_const(mrb, mod_RayLib, "KEY_SEMICOLON", mrb_fixnum_value(59));
	mrb_define_const(mrb, mod_RayLib, "KEY_EQUAL", mrb_fixnum_value(61));
	mrb_define_const(mrb, mod_RayLib, "KEY_A", mrb_fixnum_value(65));
	mrb_define_const(mrb, mod_RayLib, "KEY_B", mrb_fixnum_value(66));
	mrb_define_const(mrb, mod_RayLib, "KEY_C", mrb_fixnum_value(67));
	mrb_define_const(mrb, mod_RayLib, "KEY_D", mrb_fixnum_value(68));
	mrb_define_const(mrb, mod_RayLib, "KEY_E", mrb_fixnum_value(69));
	mrb_define_const(mrb, mod_RayLib, "KEY_F", mrb_fixnum_value(70));
	mrb_define_const(mrb, mod_RayLib, "KEY_G", mrb_fixnum_value(71));
	mrb_define_const(mrb, mod_RayLib, "KEY_H", mrb_fixnum_value(72));
	mrb_define_const(mrb, mod_RayLib, "KEY_I", mrb_fixnum_value(73));
	mrb_define_const(mrb, mod_RayLib, "KEY_J", mrb_fixnum_value(74));
	mrb_define_const(mrb, mod_RayLib, "KEY_K", mrb_fixnum_value(75));
	mrb_define_const(mrb, mod_RayLib, "KEY_L", mrb_fixnum_value(76));
	mrb_define_const(mrb, mod_RayLib, "KEY_M", mrb_fixnum_value(77));
	mrb_define_const(mrb, mod_RayLib, "KEY_N", mrb_fixnum_value(78));
	mrb_define_const(mrb, mod_RayLib, "KEY_O", mrb_fixnum_value(79));
	mrb_define_const(mrb, mod_RayLib, "KEY_P", mrb_fixnum_value(80));
	mrb_define_const(mrb, mod_RayLib, "KEY_Q", mrb_fixnum_value(81));
	mrb_define_const(mrb, mod_RayLib, "KEY_R", mrb_fixnum_value(82));
	mrb_define_const(mrb, mod_RayLib, "KEY_S", mrb_fixnum_value(83));
	mrb_define_const(mrb, mod_RayLib, "KEY_T", mrb_fixnum_value(84));
	mrb_define_const(mrb, mod_RayLib, "KEY_U", mrb_fixnum_value(85));
	mrb_define_const(mrb, mod_RayLib, "KEY_V", mrb_fixnum_value(86));
	mrb_define_const(mrb, mod_RayLib, "KEY_W", mrb_fixnum_value(87));
	mrb_define_const(mrb, mod_RayLib, "KEY_X", mrb_fixnum_value(88));
	mrb_define_const(mrb, mod_RayLib, "KEY_Y", mrb_fixnum_value(89));
	mrb_define_const(mrb, mod_RayLib, "KEY_Z", mrb_fixnum_value(90));
	mrb_define_const(mrb, mod_RayLib, "KEY_LEFT_BRACKET", mrb_fixnum_value(91));
	mrb_define_const(mrb, mod_RayLib, "KEY_BACKSLASH", mrb_fixnum_value(92));
	mrb_define_const(mrb, mod_RayLib, "KEY_RIGHT_BRACKET", mrb_fixnum_value(93));
	mrb_define_const(mrb, mod_RayLib, "KEY_GRAVE", mrb_fixnum_value(96));
	mrb_define_const(mrb, mod_RayLib, "KEY_SPACE", mrb_fixnum_value(32));
	mrb_define_const(mrb, mod_RayLib, "KEY_ESCAPE", mrb_fixnum_value(256));
	mrb_define_const(mrb, mod_RayLib, "KEY_ENTER", mrb_fixnum_value(257));
	mrb_define_const(mrb, mod_RayLib, "KEY_TAB", mrb_fixnum_value(258));
	mrb_define_const(mrb, mod_RayLib, "KEY_BACKSPACE", mrb_fixnum_value(259));
	mrb_define_const(mrb, mod_RayLib, "KEY_INSERT", mrb_fixnum_value(260));
	mrb_define_const(mrb, mod_RayLib, "KEY_DELETE", mrb_fixnum_value(261));
	mrb_define_const(mrb, mod_RayLib, "KEY_RIGHT", mrb_fixnum_value(262));
	mrb_define_const(mrb, mod_RayLib, "KEY_LEFT", mrb_fixnum_value(263));
	mrb_define_const(mrb, mod_RayLib, "KEY_DOWN", mrb_fixnum_value(264));
	mrb_define_const(mrb, mod_RayLib, "KEY_UP", mrb_fixnum_value(265));
	mrb_define_const(mrb, mod_RayLib, "KEY_PAGE_UP", mrb_fixnum_value(266));
	mrb_define_const(mrb, mod_RayLib, "KEY_PAGE_DOWN", mrb_fixnum_value(267));
	mrb_define_const(mrb, mod_RayLib, "KEY_HOME", mrb_fixnum_value(268));
	mrb_define_const(mrb, mod_RayLib, "KEY_END", mrb_fixnum_value(269));
	mrb_define_const(mrb, mod_RayLib, "KEY_CAPS_LOCK", mrb_fixnum_value(280));
	mrb_define_const(mrb, mod_RayLib, "KEY_SCROLL_LOCK", mrb_fixnum_value(281));
	mrb_define_const(mrb, mod_RayLib, "KEY_NUM_LOCK", mrb_fixnum_value(282));
	mrb_define_const(mrb, mod_RayLib, "KEY_PRINT_SCREEN", mrb_fixnum_value(283));
	mrb_define_const(mrb, mod_RayLib, "KEY_PAUSE", mrb_fixnum_value(284));
	mrb_define_const(mrb, mod_RayLib, "KEY_F1", mrb_fixnum_value(290));
	mrb_define_const(mrb, mod_RayLib, "KEY_F2", mrb_fixnum_value(291));
	mrb_define_const(mrb, mod_RayLib, "KEY_F3", mrb_fixnum_value(292));
	mrb_define_const(mrb, mod_RayLib, "KEY_F4", mrb_fixnum_value(293));
	mrb_define_const(mrb, mod_RayLib, "KEY_F5", mrb_fixnum_value(294));
	mrb_define_const(mrb, mod_RayLib, "KEY_F6", mrb_fixnum_value(295));
	mrb_define_const(mrb, mod_RayLib, "KEY_F7", mrb_fixnum_value(296));
	mrb_define_const(mrb, mod_RayLib, "KEY_F8", mrb_fixnum_value(297));
	mrb_define_const(mrb, mod_RayLib, "KEY_F9", mrb_fixnum_value(298));
	mrb_define_const(mrb, mod_RayLib, "KEY_F10", mrb_fixnum_value(299));
	mrb_define_const(mrb, mod_RayLib, "KEY_F11", mrb_fixnum_value(300));
	mrb_define_const(mrb, mod_RayLib, "KEY_F12", mrb_fixnum_value(301));
	mrb_define_const(mrb, mod_RayLib, "KEY_LEFT_SHIFT", mrb_fixnum_value(340));
	mrb_define_const(mrb, mod_RayLib, "KEY_LEFT_CONTROL", mrb_fixnum_value(341));
	mrb_define_const(mrb, mod_RayLib, "KEY_LEFT_ALT", mrb_fixnum_value(342));
	mrb_define_const(mrb, mod_RayLib, "KEY_LEFT_SUPER", mrb_fixnum_value(343));
	mrb_define_const(mrb, mod_RayLib, "KEY_RIGHT_SHIFT", mrb_fixnum_value(344));
	mrb_define_const(mrb, mod_RayLib, "KEY_RIGHT_CONTROL", mrb_fixnum_value(345));
	mrb_define_const(mrb, mod_RayLib, "KEY_RIGHT_ALT", mrb_fixnum_value(346));
	mrb_define_const(mrb, mod_RayLib, "KEY_RIGHT_SUPER", mrb_fixnum_value(347));
	mrb_define_const(mrb, mod_RayLib, "KEY_KB_MENU", mrb_fixnum_value(348));
	mrb_define_const(mrb, mod_RayLib, "KEY_KP_0", mrb_fixnum_value(320));
	mrb_define_const(mrb, mod_RayLib, "KEY_KP_1", mrb_fixnum_value(321));
	mrb_define_const(mrb, mod_RayLib, "KEY_KP_2", mrb_fixnum_value(322));
	mrb_define_const(mrb, mod_RayLib, "KEY_KP_3", mrb_fixnum_value(323));
	mrb_define_const(mrb, mod_RayLib, "KEY_KP_4", mrb_fixnum_value(324));
	mrb_define_const(mrb, mod_RayLib, "KEY_KP_5", mrb_fixnum_value(325));
	mrb_define_const(mrb, mod_RayLib, "KEY_KP_6", mrb_fixnum_value(326));
	mrb_define_const(mrb, mod_RayLib, "KEY_KP_7", mrb_fixnum_value(327));
	mrb_define_const(mrb, mod_RayLib, "KEY_KP_8", mrb_fixnum_value(328));
	mrb_define_const(mrb, mod_RayLib, "KEY_KP_9", mrb_fixnum_value(329));
	mrb_define_const(mrb, mod_RayLib, "KEY_KP_DECIMAL", mrb_fixnum_value(330));
	mrb_define_const(mrb, mod_RayLib, "KEY_KP_DIVIDE", mrb_fixnum_value(331));
	mrb_define_const(mrb, mod_RayLib, "KEY_KP_MULTIPLY", mrb_fixnum_value(332));
	mrb_define_const(mrb, mod_RayLib, "KEY_KP_SUBTRACT", mrb_fixnum_value(333));
	mrb_define_const(mrb, mod_RayLib, "KEY_KP_ADD", mrb_fixnum_value(334));
	mrb_define_const(mrb, mod_RayLib, "KEY_KP_ENTER", mrb_fixnum_value(335));
	mrb_define_const(mrb, mod_RayLib, "KEY_KP_EQUAL", mrb_fixnum_value(336));
	mrb_define_const(mrb, mod_RayLib, "KEY_BACK", mrb_fixnum_value(4));
	mrb_define_const(mrb, mod_RayLib, "KEY_MENU", mrb_fixnum_value(82));
	mrb_define_const(mrb, mod_RayLib, "KEY_VOLUME_UP", mrb_fixnum_value(24));
	mrb_define_const(mrb, mod_RayLib, "KEY_VOLUME_DOWN", mrb_fixnum_value(25));

	struct RClass *mod_RayLib_KeyboardKey;
	mod_RayLib_KeyboardKey = mrb_define_module_under(mrb, mod_RayLib, "KeyboardKey" );
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_NULL", mrb_fixnum_value(0));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_APOSTROPHE", mrb_fixnum_value(39));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_COMMA", mrb_fixnum_value(44));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_MINUS", mrb_fixnum_value(45));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_PERIOD", mrb_fixnum_value(46));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_SLASH", mrb_fixnum_value(47));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_ZERO", mrb_fixnum_value(48));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_ONE", mrb_fixnum_value(49));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_TWO", mrb_fixnum_value(50));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_THREE", mrb_fixnum_value(51));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_FOUR", mrb_fixnum_value(52));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_FIVE", mrb_fixnum_value(53));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_SIX", mrb_fixnum_value(54));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_SEVEN", mrb_fixnum_value(55));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_EIGHT", mrb_fixnum_value(56));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_NINE", mrb_fixnum_value(57));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_SEMICOLON", mrb_fixnum_value(59));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_EQUAL", mrb_fixnum_value(61));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_A", mrb_fixnum_value(65));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_B", mrb_fixnum_value(66));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_C", mrb_fixnum_value(67));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_D", mrb_fixnum_value(68));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_E", mrb_fixnum_value(69));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_F", mrb_fixnum_value(70));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_G", mrb_fixnum_value(71));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_H", mrb_fixnum_value(72));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_I", mrb_fixnum_value(73));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_J", mrb_fixnum_value(74));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_K", mrb_fixnum_value(75));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_L", mrb_fixnum_value(76));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_M", mrb_fixnum_value(77));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_N", mrb_fixnum_value(78));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_O", mrb_fixnum_value(79));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_P", mrb_fixnum_value(80));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_Q", mrb_fixnum_value(81));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_R", mrb_fixnum_value(82));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_S", mrb_fixnum_value(83));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_T", mrb_fixnum_value(84));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_U", mrb_fixnum_value(85));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_V", mrb_fixnum_value(86));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_W", mrb_fixnum_value(87));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_X", mrb_fixnum_value(88));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_Y", mrb_fixnum_value(89));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_Z", mrb_fixnum_value(90));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_LEFT_BRACKET", mrb_fixnum_value(91));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_BACKSLASH", mrb_fixnum_value(92));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_RIGHT_BRACKET", mrb_fixnum_value(93));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_GRAVE", mrb_fixnum_value(96));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_SPACE", mrb_fixnum_value(32));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_ESCAPE", mrb_fixnum_value(256));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_ENTER", mrb_fixnum_value(257));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_TAB", mrb_fixnum_value(258));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_BACKSPACE", mrb_fixnum_value(259));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_INSERT", mrb_fixnum_value(260));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_DELETE", mrb_fixnum_value(261));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_RIGHT", mrb_fixnum_value(262));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_LEFT", mrb_fixnum_value(263));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_DOWN", mrb_fixnum_value(264));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_UP", mrb_fixnum_value(265));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_PAGE_UP", mrb_fixnum_value(266));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_PAGE_DOWN", mrb_fixnum_value(267));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_HOME", mrb_fixnum_value(268));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_END", mrb_fixnum_value(269));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_CAPS_LOCK", mrb_fixnum_value(280));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_SCROLL_LOCK", mrb_fixnum_value(281));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_NUM_LOCK", mrb_fixnum_value(282));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_PRINT_SCREEN", mrb_fixnum_value(283));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_PAUSE", mrb_fixnum_value(284));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_F1", mrb_fixnum_value(290));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_F2", mrb_fixnum_value(291));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_F3", mrb_fixnum_value(292));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_F4", mrb_fixnum_value(293));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_F5", mrb_fixnum_value(294));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_F6", mrb_fixnum_value(295));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_F7", mrb_fixnum_value(296));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_F8", mrb_fixnum_value(297));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_F9", mrb_fixnum_value(298));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_F10", mrb_fixnum_value(299));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_F11", mrb_fixnum_value(300));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_F12", mrb_fixnum_value(301));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_LEFT_SHIFT", mrb_fixnum_value(340));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_LEFT_CONTROL", mrb_fixnum_value(341));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_LEFT_ALT", mrb_fixnum_value(342));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_LEFT_SUPER", mrb_fixnum_value(343));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_RIGHT_SHIFT", mrb_fixnum_value(344));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_RIGHT_CONTROL", mrb_fixnum_value(345));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_RIGHT_ALT", mrb_fixnum_value(346));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_RIGHT_SUPER", mrb_fixnum_value(347));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_KB_MENU", mrb_fixnum_value(348));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_KP_0", mrb_fixnum_value(320));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_KP_1", mrb_fixnum_value(321));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_KP_2", mrb_fixnum_value(322));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_KP_3", mrb_fixnum_value(323));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_KP_4", mrb_fixnum_value(324));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_KP_5", mrb_fixnum_value(325));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_KP_6", mrb_fixnum_value(326));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_KP_7", mrb_fixnum_value(327));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_KP_8", mrb_fixnum_value(328));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_KP_9", mrb_fixnum_value(329));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_KP_DECIMAL", mrb_fixnum_value(330));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_KP_DIVIDE", mrb_fixnum_value(331));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_KP_MULTIPLY", mrb_fixnum_value(332));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_KP_SUBTRACT", mrb_fixnum_value(333));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_KP_ADD", mrb_fixnum_value(334));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_KP_ENTER", mrb_fixnum_value(335));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_KP_EQUAL", mrb_fixnum_value(336));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_BACK", mrb_fixnum_value(4));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_MENU", mrb_fixnum_value(82));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_VOLUME_UP", mrb_fixnum_value(24));
	mrb_define_const(mrb, mod_RayLib_KeyboardKey, "KEY_VOLUME_DOWN", mrb_fixnum_value(25));

	//----------------------------------------------------------------//
	// Raylib::MouseButton
	//----------------------------------------------------------------//
	mrb_define_const(mrb, mod_RayLib, "MOUSE_BUTTON_LEFT", mrb_fixnum_value(0));
	mrb_define_const(mrb, mod_RayLib, "MOUSE_BUTTON_RIGHT", mrb_fixnum_value(1));
	mrb_define_const(mrb, mod_RayLib, "MOUSE_BUTTON_MIDDLE", mrb_fixnum_value(2));
	mrb_define_const(mrb, mod_RayLib, "MOUSE_BUTTON_SIDE", mrb_fixnum_value(3));
	mrb_define_const(mrb, mod_RayLib, "MOUSE_BUTTON_EXTRA", mrb_fixnum_value(4));
	mrb_define_const(mrb, mod_RayLib, "MOUSE_BUTTON_FORWARD", mrb_fixnum_value(5));
	mrb_define_const(mrb, mod_RayLib, "MOUSE_BUTTON_BACK", mrb_fixnum_value(6));

	struct RClass *mod_RayLib_MouseButton;
	mod_RayLib_MouseButton = mrb_define_module_under(mrb, mod_RayLib, "MouseButton" );
	mrb_define_const(mrb, mod_RayLib_MouseButton, "MOUSE_BUTTON_LEFT", mrb_fixnum_value(0));
	mrb_define_const(mrb, mod_RayLib_MouseButton, "MOUSE_BUTTON_RIGHT", mrb_fixnum_value(1));
	mrb_define_const(mrb, mod_RayLib_MouseButton, "MOUSE_BUTTON_MIDDLE", mrb_fixnum_value(2));
	mrb_define_const(mrb, mod_RayLib_MouseButton, "MOUSE_BUTTON_SIDE", mrb_fixnum_value(3));
	mrb_define_const(mrb, mod_RayLib_MouseButton, "MOUSE_BUTTON_EXTRA", mrb_fixnum_value(4));
	mrb_define_const(mrb, mod_RayLib_MouseButton, "MOUSE_BUTTON_FORWARD", mrb_fixnum_value(5));
	mrb_define_const(mrb, mod_RayLib_MouseButton, "MOUSE_BUTTON_BACK", mrb_fixnum_value(6));

	//----------------------------------------------------------------//
	// Raylib::MouseCursor
	//----------------------------------------------------------------//
	mrb_define_const(mrb, mod_RayLib, "MOUSE_CURSOR_DEFAULT", mrb_fixnum_value(0));
	mrb_define_const(mrb, mod_RayLib, "MOUSE_CURSOR_ARROW", mrb_fixnum_value(1));
	mrb_define_const(mrb, mod_RayLib, "MOUSE_CURSOR_IBEAM", mrb_fixnum_value(2));
	mrb_define_const(mrb, mod_RayLib, "MOUSE_CURSOR_CROSSHAIR", mrb_fixnum_value(3));
	mrb_define_const(mrb, mod_RayLib, "MOUSE_CURSOR_POINTING_HAND", mrb_fixnum_value(4));
	mrb_define_const(mrb, mod_RayLib, "MOUSE_CURSOR_RESIZE_EW", mrb_fixnum_value(5));
	mrb_define_const(mrb, mod_RayLib, "MOUSE_CURSOR_RESIZE_NS", mrb_fixnum_value(6));
	mrb_define_const(mrb, mod_RayLib, "MOUSE_CURSOR_RESIZE_NWSE", mrb_fixnum_value(7));
	mrb_define_const(mrb, mod_RayLib, "MOUSE_CURSOR_RESIZE_NESW", mrb_fixnum_value(8));
	mrb_define_const(mrb, mod_RayLib, "MOUSE_CURSOR_RESIZE_ALL", mrb_fixnum_value(9));
	mrb_define_const(mrb, mod_RayLib, "MOUSE_CURSOR_NOT_ALLOWED", mrb_fixnum_value(10));

	struct RClass *mod_RayLib_MouseCursor;
	mod_RayLib_MouseCursor = mrb_define_module_under(mrb, mod_RayLib, "MouseCursor" );
	mrb_define_const(mrb, mod_RayLib_MouseCursor, "MOUSE_CURSOR_DEFAULT", mrb_fixnum_value(0));
	mrb_define_const(mrb, mod_RayLib_MouseCursor, "MOUSE_CURSOR_ARROW", mrb_fixnum_value(1));
	mrb_define_const(mrb, mod_RayLib_MouseCursor, "MOUSE_CURSOR_IBEAM", mrb_fixnum_value(2));
	mrb_define_const(mrb, mod_RayLib_MouseCursor, "MOUSE_CURSOR_CROSSHAIR", mrb_fixnum_value(3));
	mrb_define_const(mrb, mod_RayLib_MouseCursor, "MOUSE_CURSOR_POINTING_HAND", mrb_fixnum_value(4));
	mrb_define_const(mrb, mod_RayLib_MouseCursor, "MOUSE_CURSOR_RESIZE_EW", mrb_fixnum_value(5));
	mrb_define_const(mrb, mod_RayLib_MouseCursor, "MOUSE_CURSOR_RESIZE_NS", mrb_fixnum_value(6));
	mrb_define_const(mrb, mod_RayLib_MouseCursor, "MOUSE_CURSOR_RESIZE_NWSE", mrb_fixnum_value(7));
	mrb_define_const(mrb, mod_RayLib_MouseCursor, "MOUSE_CURSOR_RESIZE_NESW", mrb_fixnum_value(8));
	mrb_define_const(mrb, mod_RayLib_MouseCursor, "MOUSE_CURSOR_RESIZE_ALL", mrb_fixnum_value(9));
	mrb_define_const(mrb, mod_RayLib_MouseCursor, "MOUSE_CURSOR_NOT_ALLOWED", mrb_fixnum_value(10));

	//----------------------------------------------------------------//
	// Raylib::GamepadButton
	//----------------------------------------------------------------//
	mrb_define_const(mrb, mod_RayLib, "GAMEPAD_BUTTON_UNKNOWN", mrb_fixnum_value(0));
	mrb_define_const(mrb, mod_RayLib, "GAMEPAD_BUTTON_LEFT_FACE_UP", mrb_fixnum_value(1));
	mrb_define_const(mrb, mod_RayLib, "GAMEPAD_BUTTON_LEFT_FACE_RIGHT", mrb_fixnum_value(2));
	mrb_define_const(mrb, mod_RayLib, "GAMEPAD_BUTTON_LEFT_FACE_DOWN", mrb_fixnum_value(3));
	mrb_define_const(mrb, mod_RayLib, "GAMEPAD_BUTTON_LEFT_FACE_LEFT", mrb_fixnum_value(4));
	mrb_define_const(mrb, mod_RayLib, "GAMEPAD_BUTTON_RIGHT_FACE_UP", mrb_fixnum_value(5));
	mrb_define_const(mrb, mod_RayLib, "GAMEPAD_BUTTON_RIGHT_FACE_RIGHT", mrb_fixnum_value(6));
	mrb_define_const(mrb, mod_RayLib, "GAMEPAD_BUTTON_RIGHT_FACE_DOWN", mrb_fixnum_value(7));
	mrb_define_const(mrb, mod_RayLib, "GAMEPAD_BUTTON_RIGHT_FACE_LEFT", mrb_fixnum_value(8));
	mrb_define_const(mrb, mod_RayLib, "GAMEPAD_BUTTON_LEFT_TRIGGER_1", mrb_fixnum_value(9));
	mrb_define_const(mrb, mod_RayLib, "GAMEPAD_BUTTON_LEFT_TRIGGER_2", mrb_fixnum_value(10));
	mrb_define_const(mrb, mod_RayLib, "GAMEPAD_BUTTON_RIGHT_TRIGGER_1", mrb_fixnum_value(11));
	mrb_define_const(mrb, mod_RayLib, "GAMEPAD_BUTTON_RIGHT_TRIGGER_2", mrb_fixnum_value(12));
	mrb_define_const(mrb, mod_RayLib, "GAMEPAD_BUTTON_MIDDLE_LEFT", mrb_fixnum_value(13));
	mrb_define_const(mrb, mod_RayLib, "GAMEPAD_BUTTON_MIDDLE", mrb_fixnum_value(14));
	mrb_define_const(mrb, mod_RayLib, "GAMEPAD_BUTTON_MIDDLE_RIGHT", mrb_fixnum_value(15));
	mrb_define_const(mrb, mod_RayLib, "GAMEPAD_BUTTON_LEFT_THUMB", mrb_fixnum_value(16));
	mrb_define_const(mrb, mod_RayLib, "GAMEPAD_BUTTON_RIGHT_THUMB", mrb_fixnum_value(17));

	struct RClass *mod_RayLib_GamepadButton;
	mod_RayLib_GamepadButton = mrb_define_module_under(mrb, mod_RayLib, "GamepadButton" );
	mrb_define_const(mrb, mod_RayLib_GamepadButton, "GAMEPAD_BUTTON_UNKNOWN", mrb_fixnum_value(0));
	mrb_define_const(mrb, mod_RayLib_GamepadButton, "GAMEPAD_BUTTON_LEFT_FACE_UP", mrb_fixnum_value(1));
	mrb_define_const(mrb, mod_RayLib_GamepadButton, "GAMEPAD_BUTTON_LEFT_FACE_RIGHT", mrb_fixnum_value(2));
	mrb_define_const(mrb, mod_RayLib_GamepadButton, "GAMEPAD_BUTTON_LEFT_FACE_DOWN", mrb_fixnum_value(3));
	mrb_define_const(mrb, mod_RayLib_GamepadButton, "GAMEPAD_BUTTON_LEFT_FACE_LEFT", mrb_fixnum_value(4));
	mrb_define_const(mrb, mod_RayLib_GamepadButton, "GAMEPAD_BUTTON_RIGHT_FACE_UP", mrb_fixnum_value(5));
	mrb_define_const(mrb, mod_RayLib_GamepadButton, "GAMEPAD_BUTTON_RIGHT_FACE_RIGHT", mrb_fixnum_value(6));
	mrb_define_const(mrb, mod_RayLib_GamepadButton, "GAMEPAD_BUTTON_RIGHT_FACE_DOWN", mrb_fixnum_value(7));
	mrb_define_const(mrb, mod_RayLib_GamepadButton, "GAMEPAD_BUTTON_RIGHT_FACE_LEFT", mrb_fixnum_value(8));
	mrb_define_const(mrb, mod_RayLib_GamepadButton, "GAMEPAD_BUTTON_LEFT_TRIGGER_1", mrb_fixnum_value(9));
	mrb_define_const(mrb, mod_RayLib_GamepadButton, "GAMEPAD_BUTTON_LEFT_TRIGGER_2", mrb_fixnum_value(10));
	mrb_define_const(mrb, mod_RayLib_GamepadButton, "GAMEPAD_BUTTON_RIGHT_TRIGGER_1", mrb_fixnum_value(11));
	mrb_define_const(mrb, mod_RayLib_GamepadButton, "GAMEPAD_BUTTON_RIGHT_TRIGGER_2", mrb_fixnum_value(12));
	mrb_define_const(mrb, mod_RayLib_GamepadButton, "GAMEPAD_BUTTON_MIDDLE_LEFT", mrb_fixnum_value(13));
	mrb_define_const(mrb, mod_RayLib_GamepadButton, "GAMEPAD_BUTTON_MIDDLE", mrb_fixnum_value(14));
	mrb_define_const(mrb, mod_RayLib_GamepadButton, "GAMEPAD_BUTTON_MIDDLE_RIGHT", mrb_fixnum_value(15));
	mrb_define_const(mrb, mod_RayLib_GamepadButton, "GAMEPAD_BUTTON_LEFT_THUMB", mrb_fixnum_value(16));
	mrb_define_const(mrb, mod_RayLib_GamepadButton, "GAMEPAD_BUTTON_RIGHT_THUMB", mrb_fixnum_value(17));

	//----------------------------------------------------------------//
	// Raylib::GamepadAxis
	//----------------------------------------------------------------//
	mrb_define_const(mrb, mod_RayLib, "GAMEPAD_AXIS_LEFT_X", mrb_fixnum_value(0));
	mrb_define_const(mrb, mod_RayLib, "GAMEPAD_AXIS_LEFT_Y", mrb_fixnum_value(1));
	mrb_define_const(mrb, mod_RayLib, "GAMEPAD_AXIS_RIGHT_X", mrb_fixnum_value(2));
	mrb_define_const(mrb, mod_RayLib, "GAMEPAD_AXIS_RIGHT_Y", mrb_fixnum_value(3));
	mrb_define_const(mrb, mod_RayLib, "GAMEPAD_AXIS_LEFT_TRIGGER", mrb_fixnum_value(4));
	mrb_define_const(mrb, mod_RayLib, "GAMEPAD_AXIS_RIGHT_TRIGGER", mrb_fixnum_value(5));

	struct RClass *mod_RayLib_GamepadAxis;
	mod_RayLib_GamepadAxis = mrb_define_module_under(mrb, mod_RayLib, "GamepadAxis" );
	mrb_define_const(mrb, mod_RayLib_GamepadAxis, "GAMEPAD_AXIS_LEFT_X", mrb_fixnum_value(0));
	mrb_define_const(mrb, mod_RayLib_GamepadAxis, "GAMEPAD_AXIS_LEFT_Y", mrb_fixnum_value(1));
	mrb_define_const(mrb, mod_RayLib_GamepadAxis, "GAMEPAD_AXIS_RIGHT_X", mrb_fixnum_value(2));
	mrb_define_const(mrb, mod_RayLib_GamepadAxis, "GAMEPAD_AXIS_RIGHT_Y", mrb_fixnum_value(3));
	mrb_define_const(mrb, mod_RayLib_GamepadAxis, "GAMEPAD_AXIS_LEFT_TRIGGER", mrb_fixnum_value(4));
	mrb_define_const(mrb, mod_RayLib_GamepadAxis, "GAMEPAD_AXIS_RIGHT_TRIGGER", mrb_fixnum_value(5));

	//----------------------------------------------------------------//
	// Raylib::MaterialMapIndex
	//----------------------------------------------------------------//
	mrb_define_const(mrb, mod_RayLib, "MATERIAL_MAP_ALBEDO", mrb_fixnum_value(0));
	mrb_define_const(mrb, mod_RayLib, "MATERIAL_MAP_METALNESS", mrb_fixnum_value(1));
	mrb_define_const(mrb, mod_RayLib, "MATERIAL_MAP_NORMAL", mrb_fixnum_value(2));
	mrb_define_const(mrb, mod_RayLib, "MATERIAL_MAP_ROUGHNESS", mrb_fixnum_value(3));
	mrb_define_const(mrb, mod_RayLib, "MATERIAL_MAP_OCCLUSION", mrb_fixnum_value(4));
	mrb_define_const(mrb, mod_RayLib, "MATERIAL_MAP_EMISSION", mrb_fixnum_value(5));
	mrb_define_const(mrb, mod_RayLib, "MATERIAL_MAP_HEIGHT", mrb_fixnum_value(6));
	mrb_define_const(mrb, mod_RayLib, "MATERIAL_MAP_CUBEMAP", mrb_fixnum_value(7));
	mrb_define_const(mrb, mod_RayLib, "MATERIAL_MAP_IRRADIANCE", mrb_fixnum_value(8));
	mrb_define_const(mrb, mod_RayLib, "MATERIAL_MAP_PREFILTER", mrb_fixnum_value(9));
	mrb_define_const(mrb, mod_RayLib, "MATERIAL_MAP_BRDF", mrb_fixnum_value(10));

	struct RClass *mod_RayLib_MaterialMapIndex;
	mod_RayLib_MaterialMapIndex = mrb_define_module_under(mrb, mod_RayLib, "MaterialMapIndex" );
	mrb_define_const(mrb, mod_RayLib_MaterialMapIndex, "MATERIAL_MAP_ALBEDO", mrb_fixnum_value(0));
	mrb_define_const(mrb, mod_RayLib_MaterialMapIndex, "MATERIAL_MAP_METALNESS", mrb_fixnum_value(1));
	mrb_define_const(mrb, mod_RayLib_MaterialMapIndex, "MATERIAL_MAP_NORMAL", mrb_fixnum_value(2));
	mrb_define_const(mrb, mod_RayLib_MaterialMapIndex, "MATERIAL_MAP_ROUGHNESS", mrb_fixnum_value(3));
	mrb_define_const(mrb, mod_RayLib_MaterialMapIndex, "MATERIAL_MAP_OCCLUSION", mrb_fixnum_value(4));
	mrb_define_const(mrb, mod_RayLib_MaterialMapIndex, "MATERIAL_MAP_EMISSION", mrb_fixnum_value(5));
	mrb_define_const(mrb, mod_RayLib_MaterialMapIndex, "MATERIAL_MAP_HEIGHT", mrb_fixnum_value(6));
	mrb_define_const(mrb, mod_RayLib_MaterialMapIndex, "MATERIAL_MAP_CUBEMAP", mrb_fixnum_value(7));
	mrb_define_const(mrb, mod_RayLib_MaterialMapIndex, "MATERIAL_MAP_IRRADIANCE", mrb_fixnum_value(8));
	mrb_define_const(mrb, mod_RayLib_MaterialMapIndex, "MATERIAL_MAP_PREFILTER", mrb_fixnum_value(9));
	mrb_define_const(mrb, mod_RayLib_MaterialMapIndex, "MATERIAL_MAP_BRDF", mrb_fixnum_value(10));

	//----------------------------------------------------------------//
	// Raylib::ShaderLocationIndex
	//----------------------------------------------------------------//
	mrb_define_const(mrb, mod_RayLib, "SHADER_LOC_VERTEX_POSITION", mrb_fixnum_value(0));
	mrb_define_const(mrb, mod_RayLib, "SHADER_LOC_VERTEX_TEXCOORD01", mrb_fixnum_value(1));
	mrb_define_const(mrb, mod_RayLib, "SHADER_LOC_VERTEX_TEXCOORD02", mrb_fixnum_value(2));
	mrb_define_const(mrb, mod_RayLib, "SHADER_LOC_VERTEX_NORMAL", mrb_fixnum_value(3));
	mrb_define_const(mrb, mod_RayLib, "SHADER_LOC_VERTEX_TANGENT", mrb_fixnum_value(4));
	mrb_define_const(mrb, mod_RayLib, "SHADER_LOC_VERTEX_COLOR", mrb_fixnum_value(5));
	mrb_define_const(mrb, mod_RayLib, "SHADER_LOC_MATRIX_MVP", mrb_fixnum_value(6));
	mrb_define_const(mrb, mod_RayLib, "SHADER_LOC_MATRIX_VIEW", mrb_fixnum_value(7));
	mrb_define_const(mrb, mod_RayLib, "SHADER_LOC_MATRIX_PROJECTION", mrb_fixnum_value(8));
	mrb_define_const(mrb, mod_RayLib, "SHADER_LOC_MATRIX_MODEL", mrb_fixnum_value(9));
	mrb_define_const(mrb, mod_RayLib, "SHADER_LOC_MATRIX_NORMAL", mrb_fixnum_value(10));
	mrb_define_const(mrb, mod_RayLib, "SHADER_LOC_VECTOR_VIEW", mrb_fixnum_value(11));
	mrb_define_const(mrb, mod_RayLib, "SHADER_LOC_COLOR_DIFFUSE", mrb_fixnum_value(12));
	mrb_define_const(mrb, mod_RayLib, "SHADER_LOC_COLOR_SPECULAR", mrb_fixnum_value(13));
	mrb_define_const(mrb, mod_RayLib, "SHADER_LOC_COLOR_AMBIENT", mrb_fixnum_value(14));
	mrb_define_const(mrb, mod_RayLib, "SHADER_LOC_MAP_ALBEDO", mrb_fixnum_value(15));
	mrb_define_const(mrb, mod_RayLib, "SHADER_LOC_MAP_METALNESS", mrb_fixnum_value(16));
	mrb_define_const(mrb, mod_RayLib, "SHADER_LOC_MAP_NORMAL", mrb_fixnum_value(17));
	mrb_define_const(mrb, mod_RayLib, "SHADER_LOC_MAP_ROUGHNESS", mrb_fixnum_value(18));
	mrb_define_const(mrb, mod_RayLib, "SHADER_LOC_MAP_OCCLUSION", mrb_fixnum_value(19));
	mrb_define_const(mrb, mod_RayLib, "SHADER_LOC_MAP_EMISSION", mrb_fixnum_value(20));
	mrb_define_const(mrb, mod_RayLib, "SHADER_LOC_MAP_HEIGHT", mrb_fixnum_value(21));
	mrb_define_const(mrb, mod_RayLib, "SHADER_LOC_MAP_CUBEMAP", mrb_fixnum_value(22));
	mrb_define_const(mrb, mod_RayLib, "SHADER_LOC_MAP_IRRADIANCE", mrb_fixnum_value(23));
	mrb_define_const(mrb, mod_RayLib, "SHADER_LOC_MAP_PREFILTER", mrb_fixnum_value(24));
	mrb_define_const(mrb, mod_RayLib, "SHADER_LOC_MAP_BRDF", mrb_fixnum_value(25));

	struct RClass *mod_RayLib_ShaderLocationIndex;
	mod_RayLib_ShaderLocationIndex = mrb_define_module_under(mrb, mod_RayLib, "ShaderLocationIndex" );
	mrb_define_const(mrb, mod_RayLib_ShaderLocationIndex, "SHADER_LOC_VERTEX_POSITION", mrb_fixnum_value(0));
	mrb_define_const(mrb, mod_RayLib_ShaderLocationIndex, "SHADER_LOC_VERTEX_TEXCOORD01", mrb_fixnum_value(1));
	mrb_define_const(mrb, mod_RayLib_ShaderLocationIndex, "SHADER_LOC_VERTEX_TEXCOORD02", mrb_fixnum_value(2));
	mrb_define_const(mrb, mod_RayLib_ShaderLocationIndex, "SHADER_LOC_VERTEX_NORMAL", mrb_fixnum_value(3));
	mrb_define_const(mrb, mod_RayLib_ShaderLocationIndex, "SHADER_LOC_VERTEX_TANGENT", mrb_fixnum_value(4));
	mrb_define_const(mrb, mod_RayLib_ShaderLocationIndex, "SHADER_LOC_VERTEX_COLOR", mrb_fixnum_value(5));
	mrb_define_const(mrb, mod_RayLib_ShaderLocationIndex, "SHADER_LOC_MATRIX_MVP", mrb_fixnum_value(6));
	mrb_define_const(mrb, mod_RayLib_ShaderLocationIndex, "SHADER_LOC_MATRIX_VIEW", mrb_fixnum_value(7));
	mrb_define_const(mrb, mod_RayLib_ShaderLocationIndex, "SHADER_LOC_MATRIX_PROJECTION", mrb_fixnum_value(8));
	mrb_define_const(mrb, mod_RayLib_ShaderLocationIndex, "SHADER_LOC_MATRIX_MODEL", mrb_fixnum_value(9));
	mrb_define_const(mrb, mod_RayLib_ShaderLocationIndex, "SHADER_LOC_MATRIX_NORMAL", mrb_fixnum_value(10));
	mrb_define_const(mrb, mod_RayLib_ShaderLocationIndex, "SHADER_LOC_VECTOR_VIEW", mrb_fixnum_value(11));
	mrb_define_const(mrb, mod_RayLib_ShaderLocationIndex, "SHADER_LOC_COLOR_DIFFUSE", mrb_fixnum_value(12));
	mrb_define_const(mrb, mod_RayLib_ShaderLocationIndex, "SHADER_LOC_COLOR_SPECULAR", mrb_fixnum_value(13));
	mrb_define_const(mrb, mod_RayLib_ShaderLocationIndex, "SHADER_LOC_COLOR_AMBIENT", mrb_fixnum_value(14));
	mrb_define_const(mrb, mod_RayLib_ShaderLocationIndex, "SHADER_LOC_MAP_ALBEDO", mrb_fixnum_value(15));
	mrb_define_const(mrb, mod_RayLib_ShaderLocationIndex, "SHADER_LOC_MAP_METALNESS", mrb_fixnum_value(16));
	mrb_define_const(mrb, mod_RayLib_ShaderLocationIndex, "SHADER_LOC_MAP_NORMAL", mrb_fixnum_value(17));
	mrb_define_const(mrb, mod_RayLib_ShaderLocationIndex, "SHADER_LOC_MAP_ROUGHNESS", mrb_fixnum_value(18));
	mrb_define_const(mrb, mod_RayLib_ShaderLocationIndex, "SHADER_LOC_MAP_OCCLUSION", mrb_fixnum_value(19));
	mrb_define_const(mrb, mod_RayLib_ShaderLocationIndex, "SHADER_LOC_MAP_EMISSION", mrb_fixnum_value(20));
	mrb_define_const(mrb, mod_RayLib_ShaderLocationIndex, "SHADER_LOC_MAP_HEIGHT", mrb_fixnum_value(21));
	mrb_define_const(mrb, mod_RayLib_ShaderLocationIndex, "SHADER_LOC_MAP_CUBEMAP", mrb_fixnum_value(22));
	mrb_define_const(mrb, mod_RayLib_ShaderLocationIndex, "SHADER_LOC_MAP_IRRADIANCE", mrb_fixnum_value(23));
	mrb_define_const(mrb, mod_RayLib_ShaderLocationIndex, "SHADER_LOC_MAP_PREFILTER", mrb_fixnum_value(24));
	mrb_define_const(mrb, mod_RayLib_ShaderLocationIndex, "SHADER_LOC_MAP_BRDF", mrb_fixnum_value(25));

	//----------------------------------------------------------------//
	// Raylib::ShaderUniformDataType
	//----------------------------------------------------------------//
	mrb_define_const(mrb, mod_RayLib, "SHADER_UNIFORM_FLOAT", mrb_fixnum_value(0));
	mrb_define_const(mrb, mod_RayLib, "SHADER_UNIFORM_VEC2", mrb_fixnum_value(1));
	mrb_define_const(mrb, mod_RayLib, "SHADER_UNIFORM_VEC3", mrb_fixnum_value(2));
	mrb_define_const(mrb, mod_RayLib, "SHADER_UNIFORM_VEC4", mrb_fixnum_value(3));
	mrb_define_const(mrb, mod_RayLib, "SHADER_UNIFORM_INT", mrb_fixnum_value(4));
	mrb_define_const(mrb, mod_RayLib, "SHADER_UNIFORM_IVEC2", mrb_fixnum_value(5));
	mrb_define_const(mrb, mod_RayLib, "SHADER_UNIFORM_IVEC3", mrb_fixnum_value(6));
	mrb_define_const(mrb, mod_RayLib, "SHADER_UNIFORM_IVEC4", mrb_fixnum_value(7));
	mrb_define_const(mrb, mod_RayLib, "SHADER_UNIFORM_SAMPLER2D", mrb_fixnum_value(8));

	struct RClass *mod_RayLib_ShaderUniformDataType;
	mod_RayLib_ShaderUniformDataType = mrb_define_module_under(mrb, mod_RayLib, "ShaderUniformDataType" );
	mrb_define_const(mrb, mod_RayLib_ShaderUniformDataType, "SHADER_UNIFORM_FLOAT", mrb_fixnum_value(0));
	mrb_define_const(mrb, mod_RayLib_ShaderUniformDataType, "SHADER_UNIFORM_VEC2", mrb_fixnum_value(1));
	mrb_define_const(mrb, mod_RayLib_ShaderUniformDataType, "SHADER_UNIFORM_VEC3", mrb_fixnum_value(2));
	mrb_define_const(mrb, mod_RayLib_ShaderUniformDataType, "SHADER_UNIFORM_VEC4", mrb_fixnum_value(3));
	mrb_define_const(mrb, mod_RayLib_ShaderUniformDataType, "SHADER_UNIFORM_INT", mrb_fixnum_value(4));
	mrb_define_const(mrb, mod_RayLib_ShaderUniformDataType, "SHADER_UNIFORM_IVEC2", mrb_fixnum_value(5));
	mrb_define_const(mrb, mod_RayLib_ShaderUniformDataType, "SHADER_UNIFORM_IVEC3", mrb_fixnum_value(6));
	mrb_define_const(mrb, mod_RayLib_ShaderUniformDataType, "SHADER_UNIFORM_IVEC4", mrb_fixnum_value(7));
	mrb_define_const(mrb, mod_RayLib_ShaderUniformDataType, "SHADER_UNIFORM_SAMPLER2D", mrb_fixnum_value(8));

	//----------------------------------------------------------------//
	// Raylib::ShaderAttributeDataType
	//----------------------------------------------------------------//
	mrb_define_const(mrb, mod_RayLib, "SHADER_ATTRIB_FLOAT", mrb_fixnum_value(0));
	mrb_define_const(mrb, mod_RayLib, "SHADER_ATTRIB_VEC2", mrb_fixnum_value(1));
	mrb_define_const(mrb, mod_RayLib, "SHADER_ATTRIB_VEC3", mrb_fixnum_value(2));
	mrb_define_const(mrb, mod_RayLib, "SHADER_ATTRIB_VEC4", mrb_fixnum_value(3));

	struct RClass *mod_RayLib_ShaderAttributeDataType;
	mod_RayLib_ShaderAttributeDataType = mrb_define_module_under(mrb, mod_RayLib, "ShaderAttributeDataType" );
	mrb_define_const(mrb, mod_RayLib_ShaderAttributeDataType, "SHADER_ATTRIB_FLOAT", mrb_fixnum_value(0));
	mrb_define_const(mrb, mod_RayLib_ShaderAttributeDataType, "SHADER_ATTRIB_VEC2", mrb_fixnum_value(1));
	mrb_define_const(mrb, mod_RayLib_ShaderAttributeDataType, "SHADER_ATTRIB_VEC3", mrb_fixnum_value(2));
	mrb_define_const(mrb, mod_RayLib_ShaderAttributeDataType, "SHADER_ATTRIB_VEC4", mrb_fixnum_value(3));

	//----------------------------------------------------------------//
	// Raylib::PixelFormat
	//----------------------------------------------------------------//
	mrb_define_const(mrb, mod_RayLib, "PIXELFORMAT_UNCOMPRESSED_GRAYSCALE", mrb_fixnum_value(1));
	mrb_define_const(mrb, mod_RayLib, "PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA", mrb_fixnum_value(2));
	mrb_define_const(mrb, mod_RayLib, "PIXELFORMAT_UNCOMPRESSED_R5G6B5", mrb_fixnum_value(3));
	mrb_define_const(mrb, mod_RayLib, "PIXELFORMAT_UNCOMPRESSED_R8G8B8", mrb_fixnum_value(4));
	mrb_define_const(mrb, mod_RayLib, "PIXELFORMAT_UNCOMPRESSED_R5G5B5A1", mrb_fixnum_value(5));
	mrb_define_const(mrb, mod_RayLib, "PIXELFORMAT_UNCOMPRESSED_R4G4B4A4", mrb_fixnum_value(6));
	mrb_define_const(mrb, mod_RayLib, "PIXELFORMAT_UNCOMPRESSED_R8G8B8A8", mrb_fixnum_value(7));
	mrb_define_const(mrb, mod_RayLib, "PIXELFORMAT_UNCOMPRESSED_R32", mrb_fixnum_value(8));
	mrb_define_const(mrb, mod_RayLib, "PIXELFORMAT_UNCOMPRESSED_R32G32B32", mrb_fixnum_value(9));
	mrb_define_const(mrb, mod_RayLib, "PIXELFORMAT_UNCOMPRESSED_R32G32B32A32", mrb_fixnum_value(10));
	mrb_define_const(mrb, mod_RayLib, "PIXELFORMAT_UNCOMPRESSED_R16", mrb_fixnum_value(11));
	mrb_define_const(mrb, mod_RayLib, "PIXELFORMAT_UNCOMPRESSED_R16G16B16", mrb_fixnum_value(12));
	mrb_define_const(mrb, mod_RayLib, "PIXELFORMAT_UNCOMPRESSED_R16G16B16A16", mrb_fixnum_value(13));
	mrb_define_const(mrb, mod_RayLib, "PIXELFORMAT_COMPRESSED_DXT1_RGB", mrb_fixnum_value(14));
	mrb_define_const(mrb, mod_RayLib, "PIXELFORMAT_COMPRESSED_DXT1_RGBA", mrb_fixnum_value(15));
	mrb_define_const(mrb, mod_RayLib, "PIXELFORMAT_COMPRESSED_DXT3_RGBA", mrb_fixnum_value(16));
	mrb_define_const(mrb, mod_RayLib, "PIXELFORMAT_COMPRESSED_DXT5_RGBA", mrb_fixnum_value(17));
	mrb_define_const(mrb, mod_RayLib, "PIXELFORMAT_COMPRESSED_ETC1_RGB", mrb_fixnum_value(18));
	mrb_define_const(mrb, mod_RayLib, "PIXELFORMAT_COMPRESSED_ETC2_RGB", mrb_fixnum_value(19));
	mrb_define_const(mrb, mod_RayLib, "PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA", mrb_fixnum_value(20));
	mrb_define_const(mrb, mod_RayLib, "PIXELFORMAT_COMPRESSED_PVRT_RGB", mrb_fixnum_value(21));
	mrb_define_const(mrb, mod_RayLib, "PIXELFORMAT_COMPRESSED_PVRT_RGBA", mrb_fixnum_value(22));
	mrb_define_const(mrb, mod_RayLib, "PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA", mrb_fixnum_value(23));
	mrb_define_const(mrb, mod_RayLib, "PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA", mrb_fixnum_value(24));

	struct RClass *mod_RayLib_PixelFormat;
	mod_RayLib_PixelFormat = mrb_define_module_under(mrb, mod_RayLib, "PixelFormat" );
	mrb_define_const(mrb, mod_RayLib_PixelFormat, "PIXELFORMAT_UNCOMPRESSED_GRAYSCALE", mrb_fixnum_value(1));
	mrb_define_const(mrb, mod_RayLib_PixelFormat, "PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA", mrb_fixnum_value(2));
	mrb_define_const(mrb, mod_RayLib_PixelFormat, "PIXELFORMAT_UNCOMPRESSED_R5G6B5", mrb_fixnum_value(3));
	mrb_define_const(mrb, mod_RayLib_PixelFormat, "PIXELFORMAT_UNCOMPRESSED_R8G8B8", mrb_fixnum_value(4));
	mrb_define_const(mrb, mod_RayLib_PixelFormat, "PIXELFORMAT_UNCOMPRESSED_R5G5B5A1", mrb_fixnum_value(5));
	mrb_define_const(mrb, mod_RayLib_PixelFormat, "PIXELFORMAT_UNCOMPRESSED_R4G4B4A4", mrb_fixnum_value(6));
	mrb_define_const(mrb, mod_RayLib_PixelFormat, "PIXELFORMAT_UNCOMPRESSED_R8G8B8A8", mrb_fixnum_value(7));
	mrb_define_const(mrb, mod_RayLib_PixelFormat, "PIXELFORMAT_UNCOMPRESSED_R32", mrb_fixnum_value(8));
	mrb_define_const(mrb, mod_RayLib_PixelFormat, "PIXELFORMAT_UNCOMPRESSED_R32G32B32", mrb_fixnum_value(9));
	mrb_define_const(mrb, mod_RayLib_PixelFormat, "PIXELFORMAT_UNCOMPRESSED_R32G32B32A32", mrb_fixnum_value(10));
	mrb_define_const(mrb, mod_RayLib_PixelFormat, "PIXELFORMAT_UNCOMPRESSED_R16", mrb_fixnum_value(11));
	mrb_define_const(mrb, mod_RayLib_PixelFormat, "PIXELFORMAT_UNCOMPRESSED_R16G16B16", mrb_fixnum_value(12));
	mrb_define_const(mrb, mod_RayLib_PixelFormat, "PIXELFORMAT_UNCOMPRESSED_R16G16B16A16", mrb_fixnum_value(13));
	mrb_define_const(mrb, mod_RayLib_PixelFormat, "PIXELFORMAT_COMPRESSED_DXT1_RGB", mrb_fixnum_value(14));
	mrb_define_const(mrb, mod_RayLib_PixelFormat, "PIXELFORMAT_COMPRESSED_DXT1_RGBA", mrb_fixnum_value(15));
	mrb_define_const(mrb, mod_RayLib_PixelFormat, "PIXELFORMAT_COMPRESSED_DXT3_RGBA", mrb_fixnum_value(16));
	mrb_define_const(mrb, mod_RayLib_PixelFormat, "PIXELFORMAT_COMPRESSED_DXT5_RGBA", mrb_fixnum_value(17));
	mrb_define_const(mrb, mod_RayLib_PixelFormat, "PIXELFORMAT_COMPRESSED_ETC1_RGB", mrb_fixnum_value(18));
	mrb_define_const(mrb, mod_RayLib_PixelFormat, "PIXELFORMAT_COMPRESSED_ETC2_RGB", mrb_fixnum_value(19));
	mrb_define_const(mrb, mod_RayLib_PixelFormat, "PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA", mrb_fixnum_value(20));
	mrb_define_const(mrb, mod_RayLib_PixelFormat, "PIXELFORMAT_COMPRESSED_PVRT_RGB", mrb_fixnum_value(21));
	mrb_define_const(mrb, mod_RayLib_PixelFormat, "PIXELFORMAT_COMPRESSED_PVRT_RGBA", mrb_fixnum_value(22));
	mrb_define_const(mrb, mod_RayLib_PixelFormat, "PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA", mrb_fixnum_value(23));
	mrb_define_const(mrb, mod_RayLib_PixelFormat, "PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA", mrb_fixnum_value(24));

	//----------------------------------------------------------------//
	// Raylib::TextureFilter
	//----------------------------------------------------------------//
	mrb_define_const(mrb, mod_RayLib, "TEXTURE_FILTER_POINT", mrb_fixnum_value(0));
	mrb_define_const(mrb, mod_RayLib, "TEXTURE_FILTER_BILINEAR", mrb_fixnum_value(1));
	mrb_define_const(mrb, mod_RayLib, "TEXTURE_FILTER_TRILINEAR", mrb_fixnum_value(2));
	mrb_define_const(mrb, mod_RayLib, "TEXTURE_FILTER_ANISOTROPIC_4X", mrb_fixnum_value(3));
	mrb_define_const(mrb, mod_RayLib, "TEXTURE_FILTER_ANISOTROPIC_8X", mrb_fixnum_value(4));
	mrb_define_const(mrb, mod_RayLib, "TEXTURE_FILTER_ANISOTROPIC_16X", mrb_fixnum_value(5));

	struct RClass *mod_RayLib_TextureFilter;
	mod_RayLib_TextureFilter = mrb_define_module_under(mrb, mod_RayLib, "TextureFilter" );
	mrb_define_const(mrb, mod_RayLib_TextureFilter, "TEXTURE_FILTER_POINT", mrb_fixnum_value(0));
	mrb_define_const(mrb, mod_RayLib_TextureFilter, "TEXTURE_FILTER_BILINEAR", mrb_fixnum_value(1));
	mrb_define_const(mrb, mod_RayLib_TextureFilter, "TEXTURE_FILTER_TRILINEAR", mrb_fixnum_value(2));
	mrb_define_const(mrb, mod_RayLib_TextureFilter, "TEXTURE_FILTER_ANISOTROPIC_4X", mrb_fixnum_value(3));
	mrb_define_const(mrb, mod_RayLib_TextureFilter, "TEXTURE_FILTER_ANISOTROPIC_8X", mrb_fixnum_value(4));
	mrb_define_const(mrb, mod_RayLib_TextureFilter, "TEXTURE_FILTER_ANISOTROPIC_16X", mrb_fixnum_value(5));

	//----------------------------------------------------------------//
	// Raylib::TextureWrap
	//----------------------------------------------------------------//
	mrb_define_const(mrb, mod_RayLib, "TEXTURE_WRAP_REPEAT", mrb_fixnum_value(0));
	mrb_define_const(mrb, mod_RayLib, "TEXTURE_WRAP_CLAMP", mrb_fixnum_value(1));
	mrb_define_const(mrb, mod_RayLib, "TEXTURE_WRAP_MIRROR_REPEAT", mrb_fixnum_value(2));
	mrb_define_const(mrb, mod_RayLib, "TEXTURE_WRAP_MIRROR_CLAMP", mrb_fixnum_value(3));

	struct RClass *mod_RayLib_TextureWrap;
	mod_RayLib_TextureWrap = mrb_define_module_under(mrb, mod_RayLib, "TextureWrap" );
	mrb_define_const(mrb, mod_RayLib_TextureWrap, "TEXTURE_WRAP_REPEAT", mrb_fixnum_value(0));
	mrb_define_const(mrb, mod_RayLib_TextureWrap, "TEXTURE_WRAP_CLAMP", mrb_fixnum_value(1));
	mrb_define_const(mrb, mod_RayLib_TextureWrap, "TEXTURE_WRAP_MIRROR_REPEAT", mrb_fixnum_value(2));
	mrb_define_const(mrb, mod_RayLib_TextureWrap, "TEXTURE_WRAP_MIRROR_CLAMP", mrb_fixnum_value(3));

	//----------------------------------------------------------------//
	// Raylib::CubemapLayout
	//----------------------------------------------------------------//
	mrb_define_const(mrb, mod_RayLib, "CUBEMAP_LAYOUT_AUTO_DETECT", mrb_fixnum_value(0));
	mrb_define_const(mrb, mod_RayLib, "CUBEMAP_LAYOUT_LINE_VERTICAL", mrb_fixnum_value(1));
	mrb_define_const(mrb, mod_RayLib, "CUBEMAP_LAYOUT_LINE_HORIZONTAL", mrb_fixnum_value(2));
	mrb_define_const(mrb, mod_RayLib, "CUBEMAP_LAYOUT_CROSS_THREE_BY_FOUR", mrb_fixnum_value(3));
	mrb_define_const(mrb, mod_RayLib, "CUBEMAP_LAYOUT_CROSS_FOUR_BY_THREE", mrb_fixnum_value(4));
	mrb_define_const(mrb, mod_RayLib, "CUBEMAP_LAYOUT_PANORAMA", mrb_fixnum_value(5));

	struct RClass *mod_RayLib_CubemapLayout;
	mod_RayLib_CubemapLayout = mrb_define_module_under(mrb, mod_RayLib, "CubemapLayout" );
	mrb_define_const(mrb, mod_RayLib_CubemapLayout, "CUBEMAP_LAYOUT_AUTO_DETECT", mrb_fixnum_value(0));
	mrb_define_const(mrb, mod_RayLib_CubemapLayout, "CUBEMAP_LAYOUT_LINE_VERTICAL", mrb_fixnum_value(1));
	mrb_define_const(mrb, mod_RayLib_CubemapLayout, "CUBEMAP_LAYOUT_LINE_HORIZONTAL", mrb_fixnum_value(2));
	mrb_define_const(mrb, mod_RayLib_CubemapLayout, "CUBEMAP_LAYOUT_CROSS_THREE_BY_FOUR", mrb_fixnum_value(3));
	mrb_define_const(mrb, mod_RayLib_CubemapLayout, "CUBEMAP_LAYOUT_CROSS_FOUR_BY_THREE", mrb_fixnum_value(4));
	mrb_define_const(mrb, mod_RayLib_CubemapLayout, "CUBEMAP_LAYOUT_PANORAMA", mrb_fixnum_value(5));

	//----------------------------------------------------------------//
	// Raylib::FontType
	//----------------------------------------------------------------//
	mrb_define_const(mrb, mod_RayLib, "FONT_DEFAULT", mrb_fixnum_value(0));
	mrb_define_const(mrb, mod_RayLib, "FONT_BITMAP", mrb_fixnum_value(1));
	mrb_define_const(mrb, mod_RayLib, "FONT_SDF", mrb_fixnum_value(2));

	struct RClass *mod_RayLib_FontType;
	mod_RayLib_FontType = mrb_define_module_under(mrb, mod_RayLib, "FontType" );
	mrb_define_const(mrb, mod_RayLib_FontType, "FONT_DEFAULT", mrb_fixnum_value(0));
	mrb_define_const(mrb, mod_RayLib_FontType, "FONT_BITMAP", mrb_fixnum_value(1));
	mrb_define_const(mrb, mod_RayLib_FontType, "FONT_SDF", mrb_fixnum_value(2));

	//----------------------------------------------------------------//
	// Raylib::BlendMode
	//----------------------------------------------------------------//
	mrb_define_const(mrb, mod_RayLib, "BLEND_ALPHA", mrb_fixnum_value(0));
	mrb_define_const(mrb, mod_RayLib, "BLEND_ADDITIVE", mrb_fixnum_value(1));
	mrb_define_const(mrb, mod_RayLib, "BLEND_MULTIPLIED", mrb_fixnum_value(2));
	mrb_define_const(mrb, mod_RayLib, "BLEND_ADD_COLORS", mrb_fixnum_value(3));
	mrb_define_const(mrb, mod_RayLib, "BLEND_SUBTRACT_COLORS", mrb_fixnum_value(4));
	mrb_define_const(mrb, mod_RayLib, "BLEND_ALPHA_PREMULTIPLY", mrb_fixnum_value(5));
	mrb_define_const(mrb, mod_RayLib, "BLEND_CUSTOM", mrb_fixnum_value(6));
	mrb_define_const(mrb, mod_RayLib, "BLEND_CUSTOM_SEPARATE", mrb_fixnum_value(7));

	struct RClass *mod_RayLib_BlendMode;
	mod_RayLib_BlendMode = mrb_define_module_under(mrb, mod_RayLib, "BlendMode" );
	mrb_define_const(mrb, mod_RayLib_BlendMode, "BLEND_ALPHA", mrb_fixnum_value(0));
	mrb_define_const(mrb, mod_RayLib_BlendMode, "BLEND_ADDITIVE", mrb_fixnum_value(1));
	mrb_define_const(mrb, mod_RayLib_BlendMode, "BLEND_MULTIPLIED", mrb_fixnum_value(2));
	mrb_define_const(mrb, mod_RayLib_BlendMode, "BLEND_ADD_COLORS", mrb_fixnum_value(3));
	mrb_define_const(mrb, mod_RayLib_BlendMode, "BLEND_SUBTRACT_COLORS", mrb_fixnum_value(4));
	mrb_define_const(mrb, mod_RayLib_BlendMode, "BLEND_ALPHA_PREMULTIPLY", mrb_fixnum_value(5));
	mrb_define_const(mrb, mod_RayLib_BlendMode, "BLEND_CUSTOM", mrb_fixnum_value(6));
	mrb_define_const(mrb, mod_RayLib_BlendMode, "BLEND_CUSTOM_SEPARATE", mrb_fixnum_value(7));

	//----------------------------------------------------------------//
	// Raylib::Gesture
	//----------------------------------------------------------------//
	mrb_define_const(mrb, mod_RayLib, "GESTURE_NONE", mrb_fixnum_value(0));
	mrb_define_const(mrb, mod_RayLib, "GESTURE_TAP", mrb_fixnum_value(1));
	mrb_define_const(mrb, mod_RayLib, "GESTURE_DOUBLETAP", mrb_fixnum_value(2));
	mrb_define_const(mrb, mod_RayLib, "GESTURE_HOLD", mrb_fixnum_value(4));
	mrb_define_const(mrb, mod_RayLib, "GESTURE_DRAG", mrb_fixnum_value(8));
	mrb_define_const(mrb, mod_RayLib, "GESTURE_SWIPE_RIGHT", mrb_fixnum_value(16));
	mrb_define_const(mrb, mod_RayLib, "GESTURE_SWIPE_LEFT", mrb_fixnum_value(32));
	mrb_define_const(mrb, mod_RayLib, "GESTURE_SWIPE_UP", mrb_fixnum_value(64));
	mrb_define_const(mrb, mod_RayLib, "GESTURE_SWIPE_DOWN", mrb_fixnum_value(128));
	mrb_define_const(mrb, mod_RayLib, "GESTURE_PINCH_IN", mrb_fixnum_value(256));
	mrb_define_const(mrb, mod_RayLib, "GESTURE_PINCH_OUT", mrb_fixnum_value(512));

	struct RClass *mod_RayLib_Gesture;
	mod_RayLib_Gesture = mrb_define_module_under(mrb, mod_RayLib, "Gesture" );
	mrb_define_const(mrb, mod_RayLib_Gesture, "GESTURE_NONE", mrb_fixnum_value(0));
	mrb_define_const(mrb, mod_RayLib_Gesture, "GESTURE_TAP", mrb_fixnum_value(1));
	mrb_define_const(mrb, mod_RayLib_Gesture, "GESTURE_DOUBLETAP", mrb_fixnum_value(2));
	mrb_define_const(mrb, mod_RayLib_Gesture, "GESTURE_HOLD", mrb_fixnum_value(4));
	mrb_define_const(mrb, mod_RayLib_Gesture, "GESTURE_DRAG", mrb_fixnum_value(8));
	mrb_define_const(mrb, mod_RayLib_Gesture, "GESTURE_SWIPE_RIGHT", mrb_fixnum_value(16));
	mrb_define_const(mrb, mod_RayLib_Gesture, "GESTURE_SWIPE_LEFT", mrb_fixnum_value(32));
	mrb_define_const(mrb, mod_RayLib_Gesture, "GESTURE_SWIPE_UP", mrb_fixnum_value(64));
	mrb_define_const(mrb, mod_RayLib_Gesture, "GESTURE_SWIPE_DOWN", mrb_fixnum_value(128));
	mrb_define_const(mrb, mod_RayLib_Gesture, "GESTURE_PINCH_IN", mrb_fixnum_value(256));
	mrb_define_const(mrb, mod_RayLib_Gesture, "GESTURE_PINCH_OUT", mrb_fixnum_value(512));

	//----------------------------------------------------------------//
	// Raylib::CameraMode
	//----------------------------------------------------------------//
	mrb_define_const(mrb, mod_RayLib, "CAMERA_CUSTOM", mrb_fixnum_value(0));
	mrb_define_const(mrb, mod_RayLib, "CAMERA_FREE", mrb_fixnum_value(1));
	mrb_define_const(mrb, mod_RayLib, "CAMERA_ORBITAL", mrb_fixnum_value(2));
	mrb_define_const(mrb, mod_RayLib, "CAMERA_FIRST_PERSON", mrb_fixnum_value(3));
	mrb_define_const(mrb, mod_RayLib, "CAMERA_THIRD_PERSON", mrb_fixnum_value(4));

	struct RClass *mod_RayLib_CameraMode;
	mod_RayLib_CameraMode = mrb_define_module_under(mrb, mod_RayLib, "CameraMode" );
	mrb_define_const(mrb, mod_RayLib_CameraMode, "CAMERA_CUSTOM", mrb_fixnum_value(0));
	mrb_define_const(mrb, mod_RayLib_CameraMode, "CAMERA_FREE", mrb_fixnum_value(1));
	mrb_define_const(mrb, mod_RayLib_CameraMode, "CAMERA_ORBITAL", mrb_fixnum_value(2));
	mrb_define_const(mrb, mod_RayLib_CameraMode, "CAMERA_FIRST_PERSON", mrb_fixnum_value(3));
	mrb_define_const(mrb, mod_RayLib_CameraMode, "CAMERA_THIRD_PERSON", mrb_fixnum_value(4));

	//----------------------------------------------------------------//
	// Raylib::CameraProjection
	//----------------------------------------------------------------//
	mrb_define_const(mrb, mod_RayLib, "CAMERA_PERSPECTIVE", mrb_fixnum_value(0));
	mrb_define_const(mrb, mod_RayLib, "CAMERA_ORTHOGRAPHIC", mrb_fixnum_value(1));

	struct RClass *mod_RayLib_CameraProjection;
	mod_RayLib_CameraProjection = mrb_define_module_under(mrb, mod_RayLib, "CameraProjection" );
	mrb_define_const(mrb, mod_RayLib_CameraProjection, "CAMERA_PERSPECTIVE", mrb_fixnum_value(0));
	mrb_define_const(mrb, mod_RayLib_CameraProjection, "CAMERA_ORTHOGRAPHIC", mrb_fixnum_value(1));

	//----------------------------------------------------------------//
	// Raylib::NPatchLayout
	//----------------------------------------------------------------//
	mrb_define_const(mrb, mod_RayLib, "NPATCH_NINE_PATCH", mrb_fixnum_value(0));
	mrb_define_const(mrb, mod_RayLib, "NPATCH_THREE_PATCH_VERTICAL", mrb_fixnum_value(1));
	mrb_define_const(mrb, mod_RayLib, "NPATCH_THREE_PATCH_HORIZONTAL", mrb_fixnum_value(2));

	struct RClass *mod_RayLib_NPatchLayout;
	mod_RayLib_NPatchLayout = mrb_define_module_under(mrb, mod_RayLib, "NPatchLayout" );
	mrb_define_const(mrb, mod_RayLib_NPatchLayout, "NPATCH_NINE_PATCH", mrb_fixnum_value(0));
	mrb_define_const(mrb, mod_RayLib_NPatchLayout, "NPATCH_THREE_PATCH_VERTICAL", mrb_fixnum_value(1));
	mrb_define_const(mrb, mod_RayLib_NPatchLayout, "NPATCH_THREE_PATCH_HORIZONTAL", mrb_fixnum_value(2));

	mrb_gc_arena_restore(mrb, arena_size);

	//----------------------------------------------------------------//
	// module: Vector2
	//----------------------------------------------------------------//
	class_raylib_vector2_init( mrb, mod_RayLib );

	//----------------------------------------------------------------//
	// module: Vector3
	//----------------------------------------------------------------//
	class_raylib_vector3_init( mrb, mod_RayLib );

	//----------------------------------------------------------------//
	// module: Vector4
	//----------------------------------------------------------------//
	class_raylib_vector4_init( mrb, mod_RayLib );

	//----------------------------------------------------------------//
	// module: Matrix
	//----------------------------------------------------------------//
	class_raylib_matrix_init( mrb, mod_RayLib );

	//----------------------------------------------------------------//
	// module: Color
	//----------------------------------------------------------------//
	class_raylib_color_init( mrb, mod_RayLib );

	//----------------------------------------------------------------//
	// module: Rectangle
	//----------------------------------------------------------------//
	class_raylib_rectangle_init( mrb, mod_RayLib );

	//----------------------------------------------------------------//
	// module: Image
	//----------------------------------------------------------------//
	class_raylib_image_init( mrb, mod_RayLib );

	//----------------------------------------------------------------//
	// module: Texture
	//----------------------------------------------------------------//
	class_raylib_texture_init( mrb, mod_RayLib );

	//----------------------------------------------------------------//
	// module: RenderTexture
	//----------------------------------------------------------------//
	class_raylib_rendertexture_init( mrb, mod_RayLib );

	//----------------------------------------------------------------//
	// module: NPatchInfo
	//----------------------------------------------------------------//
	class_raylib_npatchinfo_init( mrb, mod_RayLib );

	//----------------------------------------------------------------//
	// module: GlyphInfo
	//----------------------------------------------------------------//
	class_raylib_glyphinfo_init( mrb, mod_RayLib );

	//----------------------------------------------------------------//
	// module: Font
	//----------------------------------------------------------------//
	class_raylib_font_init( mrb, mod_RayLib );

	//----------------------------------------------------------------//
	// module: Camera3D
	//----------------------------------------------------------------//
	class_raylib_camera3d_init( mrb, mod_RayLib );

	//----------------------------------------------------------------//
	// module: Camera2D
	//----------------------------------------------------------------//
	class_raylib_camera2d_init( mrb, mod_RayLib );

	//----------------------------------------------------------------//
	// module: Mesh
	//----------------------------------------------------------------//
	class_raylib_mesh_init( mrb, mod_RayLib );

	//----------------------------------------------------------------//
	// module: Shader
	//----------------------------------------------------------------//
	class_raylib_shader_init( mrb, mod_RayLib );

	//----------------------------------------------------------------//
	// module: MaterialMap
	//----------------------------------------------------------------//
	class_raylib_materialmap_init( mrb, mod_RayLib );

	//----------------------------------------------------------------//
	// module: Material
	//----------------------------------------------------------------//
	class_raylib_material_init( mrb, mod_RayLib );

	//----------------------------------------------------------------//
	// module: Transform
	//----------------------------------------------------------------//
	class_raylib_transform_init( mrb, mod_RayLib );

	//----------------------------------------------------------------//
	// module: BoneInfo
	//----------------------------------------------------------------//
	class_raylib_boneinfo_init( mrb, mod_RayLib );

	//----------------------------------------------------------------//
	// module: Model
	//----------------------------------------------------------------//
	class_raylib_model_init( mrb, mod_RayLib );

	//----------------------------------------------------------------//
	// module: ModelAnimation
	//----------------------------------------------------------------//
	class_raylib_modelanimation_init( mrb, mod_RayLib );

	//----------------------------------------------------------------//
	// module: Ray
	//----------------------------------------------------------------//
	class_raylib_ray_init( mrb, mod_RayLib );

	//----------------------------------------------------------------//
	// module: RayCollision
	//----------------------------------------------------------------//
	class_raylib_raycollision_init( mrb, mod_RayLib );

	//----------------------------------------------------------------//
	// module: BoundingBox
	//----------------------------------------------------------------//
	class_raylib_boundingbox_init( mrb, mod_RayLib );

	//----------------------------------------------------------------//
	// module: Wave
	//----------------------------------------------------------------//
	class_raylib_wave_init( mrb, mod_RayLib );

	//----------------------------------------------------------------//
	// module: rAudioBuffer
	//----------------------------------------------------------------//
	class_raylib_raudiobuffer_init( mrb, mod_RayLib );

	//----------------------------------------------------------------//
	// module: rAudioProcessor
	//----------------------------------------------------------------//
	class_raylib_raudioprocessor_init( mrb, mod_RayLib );

	//----------------------------------------------------------------//
	// module: AudioStream
	//----------------------------------------------------------------//
	class_raylib_audiostream_init( mrb, mod_RayLib );

	//----------------------------------------------------------------//
	// module: Sound
	//----------------------------------------------------------------//
	class_raylib_sound_init( mrb, mod_RayLib );

	//----------------------------------------------------------------//
	// module: Music
	//----------------------------------------------------------------//
	class_raylib_music_init( mrb, mod_RayLib );

	//----------------------------------------------------------------//
	// module: VrDeviceInfo
	//----------------------------------------------------------------//
	class_raylib_vrdeviceinfo_init( mrb, mod_RayLib );

	//----------------------------------------------------------------//
	// module: VrStereoConfig
	//----------------------------------------------------------------//
	class_raylib_vrstereoconfig_init( mrb, mod_RayLib );

	//----------------------------------------------------------------//
	// module: FilePathList
	//----------------------------------------------------------------//
	class_raylib_filepathlist_init( mrb, mod_RayLib );

	//----------------------------------------------------------------//
	// module: AutomationEvent
	//----------------------------------------------------------------//
	class_raylib_automationevent_init( mrb, mod_RayLib );

	//----------------------------------------------------------------//
	// module: AutomationEventList
	//----------------------------------------------------------------//
	class_raylib_automationeventlist_init( mrb, mod_RayLib );


	mrb_define_module_function( mrb, mod_RayLib, "init_window", mod_raylib_init_window, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "close_window", mod_raylib_close_window, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "window_should_close", mod_raylib_window_should_close, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "is_window_ready", mod_raylib_is_window_ready, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "is_window_fullscreen", mod_raylib_is_window_fullscreen, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "is_window_hidden", mod_raylib_is_window_hidden, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "is_window_minimized", mod_raylib_is_window_minimized, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "is_window_maximized", mod_raylib_is_window_maximized, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "is_window_focused", mod_raylib_is_window_focused, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "is_window_resized", mod_raylib_is_window_resized, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "is_window_state", mod_raylib_is_window_state, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "set_window_state", mod_raylib_set_window_state, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "clear_window_state", mod_raylib_clear_window_state, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "toggle_fullscreen", mod_raylib_toggle_fullscreen, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "toggle_borderless_windowed", mod_raylib_toggle_borderless_windowed, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "maximize_window", mod_raylib_maximize_window, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "minimize_window", mod_raylib_minimize_window, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "restore_window", mod_raylib_restore_window, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "set_window_icon", mod_raylib_set_window_icon, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "set_window_icons", mod_raylib_set_window_icons, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "set_window_title", mod_raylib_set_window_title, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "set_window_position", mod_raylib_set_window_position, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "set_window_monitor", mod_raylib_set_window_monitor, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "set_window_min_size", mod_raylib_set_window_min_size, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "set_window_max_size", mod_raylib_set_window_max_size, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "set_window_size", mod_raylib_set_window_size, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "set_window_opacity", mod_raylib_set_window_opacity, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "set_window_focused", mod_raylib_set_window_focused, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "get_window_handle", mod_raylib_get_window_handle, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "get_screen_width", mod_raylib_get_screen_width, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "get_screen_height", mod_raylib_get_screen_height, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "get_render_width", mod_raylib_get_render_width, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "get_render_height", mod_raylib_get_render_height, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "get_monitor_count", mod_raylib_get_monitor_count, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "get_current_monitor", mod_raylib_get_current_monitor, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "get_monitor_position", mod_raylib_get_monitor_position, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "get_monitor_width", mod_raylib_get_monitor_width, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "get_monitor_height", mod_raylib_get_monitor_height, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "get_monitor_physical_width", mod_raylib_get_monitor_physical_width, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "get_monitor_physical_height", mod_raylib_get_monitor_physical_height, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "get_monitor_refresh_rate", mod_raylib_get_monitor_refresh_rate, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "get_window_position", mod_raylib_get_window_position, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "get_window_scale_dpi", mod_raylib_get_window_scale_dpi, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "get_monitor_name", mod_raylib_get_monitor_name, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "set_clipboard_text", mod_raylib_set_clipboard_text, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "get_clipboard_text", mod_raylib_get_clipboard_text, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "enable_event_waiting", mod_raylib_enable_event_waiting, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "disable_event_waiting", mod_raylib_disable_event_waiting, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "show_cursor", mod_raylib_show_cursor, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "hide_cursor", mod_raylib_hide_cursor, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "is_cursor_hidden", mod_raylib_is_cursor_hidden, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "enable_cursor", mod_raylib_enable_cursor, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "disable_cursor", mod_raylib_disable_cursor, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "is_cursor_on_screen", mod_raylib_is_cursor_on_screen, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "clear_background", mod_raylib_clear_background, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "begin_drawing", mod_raylib_begin_drawing, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "end_drawing", mod_raylib_end_drawing, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "begin_mode2_d", mod_raylib_begin_mode2_d, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "end_mode2_d", mod_raylib_end_mode2_d, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "begin_mode3_d", mod_raylib_begin_mode3_d, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "end_mode3_d", mod_raylib_end_mode3_d, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "begin_texture_mode", mod_raylib_begin_texture_mode, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "end_texture_mode", mod_raylib_end_texture_mode, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "begin_shader_mode", mod_raylib_begin_shader_mode, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "end_shader_mode", mod_raylib_end_shader_mode, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "begin_blend_mode", mod_raylib_begin_blend_mode, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "end_blend_mode", mod_raylib_end_blend_mode, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "begin_scissor_mode", mod_raylib_begin_scissor_mode, MRB_ARGS_REQ( 4 ) );
	mrb_define_module_function( mrb, mod_RayLib, "end_scissor_mode", mod_raylib_end_scissor_mode, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "begin_vr_stereo_mode", mod_raylib_begin_vr_stereo_mode, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "end_vr_stereo_mode", mod_raylib_end_vr_stereo_mode, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "load_vr_stereo_config", mod_raylib_load_vr_stereo_config, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "unload_vr_stereo_config", mod_raylib_unload_vr_stereo_config, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "load_shader", mod_raylib_load_shader, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "load_shader_from_memory", mod_raylib_load_shader_from_memory, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "is_shader_ready", mod_raylib_is_shader_ready, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "get_shader_location", mod_raylib_get_shader_location, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "get_shader_location_attrib", mod_raylib_get_shader_location_attrib, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "set_shader_value", mod_raylib_set_shader_value, MRB_ARGS_REQ( 4 ) );
	mrb_define_module_function( mrb, mod_RayLib, "set_shader_value_v", mod_raylib_set_shader_value_v, MRB_ARGS_REQ( 5 ) );
	mrb_define_module_function( mrb, mod_RayLib, "set_shader_value_matrix", mod_raylib_set_shader_value_matrix, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "set_shader_value_texture", mod_raylib_set_shader_value_texture, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "unload_shader", mod_raylib_unload_shader, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "get_mouse_ray", mod_raylib_get_mouse_ray, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "get_camera_matrix", mod_raylib_get_camera_matrix, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "get_camera_matrix2_d", mod_raylib_get_camera_matrix2_d, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "get_world_to_screen", mod_raylib_get_world_to_screen, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "get_screen_to_world2_d", mod_raylib_get_screen_to_world2_d, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "get_world_to_screen_ex", mod_raylib_get_world_to_screen_ex, MRB_ARGS_REQ( 4 ) );
	mrb_define_module_function( mrb, mod_RayLib, "get_world_to_screen2_d", mod_raylib_get_world_to_screen2_d, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "set_target_fps", mod_raylib_set_target_fps, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "get_frame_time", mod_raylib_get_frame_time, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "get_time", mod_raylib_get_time, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "get_fps", mod_raylib_get_fps, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "swap_screen_buffer", mod_raylib_swap_screen_buffer, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "poll_input_events", mod_raylib_poll_input_events, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "wait_time", mod_raylib_wait_time, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "set_random_seed", mod_raylib_set_random_seed, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "get_random_value", mod_raylib_get_random_value, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "load_random_sequence", mod_raylib_load_random_sequence, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "unload_random_sequence", mod_raylib_unload_random_sequence, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "take_screenshot", mod_raylib_take_screenshot, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "set_config_flags", mod_raylib_set_config_flags, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "open_url", mod_raylib_open_url, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "trace_log", mod_raylib_trace_log, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "set_trace_log_level", mod_raylib_set_trace_log_level, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "mem_alloc", mod_raylib_mem_alloc, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "mem_realloc", mod_raylib_mem_realloc, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "mem_free", mod_raylib_mem_free, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "set_trace_log_callback", mod_raylib_set_trace_log_callback, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "set_load_file_data_callback", mod_raylib_set_load_file_data_callback, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "set_save_file_data_callback", mod_raylib_set_save_file_data_callback, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "set_load_file_text_callback", mod_raylib_set_load_file_text_callback, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "set_save_file_text_callback", mod_raylib_set_save_file_text_callback, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "load_file_data", mod_raylib_load_file_data, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "unload_file_data", mod_raylib_unload_file_data, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "save_file_data", mod_raylib_save_file_data, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "export_data_as_code", mod_raylib_export_data_as_code, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "load_file_text", mod_raylib_load_file_text, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "unload_file_text", mod_raylib_unload_file_text, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "save_file_text", mod_raylib_save_file_text, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "file_exists", mod_raylib_file_exists, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "directory_exists", mod_raylib_directory_exists, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "is_file_extension", mod_raylib_is_file_extension, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "get_file_length", mod_raylib_get_file_length, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "get_file_extension", mod_raylib_get_file_extension, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "get_file_name", mod_raylib_get_file_name, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "get_file_name_without_ext", mod_raylib_get_file_name_without_ext, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "get_directory_path", mod_raylib_get_directory_path, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "get_prev_directory_path", mod_raylib_get_prev_directory_path, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "get_working_directory", mod_raylib_get_working_directory, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "get_application_directory", mod_raylib_get_application_directory, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "change_directory", mod_raylib_change_directory, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "is_path_file", mod_raylib_is_path_file, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "load_directory_files", mod_raylib_load_directory_files, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "load_directory_files_ex", mod_raylib_load_directory_files_ex, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "unload_directory_files", mod_raylib_unload_directory_files, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "is_file_dropped", mod_raylib_is_file_dropped, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "load_dropped_files", mod_raylib_load_dropped_files, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "unload_dropped_files", mod_raylib_unload_dropped_files, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "get_file_mod_time", mod_raylib_get_file_mod_time, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "compress_data", mod_raylib_compress_data, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "decompress_data", mod_raylib_decompress_data, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "encode_data_base64", mod_raylib_encode_data_base64, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "decode_data_base64", mod_raylib_decode_data_base64, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "load_automation_event_list", mod_raylib_load_automation_event_list, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "unload_automation_event_list", mod_raylib_unload_automation_event_list, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "export_automation_event_list", mod_raylib_export_automation_event_list, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "set_automation_event_list", mod_raylib_set_automation_event_list, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "set_automation_event_base_frame", mod_raylib_set_automation_event_base_frame, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "start_automation_event_recording", mod_raylib_start_automation_event_recording, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "stop_automation_event_recording", mod_raylib_stop_automation_event_recording, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "play_automation_event", mod_raylib_play_automation_event, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "is_key_pressed", mod_raylib_is_key_pressed, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "is_key_pressed_repeat", mod_raylib_is_key_pressed_repeat, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "is_key_down", mod_raylib_is_key_down, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "is_key_released", mod_raylib_is_key_released, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "is_key_up", mod_raylib_is_key_up, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "get_key_pressed", mod_raylib_get_key_pressed, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "get_char_pressed", mod_raylib_get_char_pressed, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "set_exit_key", mod_raylib_set_exit_key, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "is_gamepad_available", mod_raylib_is_gamepad_available, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "get_gamepad_name", mod_raylib_get_gamepad_name, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "is_gamepad_button_pressed", mod_raylib_is_gamepad_button_pressed, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "is_gamepad_button_down", mod_raylib_is_gamepad_button_down, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "is_gamepad_button_released", mod_raylib_is_gamepad_button_released, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "is_gamepad_button_up", mod_raylib_is_gamepad_button_up, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "get_gamepad_button_pressed", mod_raylib_get_gamepad_button_pressed, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "get_gamepad_axis_count", mod_raylib_get_gamepad_axis_count, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "get_gamepad_axis_movement", mod_raylib_get_gamepad_axis_movement, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "set_gamepad_mappings", mod_raylib_set_gamepad_mappings, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "is_mouse_button_pressed", mod_raylib_is_mouse_button_pressed, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "is_mouse_button_down", mod_raylib_is_mouse_button_down, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "is_mouse_button_released", mod_raylib_is_mouse_button_released, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "is_mouse_button_up", mod_raylib_is_mouse_button_up, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "get_mouse_x", mod_raylib_get_mouse_x, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "get_mouse_y", mod_raylib_get_mouse_y, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "get_mouse_position", mod_raylib_get_mouse_position, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "get_mouse_delta", mod_raylib_get_mouse_delta, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "set_mouse_position", mod_raylib_set_mouse_position, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "set_mouse_offset", mod_raylib_set_mouse_offset, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "set_mouse_scale", mod_raylib_set_mouse_scale, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "get_mouse_wheel_move", mod_raylib_get_mouse_wheel_move, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "get_mouse_wheel_move_v", mod_raylib_get_mouse_wheel_move_v, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "set_mouse_cursor", mod_raylib_set_mouse_cursor, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "get_touch_x", mod_raylib_get_touch_x, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "get_touch_y", mod_raylib_get_touch_y, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "get_touch_position", mod_raylib_get_touch_position, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "get_touch_point_id", mod_raylib_get_touch_point_id, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "get_touch_point_count", mod_raylib_get_touch_point_count, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "set_gestures_enabled", mod_raylib_set_gestures_enabled, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "is_gesture_detected", mod_raylib_is_gesture_detected, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "get_gesture_detected", mod_raylib_get_gesture_detected, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "get_gesture_hold_duration", mod_raylib_get_gesture_hold_duration, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "get_gesture_drag_vector", mod_raylib_get_gesture_drag_vector, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "get_gesture_drag_angle", mod_raylib_get_gesture_drag_angle, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "get_gesture_pinch_vector", mod_raylib_get_gesture_pinch_vector, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "get_gesture_pinch_angle", mod_raylib_get_gesture_pinch_angle, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "update_camera", mod_raylib_update_camera, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "update_camera_pro", mod_raylib_update_camera_pro, MRB_ARGS_REQ( 4 ) );
	mrb_define_module_function( mrb, mod_RayLib, "set_shapes_texture", mod_raylib_set_shapes_texture, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_pixel", mod_raylib_draw_pixel, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_pixel_v", mod_raylib_draw_pixel_v, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_line", mod_raylib_draw_line, MRB_ARGS_REQ( 5 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_line_v", mod_raylib_draw_line_v, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_line_ex", mod_raylib_draw_line_ex, MRB_ARGS_REQ( 4 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_line_strip", mod_raylib_draw_line_strip, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_line_bezier", mod_raylib_draw_line_bezier, MRB_ARGS_REQ( 4 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_circle", mod_raylib_draw_circle, MRB_ARGS_REQ( 4 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_circle_sector", mod_raylib_draw_circle_sector, MRB_ARGS_REQ( 6 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_circle_sector_lines", mod_raylib_draw_circle_sector_lines, MRB_ARGS_REQ( 6 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_circle_gradient", mod_raylib_draw_circle_gradient, MRB_ARGS_REQ( 5 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_circle_v", mod_raylib_draw_circle_v, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_circle_lines", mod_raylib_draw_circle_lines, MRB_ARGS_REQ( 4 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_circle_lines_v", mod_raylib_draw_circle_lines_v, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_ellipse", mod_raylib_draw_ellipse, MRB_ARGS_REQ( 5 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_ellipse_lines", mod_raylib_draw_ellipse_lines, MRB_ARGS_REQ( 5 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_ring", mod_raylib_draw_ring, MRB_ARGS_REQ( 7 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_ring_lines", mod_raylib_draw_ring_lines, MRB_ARGS_REQ( 7 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_rectangle", mod_raylib_draw_rectangle, MRB_ARGS_REQ( 5 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_rectangle_v", mod_raylib_draw_rectangle_v, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_rectangle_rec", mod_raylib_draw_rectangle_rec, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_rectangle_pro", mod_raylib_draw_rectangle_pro, MRB_ARGS_REQ( 4 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_rectangle_gradient_v", mod_raylib_draw_rectangle_gradient_v, MRB_ARGS_REQ( 6 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_rectangle_gradient_h", mod_raylib_draw_rectangle_gradient_h, MRB_ARGS_REQ( 6 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_rectangle_gradient_ex", mod_raylib_draw_rectangle_gradient_ex, MRB_ARGS_REQ( 5 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_rectangle_lines", mod_raylib_draw_rectangle_lines, MRB_ARGS_REQ( 5 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_rectangle_lines_ex", mod_raylib_draw_rectangle_lines_ex, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_rectangle_rounded", mod_raylib_draw_rectangle_rounded, MRB_ARGS_REQ( 4 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_rectangle_rounded_lines", mod_raylib_draw_rectangle_rounded_lines, MRB_ARGS_REQ( 5 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_triangle", mod_raylib_draw_triangle, MRB_ARGS_REQ( 4 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_triangle_lines", mod_raylib_draw_triangle_lines, MRB_ARGS_REQ( 4 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_triangle_fan", mod_raylib_draw_triangle_fan, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_triangle_strip", mod_raylib_draw_triangle_strip, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_poly", mod_raylib_draw_poly, MRB_ARGS_REQ( 5 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_poly_lines", mod_raylib_draw_poly_lines, MRB_ARGS_REQ( 5 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_poly_lines_ex", mod_raylib_draw_poly_lines_ex, MRB_ARGS_REQ( 6 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_spline_linear", mod_raylib_draw_spline_linear, MRB_ARGS_REQ( 4 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_spline_basis", mod_raylib_draw_spline_basis, MRB_ARGS_REQ( 4 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_spline_catmull_rom", mod_raylib_draw_spline_catmull_rom, MRB_ARGS_REQ( 4 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_spline_bezier_quadratic", mod_raylib_draw_spline_bezier_quadratic, MRB_ARGS_REQ( 4 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_spline_bezier_cubic", mod_raylib_draw_spline_bezier_cubic, MRB_ARGS_REQ( 4 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_spline_segment_linear", mod_raylib_draw_spline_segment_linear, MRB_ARGS_REQ( 4 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_spline_segment_basis", mod_raylib_draw_spline_segment_basis, MRB_ARGS_REQ( 6 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_spline_segment_catmull_rom", mod_raylib_draw_spline_segment_catmull_rom, MRB_ARGS_REQ( 6 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_spline_segment_bezier_quadratic", mod_raylib_draw_spline_segment_bezier_quadratic, MRB_ARGS_REQ( 5 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_spline_segment_bezier_cubic", mod_raylib_draw_spline_segment_bezier_cubic, MRB_ARGS_REQ( 6 ) );
	mrb_define_module_function( mrb, mod_RayLib, "get_spline_point_linear", mod_raylib_get_spline_point_linear, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "get_spline_point_basis", mod_raylib_get_spline_point_basis, MRB_ARGS_REQ( 5 ) );
	mrb_define_module_function( mrb, mod_RayLib, "get_spline_point_catmull_rom", mod_raylib_get_spline_point_catmull_rom, MRB_ARGS_REQ( 5 ) );
	mrb_define_module_function( mrb, mod_RayLib, "get_spline_point_bezier_quad", mod_raylib_get_spline_point_bezier_quad, MRB_ARGS_REQ( 4 ) );
	mrb_define_module_function( mrb, mod_RayLib, "get_spline_point_bezier_cubic", mod_raylib_get_spline_point_bezier_cubic, MRB_ARGS_REQ( 5 ) );
	mrb_define_module_function( mrb, mod_RayLib, "check_collision_recs", mod_raylib_check_collision_recs, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "check_collision_circles", mod_raylib_check_collision_circles, MRB_ARGS_REQ( 4 ) );
	mrb_define_module_function( mrb, mod_RayLib, "check_collision_circle_rec", mod_raylib_check_collision_circle_rec, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "check_collision_point_rec", mod_raylib_check_collision_point_rec, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "check_collision_point_circle", mod_raylib_check_collision_point_circle, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "check_collision_point_triangle", mod_raylib_check_collision_point_triangle, MRB_ARGS_REQ( 4 ) );
	mrb_define_module_function( mrb, mod_RayLib, "check_collision_point_poly", mod_raylib_check_collision_point_poly, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "check_collision_lines", mod_raylib_check_collision_lines, MRB_ARGS_REQ( 5 ) );
	mrb_define_module_function( mrb, mod_RayLib, "check_collision_point_line", mod_raylib_check_collision_point_line, MRB_ARGS_REQ( 4 ) );
	mrb_define_module_function( mrb, mod_RayLib, "get_collision_rec", mod_raylib_get_collision_rec, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "load_image", mod_raylib_load_image, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "load_image_raw", mod_raylib_load_image_raw, MRB_ARGS_REQ( 5 ) );
	mrb_define_module_function( mrb, mod_RayLib, "load_image_svg", mod_raylib_load_image_svg, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "load_image_anim", mod_raylib_load_image_anim, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "load_image_from_memory", mod_raylib_load_image_from_memory, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "load_image_from_texture", mod_raylib_load_image_from_texture, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "load_image_from_screen", mod_raylib_load_image_from_screen, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "is_image_ready", mod_raylib_is_image_ready, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "unload_image", mod_raylib_unload_image, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "export_image", mod_raylib_export_image, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "export_image_to_memory", mod_raylib_export_image_to_memory, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "export_image_as_code", mod_raylib_export_image_as_code, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "gen_image_color", mod_raylib_gen_image_color, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "gen_image_gradient_linear", mod_raylib_gen_image_gradient_linear, MRB_ARGS_REQ( 5 ) );
	mrb_define_module_function( mrb, mod_RayLib, "gen_image_gradient_radial", mod_raylib_gen_image_gradient_radial, MRB_ARGS_REQ( 5 ) );
	mrb_define_module_function( mrb, mod_RayLib, "gen_image_gradient_square", mod_raylib_gen_image_gradient_square, MRB_ARGS_REQ( 5 ) );
	mrb_define_module_function( mrb, mod_RayLib, "gen_image_checked", mod_raylib_gen_image_checked, MRB_ARGS_REQ( 6 ) );
	mrb_define_module_function( mrb, mod_RayLib, "gen_image_white_noise", mod_raylib_gen_image_white_noise, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "gen_image_perlin_noise", mod_raylib_gen_image_perlin_noise, MRB_ARGS_REQ( 5 ) );
	mrb_define_module_function( mrb, mod_RayLib, "gen_image_cellular", mod_raylib_gen_image_cellular, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "gen_image_text", mod_raylib_gen_image_text, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "image_copy", mod_raylib_image_copy, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "image_from_image", mod_raylib_image_from_image, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "image_text", mod_raylib_image_text, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "image_text_ex", mod_raylib_image_text_ex, MRB_ARGS_REQ( 5 ) );
	mrb_define_module_function( mrb, mod_RayLib, "image_format", mod_raylib_image_format, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "image_to_pot", mod_raylib_image_to_pot, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "image_crop", mod_raylib_image_crop, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "image_alpha_crop", mod_raylib_image_alpha_crop, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "image_alpha_clear", mod_raylib_image_alpha_clear, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "image_alpha_mask", mod_raylib_image_alpha_mask, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "image_alpha_premultiply", mod_raylib_image_alpha_premultiply, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "image_blur_gaussian", mod_raylib_image_blur_gaussian, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "image_resize", mod_raylib_image_resize, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "image_resize_nn", mod_raylib_image_resize_nn, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "image_resize_canvas", mod_raylib_image_resize_canvas, MRB_ARGS_REQ( 6 ) );
	mrb_define_module_function( mrb, mod_RayLib, "image_mipmaps", mod_raylib_image_mipmaps, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "image_dither", mod_raylib_image_dither, MRB_ARGS_REQ( 5 ) );
	mrb_define_module_function( mrb, mod_RayLib, "image_flip_vertical", mod_raylib_image_flip_vertical, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "image_flip_horizontal", mod_raylib_image_flip_horizontal, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "image_rotate", mod_raylib_image_rotate, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "image_rotate_cw", mod_raylib_image_rotate_cw, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "image_rotate_ccw", mod_raylib_image_rotate_ccw, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "image_color_tint", mod_raylib_image_color_tint, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "image_color_invert", mod_raylib_image_color_invert, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "image_color_grayscale", mod_raylib_image_color_grayscale, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "image_color_contrast", mod_raylib_image_color_contrast, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "image_color_brightness", mod_raylib_image_color_brightness, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "image_color_replace", mod_raylib_image_color_replace, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "load_image_colors", mod_raylib_load_image_colors, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "load_image_palette", mod_raylib_load_image_palette, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "unload_image_colors", mod_raylib_unload_image_colors, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "unload_image_palette", mod_raylib_unload_image_palette, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "get_image_alpha_border", mod_raylib_get_image_alpha_border, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "get_image_color", mod_raylib_get_image_color, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "image_clear_background", mod_raylib_image_clear_background, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "image_draw_pixel", mod_raylib_image_draw_pixel, MRB_ARGS_REQ( 4 ) );
	mrb_define_module_function( mrb, mod_RayLib, "image_draw_pixel_v", mod_raylib_image_draw_pixel_v, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "image_draw_line", mod_raylib_image_draw_line, MRB_ARGS_REQ( 6 ) );
	mrb_define_module_function( mrb, mod_RayLib, "image_draw_line_v", mod_raylib_image_draw_line_v, MRB_ARGS_REQ( 4 ) );
	mrb_define_module_function( mrb, mod_RayLib, "image_draw_circle", mod_raylib_image_draw_circle, MRB_ARGS_REQ( 5 ) );
	mrb_define_module_function( mrb, mod_RayLib, "image_draw_circle_v", mod_raylib_image_draw_circle_v, MRB_ARGS_REQ( 4 ) );
	mrb_define_module_function( mrb, mod_RayLib, "image_draw_circle_lines", mod_raylib_image_draw_circle_lines, MRB_ARGS_REQ( 5 ) );
	mrb_define_module_function( mrb, mod_RayLib, "image_draw_circle_lines_v", mod_raylib_image_draw_circle_lines_v, MRB_ARGS_REQ( 4 ) );
	mrb_define_module_function( mrb, mod_RayLib, "image_draw_rectangle", mod_raylib_image_draw_rectangle, MRB_ARGS_REQ( 6 ) );
	mrb_define_module_function( mrb, mod_RayLib, "image_draw_rectangle_v", mod_raylib_image_draw_rectangle_v, MRB_ARGS_REQ( 4 ) );
	mrb_define_module_function( mrb, mod_RayLib, "image_draw_rectangle_rec", mod_raylib_image_draw_rectangle_rec, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "image_draw_rectangle_lines", mod_raylib_image_draw_rectangle_lines, MRB_ARGS_REQ( 4 ) );
	mrb_define_module_function( mrb, mod_RayLib, "image_draw", mod_raylib_image_draw, MRB_ARGS_REQ( 5 ) );
	mrb_define_module_function( mrb, mod_RayLib, "image_draw_text", mod_raylib_image_draw_text, MRB_ARGS_REQ( 6 ) );
	mrb_define_module_function( mrb, mod_RayLib, "image_draw_text_ex", mod_raylib_image_draw_text_ex, MRB_ARGS_REQ( 7 ) );
	mrb_define_module_function( mrb, mod_RayLib, "load_texture", mod_raylib_load_texture, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "load_texture_from_image", mod_raylib_load_texture_from_image, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "load_texture_cubemap", mod_raylib_load_texture_cubemap, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "load_render_texture", mod_raylib_load_render_texture, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "is_texture_ready", mod_raylib_is_texture_ready, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "unload_texture", mod_raylib_unload_texture, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "is_render_texture_ready", mod_raylib_is_render_texture_ready, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "unload_render_texture", mod_raylib_unload_render_texture, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "update_texture", mod_raylib_update_texture, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "update_texture_rec", mod_raylib_update_texture_rec, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "gen_texture_mipmaps", mod_raylib_gen_texture_mipmaps, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "set_texture_filter", mod_raylib_set_texture_filter, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "set_texture_wrap", mod_raylib_set_texture_wrap, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_texture", mod_raylib_draw_texture, MRB_ARGS_REQ( 4 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_texture_v", mod_raylib_draw_texture_v, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_texture_ex", mod_raylib_draw_texture_ex, MRB_ARGS_REQ( 5 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_texture_rec", mod_raylib_draw_texture_rec, MRB_ARGS_REQ( 4 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_texture_pro", mod_raylib_draw_texture_pro, MRB_ARGS_REQ( 6 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_texture_npatch", mod_raylib_draw_texture_npatch, MRB_ARGS_REQ( 6 ) );
	mrb_define_module_function( mrb, mod_RayLib, "fade", mod_raylib_fade, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "color_to_int", mod_raylib_color_to_int, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "color_normalize", mod_raylib_color_normalize, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "color_from_normalized", mod_raylib_color_from_normalized, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "color_to_hsv", mod_raylib_color_to_hsv, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "color_from_hsv", mod_raylib_color_from_hsv, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "color_tint", mod_raylib_color_tint, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "color_brightness", mod_raylib_color_brightness, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "color_contrast", mod_raylib_color_contrast, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "color_alpha", mod_raylib_color_alpha, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "color_alpha_blend", mod_raylib_color_alpha_blend, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "get_color", mod_raylib_get_color, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "get_pixel_color", mod_raylib_get_pixel_color, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "set_pixel_color", mod_raylib_set_pixel_color, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "get_pixel_data_size", mod_raylib_get_pixel_data_size, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "get_font_default", mod_raylib_get_font_default, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "load_font", mod_raylib_load_font, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "load_font_ex", mod_raylib_load_font_ex, MRB_ARGS_REQ( 4 ) );
	mrb_define_module_function( mrb, mod_RayLib, "load_font_from_image", mod_raylib_load_font_from_image, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "load_font_from_memory", mod_raylib_load_font_from_memory, MRB_ARGS_REQ( 6 ) );
	mrb_define_module_function( mrb, mod_RayLib, "is_font_ready", mod_raylib_is_font_ready, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "load_font_data", mod_raylib_load_font_data, MRB_ARGS_REQ( 6 ) );
	mrb_define_module_function( mrb, mod_RayLib, "gen_image_font_atlas", mod_raylib_gen_image_font_atlas, MRB_ARGS_REQ( 6 ) );
	mrb_define_module_function( mrb, mod_RayLib, "unload_font_data", mod_raylib_unload_font_data, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "unload_font", mod_raylib_unload_font, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "export_font_as_code", mod_raylib_export_font_as_code, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_fps", mod_raylib_draw_fps, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_text", mod_raylib_draw_text, MRB_ARGS_REQ( 5 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_text_ex", mod_raylib_draw_text_ex, MRB_ARGS_REQ( 6 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_text_pro", mod_raylib_draw_text_pro, MRB_ARGS_REQ( 8 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_text_codepoint", mod_raylib_draw_text_codepoint, MRB_ARGS_REQ( 5 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_text_codepoints", mod_raylib_draw_text_codepoints, MRB_ARGS_REQ( 7 ) );
	mrb_define_module_function( mrb, mod_RayLib, "set_text_line_spacing", mod_raylib_set_text_line_spacing, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "measure_text", mod_raylib_measure_text, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "measure_text_ex", mod_raylib_measure_text_ex, MRB_ARGS_REQ( 4 ) );
	mrb_define_module_function( mrb, mod_RayLib, "get_glyph_index", mod_raylib_get_glyph_index, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "get_glyph_info", mod_raylib_get_glyph_info, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "get_glyph_atlas_rec", mod_raylib_get_glyph_atlas_rec, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "load_utf8", mod_raylib_load_utf8, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "unload_utf8", mod_raylib_unload_utf8, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "load_codepoints", mod_raylib_load_codepoints, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "unload_codepoints", mod_raylib_unload_codepoints, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "get_codepoint_count", mod_raylib_get_codepoint_count, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "get_codepoint", mod_raylib_get_codepoint, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "get_codepoint_next", mod_raylib_get_codepoint_next, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "get_codepoint_previous", mod_raylib_get_codepoint_previous, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "codepoint_to_utf8", mod_raylib_codepoint_to_utf8, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "text_copy", mod_raylib_text_copy, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "text_is_equal", mod_raylib_text_is_equal, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "text_length", mod_raylib_text_length, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "text_format", mod_raylib_text_format, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "text_subtext", mod_raylib_text_subtext, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "text_replace", mod_raylib_text_replace, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "text_insert", mod_raylib_text_insert, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "text_join", mod_raylib_text_join, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "text_split", mod_raylib_text_split, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "text_append", mod_raylib_text_append, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "text_find_index", mod_raylib_text_find_index, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "text_to_upper", mod_raylib_text_to_upper, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "text_to_lower", mod_raylib_text_to_lower, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "text_to_pascal", mod_raylib_text_to_pascal, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "text_to_integer", mod_raylib_text_to_integer, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_line3_d", mod_raylib_draw_line3_d, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_point3_d", mod_raylib_draw_point3_d, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_circle3_d", mod_raylib_draw_circle3_d, MRB_ARGS_REQ( 5 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_triangle3_d", mod_raylib_draw_triangle3_d, MRB_ARGS_REQ( 4 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_triangle_strip3_d", mod_raylib_draw_triangle_strip3_d, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_cube", mod_raylib_draw_cube, MRB_ARGS_REQ( 5 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_cube_v", mod_raylib_draw_cube_v, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_cube_wires", mod_raylib_draw_cube_wires, MRB_ARGS_REQ( 5 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_cube_wires_v", mod_raylib_draw_cube_wires_v, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_sphere", mod_raylib_draw_sphere, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_sphere_ex", mod_raylib_draw_sphere_ex, MRB_ARGS_REQ( 5 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_sphere_wires", mod_raylib_draw_sphere_wires, MRB_ARGS_REQ( 5 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_cylinder", mod_raylib_draw_cylinder, MRB_ARGS_REQ( 6 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_cylinder_ex", mod_raylib_draw_cylinder_ex, MRB_ARGS_REQ( 6 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_cylinder_wires", mod_raylib_draw_cylinder_wires, MRB_ARGS_REQ( 6 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_cylinder_wires_ex", mod_raylib_draw_cylinder_wires_ex, MRB_ARGS_REQ( 6 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_capsule", mod_raylib_draw_capsule, MRB_ARGS_REQ( 6 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_capsule_wires", mod_raylib_draw_capsule_wires, MRB_ARGS_REQ( 6 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_plane", mod_raylib_draw_plane, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_ray", mod_raylib_draw_ray, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_grid", mod_raylib_draw_grid, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "load_model", mod_raylib_load_model, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "load_model_from_mesh", mod_raylib_load_model_from_mesh, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "is_model_ready", mod_raylib_is_model_ready, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "unload_model", mod_raylib_unload_model, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "get_model_bounding_box", mod_raylib_get_model_bounding_box, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_model", mod_raylib_draw_model, MRB_ARGS_REQ( 4 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_model_ex", mod_raylib_draw_model_ex, MRB_ARGS_REQ( 6 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_model_wires", mod_raylib_draw_model_wires, MRB_ARGS_REQ( 4 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_model_wires_ex", mod_raylib_draw_model_wires_ex, MRB_ARGS_REQ( 6 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_bounding_box", mod_raylib_draw_bounding_box, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_billboard", mod_raylib_draw_billboard, MRB_ARGS_REQ( 5 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_billboard_rec", mod_raylib_draw_billboard_rec, MRB_ARGS_REQ( 6 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_billboard_pro", mod_raylib_draw_billboard_pro, MRB_ARGS_REQ( 9 ) );
	mrb_define_module_function( mrb, mod_RayLib, "upload_mesh", mod_raylib_upload_mesh, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "update_mesh_buffer", mod_raylib_update_mesh_buffer, MRB_ARGS_REQ( 5 ) );
	mrb_define_module_function( mrb, mod_RayLib, "unload_mesh", mod_raylib_unload_mesh, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_mesh", mod_raylib_draw_mesh, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "draw_mesh_instanced", mod_raylib_draw_mesh_instanced, MRB_ARGS_REQ( 4 ) );
	mrb_define_module_function( mrb, mod_RayLib, "export_mesh", mod_raylib_export_mesh, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "get_mesh_bounding_box", mod_raylib_get_mesh_bounding_box, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "gen_mesh_tangents", mod_raylib_gen_mesh_tangents, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "gen_mesh_poly", mod_raylib_gen_mesh_poly, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "gen_mesh_plane", mod_raylib_gen_mesh_plane, MRB_ARGS_REQ( 4 ) );
	mrb_define_module_function( mrb, mod_RayLib, "gen_mesh_cube", mod_raylib_gen_mesh_cube, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "gen_mesh_sphere", mod_raylib_gen_mesh_sphere, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "gen_mesh_hemi_sphere", mod_raylib_gen_mesh_hemi_sphere, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "gen_mesh_cylinder", mod_raylib_gen_mesh_cylinder, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "gen_mesh_cone", mod_raylib_gen_mesh_cone, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "gen_mesh_torus", mod_raylib_gen_mesh_torus, MRB_ARGS_REQ( 4 ) );
	mrb_define_module_function( mrb, mod_RayLib, "gen_mesh_knot", mod_raylib_gen_mesh_knot, MRB_ARGS_REQ( 4 ) );
	mrb_define_module_function( mrb, mod_RayLib, "gen_mesh_heightmap", mod_raylib_gen_mesh_heightmap, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "gen_mesh_cubicmap", mod_raylib_gen_mesh_cubicmap, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "load_materials", mod_raylib_load_materials, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "load_material_default", mod_raylib_load_material_default, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "is_material_ready", mod_raylib_is_material_ready, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "unload_material", mod_raylib_unload_material, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "set_material_texture", mod_raylib_set_material_texture, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "set_model_mesh_material", mod_raylib_set_model_mesh_material, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "load_model_animations", mod_raylib_load_model_animations, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "update_model_animation", mod_raylib_update_model_animation, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "unload_model_animation", mod_raylib_unload_model_animation, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "unload_model_animations", mod_raylib_unload_model_animations, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "is_model_animation_valid", mod_raylib_is_model_animation_valid, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "check_collision_spheres", mod_raylib_check_collision_spheres, MRB_ARGS_REQ( 4 ) );
	mrb_define_module_function( mrb, mod_RayLib, "check_collision_boxes", mod_raylib_check_collision_boxes, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "check_collision_box_sphere", mod_raylib_check_collision_box_sphere, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "get_ray_collision_sphere", mod_raylib_get_ray_collision_sphere, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "get_ray_collision_box", mod_raylib_get_ray_collision_box, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "get_ray_collision_mesh", mod_raylib_get_ray_collision_mesh, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "get_ray_collision_triangle", mod_raylib_get_ray_collision_triangle, MRB_ARGS_REQ( 4 ) );
	mrb_define_module_function( mrb, mod_RayLib, "get_ray_collision_quad", mod_raylib_get_ray_collision_quad, MRB_ARGS_REQ( 5 ) );
	mrb_define_module_function( mrb, mod_RayLib, "init_audio_device", mod_raylib_init_audio_device, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "close_audio_device", mod_raylib_close_audio_device, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "is_audio_device_ready", mod_raylib_is_audio_device_ready, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "set_master_volume", mod_raylib_set_master_volume, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "get_master_volume", mod_raylib_get_master_volume, MRB_ARGS_NONE() );
	mrb_define_module_function( mrb, mod_RayLib, "load_wave", mod_raylib_load_wave, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "load_wave_from_memory", mod_raylib_load_wave_from_memory, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "is_wave_ready", mod_raylib_is_wave_ready, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "load_sound", mod_raylib_load_sound, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "load_sound_from_wave", mod_raylib_load_sound_from_wave, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "load_sound_alias", mod_raylib_load_sound_alias, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "is_sound_ready", mod_raylib_is_sound_ready, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "update_sound", mod_raylib_update_sound, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "unload_wave", mod_raylib_unload_wave, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "unload_sound", mod_raylib_unload_sound, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "unload_sound_alias", mod_raylib_unload_sound_alias, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "export_wave", mod_raylib_export_wave, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "export_wave_as_code", mod_raylib_export_wave_as_code, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "play_sound", mod_raylib_play_sound, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "stop_sound", mod_raylib_stop_sound, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "pause_sound", mod_raylib_pause_sound, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "resume_sound", mod_raylib_resume_sound, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "is_sound_playing", mod_raylib_is_sound_playing, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "set_sound_volume", mod_raylib_set_sound_volume, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "set_sound_pitch", mod_raylib_set_sound_pitch, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "set_sound_pan", mod_raylib_set_sound_pan, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "wave_copy", mod_raylib_wave_copy, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "wave_crop", mod_raylib_wave_crop, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "wave_format", mod_raylib_wave_format, MRB_ARGS_REQ( 4 ) );
	mrb_define_module_function( mrb, mod_RayLib, "load_wave_samples", mod_raylib_load_wave_samples, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "unload_wave_samples", mod_raylib_unload_wave_samples, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "load_music_stream", mod_raylib_load_music_stream, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "load_music_stream_from_memory", mod_raylib_load_music_stream_from_memory, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "is_music_ready", mod_raylib_is_music_ready, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "unload_music_stream", mod_raylib_unload_music_stream, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "play_music_stream", mod_raylib_play_music_stream, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "is_music_stream_playing", mod_raylib_is_music_stream_playing, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "update_music_stream", mod_raylib_update_music_stream, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "stop_music_stream", mod_raylib_stop_music_stream, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "pause_music_stream", mod_raylib_pause_music_stream, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "resume_music_stream", mod_raylib_resume_music_stream, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "seek_music_stream", mod_raylib_seek_music_stream, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "set_music_volume", mod_raylib_set_music_volume, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "set_music_pitch", mod_raylib_set_music_pitch, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "set_music_pan", mod_raylib_set_music_pan, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "get_music_time_length", mod_raylib_get_music_time_length, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "get_music_time_played", mod_raylib_get_music_time_played, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "load_audio_stream", mod_raylib_load_audio_stream, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "is_audio_stream_ready", mod_raylib_is_audio_stream_ready, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "unload_audio_stream", mod_raylib_unload_audio_stream, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "update_audio_stream", mod_raylib_update_audio_stream, MRB_ARGS_REQ( 3 ) );
	mrb_define_module_function( mrb, mod_RayLib, "is_audio_stream_processed", mod_raylib_is_audio_stream_processed, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "play_audio_stream", mod_raylib_play_audio_stream, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "pause_audio_stream", mod_raylib_pause_audio_stream, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "resume_audio_stream", mod_raylib_resume_audio_stream, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "is_audio_stream_playing", mod_raylib_is_audio_stream_playing, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "stop_audio_stream", mod_raylib_stop_audio_stream, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "set_audio_stream_volume", mod_raylib_set_audio_stream_volume, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "set_audio_stream_pitch", mod_raylib_set_audio_stream_pitch, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "set_audio_stream_pan", mod_raylib_set_audio_stream_pan, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "set_audio_stream_buffer_size_default", mod_raylib_set_audio_stream_buffer_size_default, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "set_audio_stream_callback", mod_raylib_set_audio_stream_callback, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "attach_audio_stream_processor", mod_raylib_attach_audio_stream_processor, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "detach_audio_stream_processor", mod_raylib_detach_audio_stream_processor, MRB_ARGS_REQ( 2 ) );
	mrb_define_module_function( mrb, mod_RayLib, "attach_audio_mixed_processor", mod_raylib_attach_audio_mixed_processor, MRB_ARGS_REQ( 1 ) );
	mrb_define_module_function( mrb, mod_RayLib, "detach_audio_mixed_processor", mod_raylib_detach_audio_mixed_processor, MRB_ARGS_REQ( 1 ) );

}

void
mrb_raylib_gem_init( mrb_state *mrb ) {

}

void
mrb_raylib_struct_init( mrb_state *mrb ) {

}

void
mrb_raylib_module_final( mrb_state *mrb ) {

}
